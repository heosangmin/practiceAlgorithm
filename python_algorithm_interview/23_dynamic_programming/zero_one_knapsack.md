# 0-1 배낭 문제
피보나치 수열과 더불어 다이나믹 프로그래밍의 대표적인 문제인 배낭 문제를 살펴보자. 그리디 알고리즘에서는 "분할 가능 배낭 문제(Fractional Knapsack Problem)"을 풀어 보았는데, 이는 "탐욕 선택 속성"이 있는 문제였지만, 이번에는 짐을 쪼갤 수 없는 "0-1 배낭 문제"를 풀이해 보자. 이 문제는 "탐욕 선택 속성"은 없고 "중복된 하위 문제들" 속성을 가지고 있으므로 다이나믹 프로그래밍으로 풀 수 있다.

단가 순으로 그리디하게 배치해서 풀이했던 분할 가능 배낭 문제와 달리, 0-1 배낭 문제는 짐을 쪼갤 수 없다. 이 경우 모든 경우의 수를 계산해야 하며, 이렇게 모든 경우의 수를 계산하는 문제에서 다이나믹 프로그래밍은 위력을 발휘한다.

먼저 입력값으로 짐을 정의하고 zero_one_kanpsack() 풀이 함수를 호출한다.
```python
cargo = [
    (4, 12),
    (2, 1),
    (10, 4),
    (1, 1),
    (2, 2)
]

r = zero_one_knapsack(cargo)
```

zero_one_kanpsack() 함수는 다음과 같이 정의한다.
```python
def zero_one_knapsack(cargo)
    capacity = 15
    pack = []
    ...
```

pack이라는 리스트 변수에 6x16 행렬 형태의 중간 결과 테이블이 생성될 것이다. 즉 이 테이블은 글자 그대로 타뷸레이션하는 다이나믹 프로그래밍 풀이가 될 것이다. 테이블 크기의 기준은 짐의 개수 +1, 배낭의 최대 용량 +1 이렇게 6x16이며, 이 테이블 각각의 셀에는 그 위치까지의 짐의 개수와 배낭의 용량에 따른 최댓값이 담기게 된다.

```python
def zero_one_knapsack(cargo):
    capacity = 15
    pack = []

    for i in range(len(cargo) + 1):
        pack.append([])
        for c in range(capacity + 1):
            if i == 0 or c == 0:
                pack[i].append(0)
            elif cargo[i - 1][1] <= c:
                pack[i].append(
                    max(
                        cargo[i - 1][0] + pack[i - 1][c - cargo[i - 1][1]],
                        pack[i - 1][c]
                    )
                )
            else:
                pack[i].append(pack[i - 1][c])
    return pack[-1][-1]
```

||0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**0**|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|
|**1**|0|0|0|0|0|0|0|0|0|0|0|0|4|4|4|4|
|**2**|0|2|2|2|2|2|2|2|2|2|2|2|4|6|6|6|
|**3**|0|2|2|2|10|12|12|12|12|12|12|12|12|12|12|12|
|**4**|0|2|3|3|10|12|13|13|13|13|13|13|13|13|13|13|
|**5**|0|2|3|4|10|12|13|14|15|15|15|15|15|15|15|15|

이 표에서 세로축은 짐의 개수, 가로축은 배낭의 용량이다. 각각의 셀은 그 위치까지의 짐의 개수와 배낭의 용량에 따른 최댓값이다. 즉 짐이 4개가 있을 때는 차례대로 ($4, 12kg), ($2, 1kg), ($10, 4kg), ($1, 1kg)일 것이고, 배낭의 용량이 4라면 4kg인 10$짜리 짐 하나를 담는 게 가장 이익이다. 따라서 4x4 위치의 최댓값은 10이며 위의 표에서도 10인 것을 확인할 수 있다. 배낭의 용량이 5라면 1kg인 $2를 추가해 12가 될 수 있다. 이렇게 가장 마지막 위치인 5x15까지 이동한 총 5개의 짐, 용량이 15인 배낭의 최댓값은 15이며, 이 문제의 정답은 15임을 확인할 수 있다. 이렇게 최악의 경우 O(2^n)의 계산이 필요한 0-1 배낭 문제를 여기서는 타뷸레이션 방식으로 O(nW) (여기서 n은 짐의 개수, W는 배낭의 용량)에 풀이해봤다.
