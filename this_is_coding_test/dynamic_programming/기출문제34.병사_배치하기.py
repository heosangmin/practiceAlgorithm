'''
2022/05/27

7
15 11 4 8 5 2 4
-> 2

이 문제의 기본 아이디어는 '가장 긴 증가하는 부분 수열(LIS, Longest Increasing Subsequence)로 알려진 전형적인 다이나믹 프로그래밍 문제의 아이디어와 같다. '가장 긴 증가하는 부분 수열' 문제랑, 하나의 수열이 주어졌을 때 값들이 증가하는 형태의 가장 긴 부분 수열을 찾는 문제이다.

예를 들어 하나의 수열 array = {10,20,10,30,20,50}이 있다고 하자. 이때 가장 긴 증가하는 부분 수열은 {10,20,30,50}이 될 것이다. 'D[i] = array[i]를 마지막으로 가지는 부분 수열의 최대 길이'라고 정의하면, 가장 긴 증가하는 부분 수열을 계산하는 점화식은 다음과 같다. 이때 초기의 DP 테이블의 값은 모두 1로 초기화한다.

모든 0 <= j < i 에 대하여, D[i] = max(D[i], D[j]+1) if array[j] < array[i]

테이블이 갱신되는 과정을 확인해보자. i를 1부터 n-1까지 증가시키며, 점화식에 따라 테이블을 갱신했을 때의 결과는 다음과 같다.

data 10 20 10 30 20 50
init  1  1  1  1  1  1
i=1   1 '2' 1  1  1  1
i=2   1  2 '1' 1  1  1
i=3   1  2  1 '3' 1  1
i=4   1  2  1  3 '2' 1
i=5   1  2  1  3  2 '4'

최종적으로 테이블의 값은 [1,2,1,3,2,4]이고, 이렇게 테이블에 남아 있는 값 중에서 가장 큰 값이 가장 긴 증가하는 부분 수열의 길이이다. 즉, 현재 예시에서는 4가 최장 길이가 된다.

우리가 풀어야 하는 문제는 병사를 배치할 때 전투력이 높은 병사가 앞쪽에 오도록 내림차순 배치를 하고자 한다. 따라서 이 문제를 '가장 긴 감소하는 부분 수열'의 길이를 계산하는 문제로 간주하고, 입력으로 주어진 원소의 순서를 뒤집은 뒤에 '가장 긴 증가하는 부분 수열'문제를 풀 때의 점화식을 그대로 적용하면 해결할 수 있다.
'''

n = int(input())
array = list(map(int, input().split()))

# 순서를 뒤집어 '가장 긴 증가하는 부분 수열' 문제로 변환
array.reverse()

# 다이나믹 프로그래밍을 위한 1차원 DP 테이블 초기화
dp = [1] * n

# 가장 긴 증가하는 부분 수열(LIS) 알고리즘 수행
for i in range(1, n):
    for j in range(0, i):
        if array[j] < array[i]:
            dp[i] = max([dp[i], dp[j]+1])

# 열외시켜야 하는 병사의 최소 수를 출력
print(n - max(dp))
