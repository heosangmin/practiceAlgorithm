# 14장 이진 탐색 트리

이진 탐색 트리(BST)는 배열과 비슷하지만 저장된 값(키)이 정렬되어 있다. 이진 탐색 트리에서 키값을 탐색할 수도 있고 최솟값 혹은 최댓값을 찾을 수도 있다. 탐색할 키값(꼭 이진 탐색 트리에 없어도 된다)의 전임자(predecessor) 혹은 후임자(successor)를 찾을 수도 있고, 정해진 범위에서 키값을 정렬된 상태로 나열할 수도 있다. 또한 정렬된 배열과 다르게 이진 탐색 트리에서는 원소를 추가하거나 삭제하는 작업을 효율적으로 할 수 있다.

이진 탐색 트리는 9장에서 말한 것처럼 비교 가능한(예를 들어 정수값이나 문자열) 키가 노드에 저장된 이진 트리를 말한다. 노드에 저장된 키는 이진 탐색 트리의 속성을 만족해야 한다. 어떤 노드의 키값은 그 노드보다 왼쪽에 놓인 부분 트리의 노드 키값보다 커야 하고, 오른쪽에 놓인 부분 트리의 노드 키값보다 작거나 같아야 한다. 그림 14.1에는 첫 16개의 소수를 키값으로 하는 이진 탐색 트리가 예제로 주어졌다.

탐색, 삽입, 삭제 연산의 시간 복잡도는 트리의 높이에 비례한다. 따라서 삽입과 삭제를 단순하게 구현하면 최악의 경우에 $O(n)$이 될 수도 있다. 하지만 트리의 높이 상한을 $O(\log n)$으로 유지하는 삽입 및 삭제 구현 방식이 존재한다. 이를 위해선 트리의 노드에서 추가적인 데이터를 저장하거나 갱신하기도 한다. 레드-블랙 트리는 높이가 균형 잡힌 이진 트리의 한 예제이며 자료구조 라이브러리에서 널리 사용되고 있다.

이진 탐색 트리의 흔한 실수 중 하나는 이진 탐색 트리의 객체를 갱신할 때 생긴다. 객체가 이진 탐색 트리에 존재하더라도 제대로 찾지 못하는 경우가 발생하는 것이다. 이진 탐색 트리의 객체를 갱신할 때는, 일단 트리에서 해당 객체를 삭제한 뒤 다시 추가해야 한다. (일반적으로 수정 가능한 객체는 이진 탐색 트리에 집어 넣지 않도록 하자.)

다음은 이진 탐색 트리의 프로토타입이다.

```java
public class BSTNode<T> {
    public T data;
    public BSTNode<T> left, right;
}
```

## 이진 탐색 트리 부트 캠프

이진 탐색 트리가 사용되는 가장 기본적인 예는 탐색이다. 해시 테이블과 달리 이진 탐색 트리에서는 최솟값과 최댓값을 찾을 수 있고, 그 다음으로 큰 원소 혹은 그 다음으로 작은 원소를 찾을 수도 있다. 이러한 연산은 라이브러리에 구현된 이진 탐색 트리를 사용하면 탐색, 삭제, 연산과 마찬가지로 $O(\log n)$의 시간이 걸린다. 이진 탐색 트리와 해시 테이블 모두 $O(n)$의 공간을 사용하지만, 실제로 이진 탐색 트리는 공간을 그보다 조금 더 사용한다.

다음 프로그램은 주어진 값이 이진 탐색 트리에 존재하는지 확인하는 프로그램이다. 이진 탐색 트리에서 연산을 수행할 때 재귀가 얼마나 강력한지 보여 준다.

```java
public static BSTNode<Integer> searchBST(BSTNode<Integer> tree, int key) {
    return tree == null || tree.data == key
        ? tree
        : key < tree.data ? searchBST(tree.left, key)
                          : searchBST(tree.right, key);
}
```

이 프로그램은 각 단계마다 트리의 밑으로 내려가고, 각 높이에서 $O(1)$ 시간을 사용하므로 전체 시간 복잡도는 $O(h)$가 된다. 여기서 h는 트리의 높이를 말한다.

## 이진 탐색 트리 문제를 풀기 전 꼭 알고 있어야 할 내용

- 이진 탐색 트리에서는 $O(n)$ 시간에 원소를 **정렬된 순서로 순회**할 수 있다.(균형이 잡혀 있지 않아도 된다.) [문제 14.2]
- 어떤 문제는 **이진 탐색 트리와 해시 테이블을 함께 사용**해야 한다. 예를 들어 학생 객체를 GPA를 기준으로 정렬해 이진 탐색 트리에 삽입했다고 가정하자. 이때 학생의 GPA를 갱신해야 한다면, 그리고 주어진 정보가 학생의 이름과 새로운 GPA뿐이라면, 학생의 이름으로 트리를 모두 순회해야 한다. 하지만 추가로 해시테이블을 사용한다면 필요한 노드에 직접 도달할 수 있다.
- 때로는 간격(interval)과 같은 더 복잡한 데이터를 제어하고, 범위의 요소 개수와 같은 더 복잡한 쿼리를 효과적으로 지원하기 위해 이진 탐색 트리를 **보강(augment)**할 필요가 있다. [문제 14.11]
- 이진 탐색 트리의 속성은 **전역적인(global) 속성**이다. 즉, 이진 트리는 각 노드의 키가 왼쪽 자식 키보다 크고 오른쪽 자식 키보다 작은 속성을 가질 수 있지만, 그렇더라도 이진 탐색 트리가 아닐 수 있다. [문제 14.1]

## 이진 탐색 트리 라이브러리 이해하기

Java에서 흔히 사용되는 이진 탐색 트리 기반 자료구조는 TreeSet과 TreeMap이다. TreeSet는 Set 인터페이스를 구현했고, TreeMap은 Map 인터페이스를 구현했다. Set와 Map의 기능을 다시 보려면 '12장 해시테이블'을 참고하라.

이진 탐색 트리에서는 키가 정렬되었다는 속성 때문에 TreeSet와 TreeMap의 기능은 Set와 Map보다 많은 기능을 제공한다. 먼저, TreeSet를 통해 원소를 삽입했을 때의 기능은 다음과 같다.

- iterator()에 의해 반환된 반복자(iterator)는 오름차순으로 키를 순회한다. (내림차순으로 순회하고 싶다면 descendingIterator()를 사용하면 된다.)
- first()와 last()는 트리에서 가장 작은 키와 가장 큰 키를 찾는다.
- lower(12)와 higher(3)은 각각 주어진 숫자보다 작은 숫자 중에서 가장 큰 수와 주어진 숫자보다 큰 숫자 중에서 가장 작은 숫자를 찾는다.
- floor(4.9)와 ceiling(5.7)은 주어진 숫자보다 작거나 같은 숫자 중에서 가장 큰 수와 주어진 숫자보다 크거나 같은 숫자 중에서 가장 작은 수를 찾는다.
- headSet(10), tailSet(5), subSet(1, 12)는 주어진 범위 안에 있는 키의 뷰를 반환한다. 기본적으로 트리에 기반하기 때문에 이들의 시간 복잡도가 $O(\log n)$이라는 사실이 특히 중요하다. 따라서 트리를 수정하면 뷰도 수정된다. 결국, size()와 같은 연산의 시간 복잡도도 $O(n)$이 된다.

언제나 그렇듯이 여기에도 미묘한 상황이 존재한다. 예를 들어 비어 있는 트리에서 first()가 어떻게 처리되는지, 널(null)인 경우에 lower()를 호출하면 어떻게 되는지, subSet()의 범위는 닫힌 구간인지 등의 상황이다.

TreeMap에 추가된 기능 중에서, floor(12)는 floorKey(12)와 비슷하고 headMap(28)은 hashSet(28)과 비슷하다.

TreeSet과 TreeMap의 생성자는 키의 순서를 정하는 데 필요한 비교 객체를 명시적으로 지정할 수 있으므로, 이 구문에 익숙해져야 한다. (13장 앞부분에 비교 객체의 구문이 예제로 나와 있다.)
