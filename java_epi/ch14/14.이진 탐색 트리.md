# 14장 이진 탐색 트리

이진 탐색 트리(BST)는 배열과 비슷하지만 저장된 값(키)이 정렬되어 있다. 이진 탐색 트리에서 키값을 탐색할 수도 있고 최솟값 혹은 최댓값을 찾을 수도 있다. 탐색할 키값(꼭 이진 탐색 트리에 없어도 된다)의 전임자(predecessor) 혹은 후임자(successor)를 찾을 수도 있고, 정해진 범위에서 키값을 정렬된 상태로 나열할 수도 있다. 또한 정렬된 배열과 다르게 이진 탐색 트리에서는 원소를 추가하거나 삭제하는 작업을 효율적으로 할 수 있다.

이진 탐색 트리는 9장에서 말한 것처럼 비교 가능한(예를 들어 정수값이나 문자열) 키가 노드에 저장된 이진 트리를 말한다. 노드에 저장된 키는 이진 탐색 트리의 속성을 만족해야 한다. 어떤 노드의 키값은 그 노드보다 왼쪽에 놓인 부분 트리의 노드 키값보다 커야 하고, 오른쪽에 놓인 부분 트리의 노드 키값보다 작거나 같아야 한다. 그림 14.1에는 첫 16개의 소수를 키값으로 하는 이진 탐색 트리가 예제로 주어졌다.

탐색, 삽입, 삭제 연산의 시간 복잡도는 트리의 높이에 비례한다. 따라서 삽입과 삭제를 단순하게 구현하면 최악의 경우에 $O(n)$이 될 수도 있다. 하지만 트리의 높이 상한을 $O(\log n)$으로 유지하는 삽입 및 삭제 구현 방식이 존재한다. 이를 위해선 트리의 노드에서 추가적인 데이터를 저장하거나 갱신하기도 한다. 레드-블랙 트리는 높이가 균형 잡힌 이진 트리의 한 예제이며 자료구조 라이브러리에서 널리 사용되고 있다.

이진 탐색 트리의 흔한 실수 중 하나는 이진 탐색 트리의 객체를 갱신할 때 생긴다. 객체가 이진 탐색 트리에 존재하더라도 제대로 찾지 못하는 경우가 발생하는 것이다. 이진 탐색 트리의 객체를 갱신할 때는, 일단 트리에서 해당 객체를 삭제한 뒤 다시 추가해야 한다. (일반적으로 수정 가능한 객체는 이진 탐색 트리에 집어 넣지 않도록 하자.)

다음은 이진 탐색 트리의 프로토타입이다.

```java
public class BSTNode<T> {
    public T data;
    public BSTNode<T> left, right;
}
```

## 이진 탐색 트리 부트 캠프

이진 탐색 트리가 사용되는 가장 기본적인 예는 탐색이다. 해시 테이블과 달리 이진 탐색 트리에서는 최솟값과 최댓값을 찾을 수 있고, 그 다음으로 큰 원소 혹은 그 다음으로 작은 원소를 찾을 수도 있다. 이러한 연산은 라이브러리에 구현된 이진 탐색 트리를 사용하면 탐색, 삭제, 연산과 마찬가지로 $O(\log n)$의 시간이 걸린다. 이진 탐색 트리와 해시 테이블 모두 $O(n)$의 공간을 사용하지만, 실제로 이진 탐색 트리는 공간을 그보다 조금 더 사용한다.

다음 프로그램은 주어진 값이 이진 탐색 트리에 존재하는지 확인하는 프로그램이다. 이진 탐색 트리에서 연산을 수행할 때 재귀가 얼마나 강력한지 보여 준다.

```java
public static BSTNode<Integer> searchBST(BSTNode<Integer> tree, int key) {
    return tree == null || tree.data == key
        ? tree
        : key < tree.data ? searchBST(tree.left, key)
                          : searchBST(tree.right, key);
}
```

이 프로그램은 각 단계마다 트리의 밑으로 내려가고, 각 높이에서 $O(1)$ 시간을 사용하므로 전체 시간 복잡도는 $O(h)$가 된다. 여기서 h는 트리의 높이를 말한다.

## 이진 탐색 트리 문제를 풀기 전 꼭 알고 있어야 할 내용

- 이진 탐색 트리에서는 $O(n)$ 시간에 원소를 **정렬된 순서로 순회**할 수 있다.(균형이 잡혀 있지 않아도 된다.) [문제 14.2]
- 어떤 문제는 **이진 탐색 트리와 해시 테이블을 함께 사용**해야 한다. 예를 들어 학생 객체를 GPA를 기준으로 정렬해 이진 탐색 트리에 삽입했다고 가정하자. 이때 학생의 GPA를 갱신해야 한다면, 그리고 주어진 정보가 학생의 이름과 새로운 GPA뿐이라면, 학생의 이름으로 트리를 모두 순회해야 한다. 하지만 추가로 해시테이블을 사용한다면 필요한 노드에 직접 도달할 수 있다.
- 때로는 간격(interval)과 같은 더 복잡한 데이터를 제어하고, 범위의 요소 개수와 같은 더 복잡한 쿼리를 효과적으로 지원하기 위해 이진 탐색 트리를 **보강(augment)**할 필요가 있다. [문제 14.11]
- 이진 탐색 트리의 속성은 **전역적인(global) 속성**이다. 즉, 이진 트리는 각 노드의 키가 왼쪽 자식 키보다 크고 오른쪽 자식 키보다 작은 속성을 가질 수 있지만, 그렇더라도 이진 탐색 트리가 아닐 수 있다. [문제 14.1]

## 이진 탐색 트리 라이브러리 이해하기

Java에서 흔히 사용되는 이진 탐색 트리 기반 자료구조는 TreeSet과 TreeMap이다. TreeSet는 Set 인터페이스를 구현했고, TreeMap은 Map 인터페이스를 구현했다. Set와 Map의 기능을 다시 보려면 '12장 해시테이블'을 참고하라.

이진 탐색 트리에서는 키가 정렬되었다는 속성 때문에 TreeSet와 TreeMap의 기능은 Set와 Map보다 많은 기능을 제공한다. 먼저, TreeSet를 통해 원소를 삽입했을 때의 기능은 다음과 같다.

- iterator()에 의해 반환된 반복자(iterator)는 오름차순으로 키를 순회한다. (내림차순으로 순회하고 싶다면 descendingIterator()를 사용하면 된다.)
- first()와 last()는 트리에서 가장 작은 키와 가장 큰 키를 찾는다.
- lower(12)와 higher(3)은 각각 주어진 숫자보다 작은 숫자 중에서 가장 큰 수와 주어진 숫자보다 큰 숫자 중에서 가장 작은 숫자를 찾는다.
- floor(4.9)와 ceiling(5.7)은 주어진 숫자보다 작거나 같은 숫자 중에서 가장 큰 수와 주어진 숫자보다 크거나 같은 숫자 중에서 가장 작은 수를 찾는다.
- headSet(10), tailSet(5), subSet(1, 12)는 주어진 범위 안에 있는 키의 뷰를 반환한다. 기본적으로 트리에 기반하기 때문에 이들의 시간 복잡도가 $O(\log n)$이라는 사실이 특히 중요하다. 따라서 트리를 수정하면 뷰도 수정된다. 결국, size()와 같은 연산의 시간 복잡도도 $O(n)$이 된다.

언제나 그렇듯이 여기에도 미묘한 상황이 존재한다. 예를 들어 비어 있는 트리에서 first()가 어떻게 처리되는지, 널(null)인 경우에 lower()를 호출하면 어떻게 되는지, subSet()의 범위는 닫힌 구간인지 등의 상황이다.

TreeMap에 추가된 기능 중에서, floor(12)는 floorKey(12)와 비슷하고 headMap(28)은 hashSet(28)과 비슷하다.

TreeSet과 TreeMap의 생성자는 키의 순서를 정하는 데 필요한 비교 객체를 명시적으로 지정할 수 있으므로, 이 구문에 익숙해져야 한다. (13장 앞부분에 비교 객체의 구문이 예제로 나와 있다.)

## 문제 14.1 이진 트리가 이진 탐색 트리의 속성을 만족하는지 확인하기

이진 트리가 입력으로 주어졌을 때 해당 트리가 이진 탐색 트리의 속성을 만족하는지 확인하는 프로그램을 작성하라.

> 힌트: 각 노드에 대해서 해당 노드의 키가 왼쪽 자식의 키보다 크거나 작은지 확인하고 오른쪽 자식의 키보다 작거나 같은지 확인하는 게 맞는 걸까?

직접적인 접근 방법은 먼저 이진 탐색 트리의 정의에 따라 루트에서 시작해서 루트의 왼쪽 부분 트리에서 가장 큰 키를 구하고 루트의 오른쪽 부분 트리에서 가장 작은 키를 구하는 것이다. 그다음 루트의 키가 왼쪽 부분 트리에서 가장 큰 키보다 크거나 같고 오른쪽 부분 트리에서 가장 작은 키보다 작거나 같은지 확인한다. 만약 두 조건을 모두 만족하면 루트의 왼쪽 부분 트리와 오른쪽 부분 트리를 재귀적으로 확인한다. 만약 하나라도 조건을 만족하지 않으면 false를 반환한다.

이진 트리에서 가장 작은 키를 찾는 작업은 단순하다. 루트, 왼쪽 부분 트리, 오른쪽 부분 트리에 저장된 키 중에서 가장 작은 키를 찾으면 된다. 가장 큰 키를 찾는 작업도 비슷하다. 일반적인 이진 트리는 이진 탐색 트리의 속성을 만족하지 않을 수 있으므로 최솟값을 찾을 때는 부분 트리의 키를 모두 확인해야 한다.

이 방법의 문제는 부분 트리를 반복해서 탐색한다는 점이다. 최악의 경우엔 한쪽으로 기울어져 있는 이진 탐색 트리의 경우에는 $O(n^2)$의 시간이 걸린다. 여기서 n은 노드의 개수이다. 캐시를 사용해서 각 노드에서 가장 작은 키와 가장 큰 키를 저장하고 있으면 $O(n)$ 시간으로 개선할 수 있다. 하지만 캐시를 사용하느라 $O(n)$의 추가 공간이 든다.

트리의 높이가 h일 때, 시간 복잡도는 $O(n)$이고 공간 복잡도는 $O(h)$가 되는 두 가지 방법을 소개할 것이다.

첫 번째 방법은 각 부분 트리에서 주어진 제약조건을 확인하는 것이다. 처음에는 루트에서 시작한다. 각 노드의 왼쪽(오른쪽) 부분 트리는 반드시 루트의 키보다 작거나 같아야(크거나 같아야) 한다. 이 사실을 일반화하면 다음과 같다. 트리에 있는 모든 노드의 키값 범위를 [l, u]라고 하고 루트의 키를 w라고 했을 때, w는 반드시 [l, u] 사이에 있어야 하고, 왼쪽 부분 트리는 [l, w] 사이에 있어야 하고, 오른쪽 부분 트리의 모든 키는 [w, u] 사이에 있어야 한다.

예제를 살펴보자. 그림 14.1의 이진 탐색 트리에 적용해 보면, 처음 키의 범위는 [$-\infty$, $\infty$]이다. B를 루트로 하는 부분 트리를 재귀 호출하면 키의 범위가 [$-\infty$, 19]가 된다. 여기서 19는 A의 왼쪽 부분 트리가 가질 수 있는 키의 상한이 된다. F를 루트로 하는 부분 트리를 재귀 호출하면 키의 범위는 [7, 19]가 된다. K를 루트로 하는 부분 트리를 재귀 호출하면 키의 범위는 [23, 43]이 된다. 그림 9.1에 나와 있는 이진 트리는, 재귀 호출을 통해 C까지 내려가 보면 이진 탐색 트리가 아니라는 사실을 알 수 있다. C의 키의 범위는 [$-\infty$, 6]이지만 F의 키는 271이므로 이진 탐색 트리의 속성을 만족하지 못한다.

```java
public static boolean isBinaryTreeBST(BinaryTreeNode<Integer> tree) {
    return areKeysInRange(tree, Integer.MIN_VALUE, Integer.MAX_VALUE);
}

private static boolean areKeysInRange(BinaryTreeNode<Integer> tree, Integer lower, Integer upper) {
    if (tree == null) {
        return true;
    } else if (Integer.compare(tree.data, lower) < 0 || Integer.compare(tree.data, upper) > 0) {
        return false;
    }

    return areKeysInRange(tree.left, lower, tree.data) &&
           areKeysInRange(tree.right, tree.data, upper);
}
```

시간 복잡도는 $O(n)$이고, 추가적인 공간 복잡도는 $O(h)$이다. h는 트리의 높이다.

중위 순회를 사용하는 방법도 있다. 중위 순회는 키값을 정렬된 순서로 방문한다. 따라서 중위 순회의 결과가 정렬되어 있다면, 해당 이진 트리는 반드시 이진 탐색 트리이다. (이것은 이진 탐색 트리의 정의와 중위 순회의 정의를 그대로 따른다.) 따라서 중위 순회를 통해 가장 최근에 방문한 노드의 키를 저장함으로써 이진 탐색 트리의 속성을 확인할 수 있다. 새로운 노드를 방문할 때마다 바로 이전에 방문했던 키와 비교한다. 만약 이전에 방문한 키보다 현재 노드의 키가 크다면 이진 탐색 트리의 속성을 위반한 것이다.

두 방법 모두 왼쪽 부분 트리를 먼저 순회한다. 따라서 이진 탐색 트리의 속성을 만족하지 않는 노드가 루트에 가까이 있다고 하더라도(예를 들어 오른쪽 자식의 키가 루트의 키보다 작은 경우), 시간 복잡도는 여전히 $O(n)$이 된다.

너비 우선 탐색과 같은 방식으로 이진 탐색 트리의 속성을 위반하는 경우를 찾아보자. 이 방법은 이진 탐색 트리의 속성을 만족하지 않는 노드가 루트에 가까이 있는 경우를 보다 빠르게 찾을 수 있다.

구체적으로, 큐에 인접한 노드와 해당 노드의 하한값과 상한값을 함께 삽입한다. 처음에는 큐에 루트 노드와 하한 $-\infty$와 상한 $\infty$를 함께 삽입한다. 반복적으로 각 노드에서 범위의 조건을 확인한다. 만약 해당 조건을 만족하지 않는 노드를 발견하면 탐색을 중지한다. 조건을 만족한 경우에는 자식 노드와 자식 노드의 하한을 함께 큐에 삽입한다.

예를 들어 그림 14.1을 살펴보자. 큐에는 초깃값으로 (A, [$-\infty$, $\infty$])를 삽입한다. 매번 큐에서 노드를 꺼내고 조건을 확인한다. 첫 번째 엔트리 (A, [$-\infty$, $\infty$])를 꺼낸 뒤 A 노드의 자식 노드를 알맞은 범위와 함께 큐에 삽입한다. 예를 들면 (B, [$-\infty$, 19])와 (I, [19, $\infty$])다. 계속해서, (B, [$-\infty$, 19])의 노드를 꺼내서 자식 노드를 더한다. 즉, (C, [$-\infty$, 7])과 (D, [7, 19])를 삽입한다. 이 과정을 반복한다. 모든 노드가 조건을 만족하면 해당 트리는 이진 탐색 트리의 조건을 만족하게 된다.

만약 특정 깊이에서 이진 탐색 트리의 속성을 만족하지 않는 부분 트리가 발견됐다면, 더 이상 깊이 들어가지 않아도 된다. 왜냐하면 각 노드의 키가 될 수 있는 하한과 상한을 가능한 아주 엄격하게 설정했기 때문이다. 해당 조건을 만족하지 않는 순간 해당 트리는 이진 탐색 트리의 속성을 만족하지 않게 된다.

```java
public static class QueueEntry {
    public BinaryTreeNode<Integer> treeNode;
    public Integer lowerBound, upperBound;

    public QueueEntry(BinaryTreeNode<Integer> treeNode, Integer lowerBound, Integer upperBound) {
        this.treeNode = treeNode;
        this.lowerBound = lowerBound;
        this.upperBound = upperBound;
    }
}
```

시간 복잡도는 $O(n)$이고, 추가적인 공간 복잡도는 $O(n)$이다.

## 문제 14.2 이진 탐색 트리에서 주어진 값보다 큰 첫 번째 키 찾기

이진 탐색 트리와 값 하나가 입력으로 주어졌을 때, 중위 순회의 결과 해당 값보다 큰 첫 번째 키를 반환하는 프로그램을 작성하라. 예를 들어 그림 14.1의 이진 탐색 트리와 입력값 23이 주어진다면 29를 반환해야 한다.

> 힌트: 추가적인 상태를 유지하면서 이진 탐색을 수행하라.

이진 탐색 트리의 노드가 n개일 때, 단순하게 중위 순회를 하면 $O(n)$ 시간에 해당 노드를 찾을 수 있다. 하지만 이 방법은 이진 탐색 트리의 속성을 사용하지 않았다.

이보다 더 나은 접근법은 이진 탐색 트리의 탐색 특성을 사용하는 것이다. 가장 적합한 후보를 저장한 뒤 트리를 한 칸씩 내려가면서 해당 후보를 반복적으로 갱신한다. 부분 트리의 키와 입력값을 비교한 뒤 탐색하지 않아도 될 부분 트리를 제거해 나간다. 즉, 현재 부분 트리의 루트값이 입력값보다 작거나 같으면 오른쪽 부분 트리를 탐색한다. 만약 현재 부분 트리의 루트값이 입력값보다 크다면, 후보를 현재 루트로 갱신한 뒤 왼쪽 부분 트리를 탐색해 나간다. 우리가 원하는 결과는 현재 노드를 루트로 하는 트리 내에 반드시 존재해야 하기 때문에 이 알고리즘은 올바르게 동작한다.

예를 들어 그림 14.1의 이진 탐색 트리에서 23보다 큰 첫 번째 노드를 찾아야 한다고 하면, A,I,J,K,L의 순서로 노드를 방문하게 될 것이다. L은 왼쪽 자식이 없고 이 노드의 키는 29이기 때문에 29가 결과가 된다.

```java
public static BSTNode<Integer> findFirstGreaterThanK(BSTNode<Integer> tree, Integer k) {
    BSTNode<Integer> subtree = tree, firstSoFar = null;
    while (subtree != null) {
        if (subtree.data > k) {
            firstSoFar = subtree;
            subtree = subtree.left;
        } else { // 루트와 왼쪽 부분 트리의 모든 키는 k보다 작거나 같으므로 이들은 건너뛴다.
            subtree = subtree.right;
        }
    }
    return firstSoFar;
}
```

트리의 높이가 h일 때 시간 복잡도는 $O(h)$가 된다. 공간 복잡도는 $O(1)$이다.

## 문제 14.3 이진 탐색 트리에서 가장 큰 k개의 원소 찾기

이진 탐색 트리는 정렬된 자료구조이므로 k번째로 큰 원소를 찾는 작업은 쉽다.

이진 탐색 트리와 정수값 k가 입력으로 주어졌을 때, 이진 탐색 트리에서 가장 큰 k개의 원소를 반환하는 프로그램을 작성하라. 예를 들어 이진 탐색 트리가 그림 14.1로 입력되고 k = 3이면 (53,47,43)을 반환해야 한다.

> 힌트: 중위 순회로 얻을 수 있는 결과는 무엇인가?

무식한 방법으로 접근해 보자. 중위 순회를 통해 키를 오름차순으로 순회하면서 그중에서 마지막 k개의 키를 반환하면 된다. 큐를 사용하면 k번 이전에 방문했던 노드를 손쉽게 빼낼 수 있으므로, 방문한 노드를 저장할 때 사용하면 좋다. 하지만 이 방법은 불필요한 노드를 또한 처리한다는 단점이 있다. 예를 들어 k값이 작으면서 왼쪽 부분 트리가 큰 경우다.

이보다 더 나은 방법은 원하는 노드에서 시작해서 거꾸로 찾아 나가는 방법이다. 먼저 가능한 오른쪽 부분 트리로 재귀적으로 내려간다. 만약 오른쪽 부분 트리가 존재하지 않는 경우에는 왼쪽 부분 트리로 내려간다. 이 방법은 거꾸로 중위 순회를 하는 것과 같다. 그림 14.1의 이진 탐색 트리를 거꾸로 중위 순회를 한다면 그 결과는 `<P,O,I,N,K,M,L,J,A,G,H,F,B,E,C,D>`가 된다.

k개의 노드를 모두 방문한 순간 순회를 중단한다. 다음은 찾고자 하는 키를 동적 배열에 저장하는 코드이다. 배열의 원소가 k개가 되는 수간 해당 배열을 반환한다. 문제에 나와 있는 대로 새롭게 방문하는 노드를 배열의 끝에 저장한다.

```java
public static List<Integer> findKLargestInBST(BSTNode<Integer> tree, int k) {
    List<Integer> kLargestElements = new ArrayList<>();
    findKLargestInBSTHelper(tree, k, kLargestElements);
    return kLargestElements;
}

private static void findKLargestInBSTHelper(BSTNode<Integer> tree, int k, List<Integer> kLargestElements) {
    // 중위 순회를 거꾸로 순회한다.
    if (tree != null && kLargestElements.size() < k) {
        findKLargestInBSTHelper(tree.right, k, kLargestElements);
        if (kLargestElements.size() < k) {
            kLargestElements.add(tree.data);
            findKLargestInBSTHelper(tree.left, k, kLargestElements);
        }
    }
}
```

그림 14.1에서 가장 큰 5개의 키를 찾고자 할 때, 먼저 재귀적으로 A,I,O,P를 순서대로 방문한다. 그 다음에 P,O,I의 순서대로 방문하고 이들을 결과에 추가한다. 그리고 재귀적으로 J,K,N을 순서대로 방문한다. 마지막에 N과 K를 방문한 순간 이들을 결과에 저장한다. 배열에 저장한 키가 다섯 개가 되었으므로 순회를 중단한다.

시간 복잡도는 $O(h + k)$이다. 이는 트리가 균형 잡혀 있고 k가 작은 경우에 일반적인 중위 순회보다 더 빠르다. 복잡도의 상한은 다음과 같이 구할 수 있다. 이 프로그램은 많아야 h번 트리를 내려가고, 그 횟수는 적어도 트리를 다시 올라가는 횟수보다 많다. 또한 결과에 추가할 노드를 방문을 한 뒤에야 트리를 다시 올라간다. k개의 노드를 결과에 넣은 뒤에는 프로그램이 종료된다.

## 문제 14.4 이진 탐색 트리에서 최소 공통 조상 구하기

이진 탐색 트리는 특별한 트리이므로 문제 9.4에 나와 있는 것처럼 최소 공통 조상(LCA)의 개념이 적용된다.

이진 탐색 트리에서 두 노드의 최소 공통 조상을 구하는 것이 일반적인 이진 트리에서 최소 공통 조상을 구하는 것보다 보통 더 쉽지는 않다. 왜냐하면 구조적으로 이진 트리의 키값이 모두 같다고 했을 때 모든 이진 트리를 이진 탐색 트리로 볼 수 있기 때문이다. 하지만 중복된 키가 없는 경우에는 최소 공통 조상을 찾는 알고리즘을 개선할 수 있다.

이진 탐색 트리와 노드 두 개가 입력으로 주어졌을 때, 두 노드의 최소 공통 조상을 반환하는 알고리즘을 설계하라. 예를 들어 그림 14.1의 이진 탐색 트리와 노드 C와 G가 입력으로 주어졌을 때, 여러분의 알고리즘은 B를 반환해야 한다. 중복된 키는 없다고 가정해도 좋다. 노드 안에 부모를 가리키는 참조 변수는 없다.

> 힌트: 이진 탐색 트리의 속성을 활용하라.

문제 9.3의 해법을 살펴보면 이진 트리에서 이 문제를 해결하는 알고리즘을 확인할 수 있다. 이 알고리즘은 후위 순회를 통해 문제를 해결한다. 두 노드의 최소 공통 조상은 두 노드를 방문한 이후에 가장 먼저 방문하는 노드가 된다. 노드의 개수가 n일 때 이 방법의 시간 복잡도는 $O(n)$이 된다.

이 방법은 이진 탐색 트리에 중복된 키가 없는 경우에 좀 더 개선될 여지가 있다. 그림 14.1의 이진 탐색 트리와 노드 C, G를 확인해 보자. C와 G의 키는 A의 키보다 작으므로 최소 공통 조상은 A의 왼쪽 부분 트리에 있어야 한다. B를 살펴보면 C의 키는 B보다 작고 B의 키는 G보다 작다. 따라서 B가 C와 G의 최소 공통 조상이 된다.

두 노드 s와 b의 최소 공통 조상을 구해 보자. 일반성을 잃지 않고 s의 키가 b의 키보다 작다고 가정한다(중복된 키가 없다고 가정했기 때문에 s와 b의 키가 같을 수는 없다). 이진 탐색 트리의 루트에 저장된 키를 살펴보면 다음과 같은 네 가지 가능성이 존재한다.

- 루트의 키가 s 혹은 b의 키와 같으면, 루트가 최소 공통 조상이 된다.
- s의 키가 루트의 키보다 작고 b의 키가 루트의 키보다 크다면, 루트가 최소 공통 조상이 된다.
- s와 b의 키가 모두 루트보다 작다면, 최소 공통 조상은 루트의 왼쪽 부분 트리에서 찾을 수 있다.
- 두 노드의 키가 모두 루트보다 크다면, 최소 공통 조상은 루트의 오른쪽 부분 트리에서 찾을 수 있다.

```java
// 입력 노드는 null이 아니고 노드 s의 값이 노드 b의 키값보다 작거나 같다.
public static BSTNode<Integer> findLCA(BSTNode<Integer> tree,
                                       BSTNode<Integer> s,
                                       BSTNode<Integer> b) {
    BSTNode<Integer> p = tree;
    while (p.data < s.data || p.data > b.data) {
        // p가 [s, b]의 범위 안에 없으므로 계속 탐색한다.
        while (p.data < s.data) {
            p = p.right; // 최소 공통 조상은 p의 오른쪽 부분 트리에 있다.
        }
        while (p.data > b.data) {
            p = p.left; // 최소 공통 조상은 p의 왼쪽 부분 트리에 있다.
        }
    }
    // 이제 s.data >= p.data && p.data <= b.data이다.
    return p;
}
```

매번 트리를 한 칸씩 내려가므로, 트리의 높이가 h일 때 시간 복잡도는 $O(h)$가 된다.

## 문제 14.5 순회한 데이터를 통해 이진 탐색 트리 재구성하기

문제 9.12에서 얘기했듯이 중위순회로 방문한 노드의 수열은 같지만 실제 이진 트리의 모양은 다른 경우가 무수히 많다. 전위 순회와 후위 순회도 마찬가지이다. 하지만 중위 순회로 방문한 노드의 수열과 전위 순회 혹은 후위 순회로 방문한 노드의 수열이 함께 주어졌다면, 유일한 이진 트리를 찾을 수 있다. 여기서는 트리가 이진 탐색 트리라는 사실을 알고 있을 때, 한 가지 방문 수열만으로 트리를 재구성할 수 있는지 살펴볼 것이다.

중요한 사실은 트리에 저장된 원소가 중복되지 않았다는 점이다. 만약 루트의 키가 v이고 다른 노드의 키도 v가 될 수 있다면, v 이후의 수열이 v의 왼쪽 부분 트리인지 오른쪽 부분 트리인지 판별할 수가 없다. 예를 들어 그림 14.2에서 G가 해당 트리의 루트라고 했을 때, 이를 전위 순회한다면 그 수열은 285, 243, 285, 401이 된다. 하지만 285가 왼쪽 부분 트리 243의 오른쪽 자식노드이고 401이 루트의 오른쪽 자식노드인 경우에도 전위 순회의 결과는 같다.

이진 탐색 트리를 중위 순회로 방문한 키의 시퀀스가 주어졌다고 가정하자. 중복된 키값은 없다. 이 시퀀스를 통해 이진 탐색 트리를 재구성할 수 있을까? 만약 그렇다면 프로그램을 작성해 보라. 전위 순회와 후위 순회의 결과가 주어졌을 때도 같은 문제를 풀어 보라.

> 힌트: 키가 1,2,3인 다섯 개의 이진 탐색 트리를 구린 후 그에 해당하는 순회 순서를 살펴보라.

머넞, 실험을 통해 중위 순회 결과만으로는 트리를 재구성하기 부족하다는 사실을 알 수 있다. 예를 들어, 키의 시퀀스가 1,2,3인 경우에는 그림 14.3과 같이 다섯 개의 서로 다른 이진 탐색 트리가 존재한다.

하지만 전위 순회의 경우에는 얘기가 달라진다. 예를 들어 전위 순회의 키 방문 시퀀스가 <43, 23, 37, 29, 31, 41, 47, 53>이라고 하자. 가장 먼저 방문한 노드가 43이므로 이 노드는 반드시 루트가 된다. 왼쪽 부분 트리는 43보다 작은 23, 37, 29, 31, 41이 되고, 오른쪽 부분 트리는 43보다 큰 47, 53이 된다. 또한 <23,37,29,31,41>은 왼쪽 부분 트리의 전위 순회 결과이고 <47,53>은 오른쪽 부분 트리의 전위 순회 결과이다. 재귀적인 이유에 의해 23과 47이 왼쪽 부분 트리와 오른쪽 부분 트리의 루트라는 사실을 알 수 있고, 이를 계속해 나가면 전체 트리를 알 수 있다. 그 결과는 그림 14.1에서 I를 루트로 한 부분 트리와 같다.

이를 일반화하면 임의의 전위 순회 시퀀스가 주어졌을 때, 첫 번째 노드가 루트가 된다. 그 뒤에 두 번째 원소부터 시작해서 루트의 키보다 작은 원소까지의 부분 시퀀스가 루트의 왼쪽 부분 트리를 전위 순회한 결과와 같다. 그 뒤의 나머지 시퀀스, 즉 루트보다 큰 키의 부분 시퀀스는 루트의 오른쪽 부분 트리를 전위 순회한 결과와 같다. 이 두 부분 시퀀스를 통해 왼쪽과 오른쪽 부분 트리를 재귀적으로 만들어 가면 전체 이진 탐색 트리를 만들 수 있다.

```java
public static BSTNode<Integer> rebuildBSTFromPreorder(List<Integer> preorderSequence) {
    return rebuildBSTFromPreorderHelper(preorderSequence, 0, preorderSequence.size());
}

// preorderSequence.subList(start, end)로부터 이진 탐색 트리를 만들어 낸다.
private static BSTNode<Integer> rebuildBSTFromPreorderHelper(List<Integer> preorderSequence, int start, int end) {
    if (start >= end) {
        return null;
    }
    int transitionPoint = start + 1;
    while (transitionPoint < end
        && Integer.compare(preorderSequence.get(transitionPoint),
                           preorderSequence.get(start)) < 0) {
        ++transitionPoint;
    }
    return new BSTNode<>(
        preorderSequence.get(start),
        rebuildBSTFromPreorderHelper(preorderSequence, start + 1, transitionPoint),
        rebuildBSTFromPreorderHelper(preorderSequence, transitionPoint, end)
    );
}
```

이 알고리즘에서 최악은 입력으로 왼쪽으로 치우친 트리의 전위 순회 시퀀스가 주어졌을 경우다. 최악의 경우에 시간 복잡도는 $W(n) = W(n - 1) + O(n)$이므로 $O(n^2)$이 된다. 최선의 입력은 오른쪽으로 치우친 트리이고, 이 경우의 시간 복잡도는 $O(n)$이다. 균형 잡힌 이진 탐색 트리의 경우에는 $B(n) = 2B(n/2) + O(n)$이고, 이는 $O(n \log n)$과 같다.

이 구현 방법은 노드를 여러 번 반복해서 순회하므로 잠재적인 낭비가 존재한다. 왼쪽 부분 트리에 속한 노드가 무엇인지 확인하는 순간 왼쪽 부분 트리를 함께 만들어 나가면 알고리즘을 더 개선할 수 있다. 다음은 이 방법을 구현한 코드이다. 이 방법의 핵심은 루트보다 작은 원소 중에 가장 뒤에 있는 원소를 찾고, 그다음 다시 첫 번째 원소로 돌아가지 않는 것이다. 우리가 만들고 싶은 부분 트리의 키의 범위를 알고 있으면 다시 돌아가지 않아도 부분 트리를 만들 수 있다. 예를 들어 부분 시퀀스 <23,37,29,31,41>을 재귀적으로 다시 순회하지 말고 전체 시퀀스 <43,23,37,29,31,41,47,53>을 살펴보자. 부분 시퀀스를 구하려면 부분 시퀀스의 마지막 원소를 찾기 위해 순회하는 작업이 필요하다. 그보다는 전체 시퀀스 <23,37,29,31,41,47,53>에서 43보다 작은 키만을 사용해서 재귀적으로 부분 트리를 만들어 나가면 된다.

```java
// 전역 변수, 현재 부분 트리를 추적한다.
private static Integer rootIdx;

public static BSTNode<Integer> rebuildBSTFromPreorder(List<Integer> preorderSequence) {
    rootIdx = 0;
    return rebuildBSTFromPreorderHelper(preorderSequence, Integer.MIN_VALUE, Integer.MAX_VALUE);
}

// preorderSequence에서 (lowerBound, upperBound) 사이에 있는 키값을 통해
// rootIdx를 루트로 한 부분 이진 탐색 트리를 만든다.
private static BSTNode<Integer> rebuildBSTFromPreorderOnValueRange(List<Integer> preorderSequence, Integer lowerBound, Integer upperBound) {
    if (rootIdx == preorderSequence.size()) {
        return null;
    }

    Integer root = preorderSequence.get(rootIdx);
    if (root < lowerBound || root > upperBound) {
        return null;
    }
    ++rootIdx;

    // rebuildBSTFromPreorderOnValueRange는 rootIdx를 갱신한다는 점에 주의하자.
    // 따라서 다음 두 함수의 호출 순서는 굉장히 중요하다.
    BSTNode<Integer> leftSubtree = rebuildBSTFromPreorderOnValueRange(preorderSequence, lowerBound, root);
    BSTNode<Integer> rightSubtree = rebuildBSTFromPreorderOnValueRange(preorderSequence, root, upperBound);
    return new BSTNode<>(root, leftSubtree, rightSubtree);
}
```

각 노드에서 상수만큼의 작업을 수행하므로 최악의 경우에 시간 복잡도 $O(n)$이 된다. 문제 24.20의 해법과 비슷한 점을 발견할 수 있다.

후위 순회가 주어졌을 때도 유일한 이진 탐색 트리를 만들 수 있고, 그 알고리즘은 전위 순회를 사용했을 때와 굉장히 비슷하다.

## 문제 14.6 세 개의 정렬된 배열에서 가장 가까운 원소 찾기

정렬된 배열 세 개가 주어졌을 때, 세 개의 배열에서 원소를 하나씩 꺼내서 이들 사이의 거리가 최소가 되도록 하라. 예를 들ㅇ러 세 개의 배열이 각각 <5,10,15>, <3,6,9,12,15>, <8,16,24>라면 각각 15,15,16을 꺼냈을 때 이들 사이의 거리가 최소가 된다.

> 힌트: 하나의 정렬된 배열에서 위의 조건을 만족하는 원소 세 개를 고른다면 어떻게 할 것인가?

무식한 방법은 삼중 루프를 사용해서 모든 가능한 경우를 다 살펴보는 것이다. 어떤 숫자 집합이 있을 때 이들 사이의 거리는 단순하게 그 집합의 최댓값과 최솟값의 차이와 같다. 배열 세 개의 길이가 각각 l, m, n일 때 시간 복잡도는 $O(lmn)$이 된다.

이 무식한 방법은 입력 배열이 정렬되어 있다는 사실을 사용하지 않았다. 문제에서 언급한 예제에서 <5,3,16>과 <5,3,24>에서의 최소 거리는 <5,3,8>을 함께 고려했을 때보다 반드시 커야한다. 왜냐하면 5,3,8의 최댓값은 8이고 8 < 16 < 24이기 때문이다.

먼저 각 배열의 가장 작은 값부터 시작하자. s는 이 세개의 값 중에서 가장 작은 값을 나타내고 t는 가장 큰 값을 나타낸다고 하자. 그럼 이 세 개의 숫자 사이의 거리는 [s,t]가 된다.

이제 s를 후보에서 지운 뒤 s가 들어 있던 배열에서 그 다음으로 작은 값을 꺼낸다. s'와 t'가 숫자 세 개 중에서 그 다음으로 가장 작은 숫자와 가장 큰 숫자라고 했을 때 s'는 숫자 세 개의 거리를 나타낼 때 왼쪽 끝이 된다. 왜냐하면 다른 두 값이 반드시 s'보다 크거나 같기 때문이다. 세 개의 숫자 중에서 가장 작은 원소를 꺼내고 해당 원소가 들어 있던 배열에서 그 다음으로 작은 값을 꺼내는 걸 반복한다.

예를 들어 <5,3,8>에서 시작해 보자.

- 이들의 구간은 왼쪽 끝이 3이고 그 길이는 8-3=5가 된다.
- 3 다음으로 가장 작은 원소는 6이므로 그 다음 숫자 세 개는 <5,6,8>이 된다. 이들의 구간은 왼쪽이 5이고 그 길이는 8-5=3이다.
- 5 다음으로 가장 작은 원소는 10이므로 그 다음 숫자 세 개는 <10,6,8>이 된다. 이들의 구간은 왼쪽 끝이 6이고 그 길이는 10-6-4가 된다.
- 6 다음 원소는 9이므로 그 다음 숫자 세 개는 <10,9,8>이 된다.

이를 반복해 나가면 <10,9,16>, <10,12,16>, <15,12,16>, <15,15,16>의 순서대로 선택하게 된다. 이들 중에서 숫자 사이의 가장 거리 짧은 숫자 세 개는 <15,15,16>이 된다.

다음은 이 문제를 일반화한 코드이다. k개의 정렬된 배열에서 가장 가까운 원소 k개를 찾는다. k개의 원소에서 반복적으로 삽입, 삭제, 최솟값 찾기, 최댓값 찾기와 같은 연산을 해야 하므로 자연스럽게 이진 탐색 트리를 사용했다.

```java
public static class ArrayData implements Comparable<ArrayData> {
    public int val;
    public int idx;

    public ArrayData(int idx, int val) {
        this.val = val;
        this.idx = idx;
    }

    @Override
    public int compareTo(ArrayData o) {
        int result = Integer.compare(val, o.val);
        if (result == 0) {
            result = Integer.compare(idx, o.idx);
        }
        return result;
    }
}
```

전체 원소가 n개이고 배열의 개수가 k일 때 시간 복잡도는 $O(n \log k)$가 된다. 이 문제는 특별히 k=3이므로 $O(n \log 3) = O(n)$이 된다.

## 문제 14.7 $a+b\sqrt{2}$꼴의 숫자 나열하기

a와 b가 음이 아닌 정수이고 q는 어떤 정수의 제곱이 아닌 정수값이라고 했을 때 $a + b\sqrt{q}$는 덧셈과 곱셈에 닫혀 있다는 특별한 속성이 있다. 그림 14.4에 이와 같은 꼴의 숫자 몇 가지를 나열했다.

음이 아닌 정수 a와 b로 이루어진 $a + b\sqrt{2}$의 숫자 중에서 가장 작은 k개의 숫자를 효율적으로 찾는 알고리즘을 설계하라.

> 힌트: 그래프상의 점을 체계적으로 나열하라.

중요한 사실은 $\sqrt{2}$가 무리수라는 점이다. 즉, 어떤 정수 a,b에 대해서 $\frac{b}{a}$와 같을 수 없다. 따라서 x와 y가 정수이고 $x + y\sqrt{2} = x' + y'\sqrt{2}$를 만족한다면 $x = x'$이고 $y = y'$가 된다. (그렇지 않으면 $\sqrt{2} = \frac{x - x'}{y - y'}$가 되기 때문이다.)

무식한 방법은 $0 \le a, b \le k - 1$ 사이의 모든 a,b에 대해서 $a + b\sqrt{2}$을 만족하는 숫자를 전부 나열하는 것이다. 이 숫자는 정확히 $k^2$개이고, k개의 작은 숫자는 반드시 이 중에 존재한다. 이 숫자를 정렬한 뒤에 k개의 가장 작은 숫자를 골라내면 된다. 시간 복잡도는 $O(k^2 \log (k^2)) = O(k^2 \log k)$가 된다.

직관적으로 $k^2$개의 숫자를 모두 나열하는 건 낭비가 심하다. 우리가 필요한 건 오직 k개의 숫자이다.

가장 작은 숫자는 $0 + 0\sqrt{2}$이다. 그 다음으로 작은 숫자는 $1 + 0\sqrt{2}$ 혹은 $0 + 1\sqrt{2}$이다. 여기서 다음 알고리즘을 추론할 수 있다. 가장 작은 숫자 k개를 뽑아내려고 한다. 이 실수 컬렉션은 $0 + 0\sqrt{2}$에서 시작한다. $a + b\sqrt{2}$를 뽑았다면 그 다음에는 $(a + 1) + b\sqrt{2}$와 $a + (b + 1)\sqrt{2}$를 후보 컬렉션에 넣어야 한다.

여기서 사용하는 연산은 컬렉션에서 가장 작은 원소를 뽑아내고 새로운 원소를 삽입하는 연산이다. 같은 값을 여러 번 넣을 수도 있으므로, 같은 숫자를 여러 번 삽입했을 때 해당 숫자를 여러 개 만들지 않아야 한다. 이진 탐색 트리는 이런 연산을 다음과 같이 효과적으로 수행한다.

먼저 $0 + 0\sqrt{2}로 초기화한다.

이진 탐색 트리에서 최솟값인 $0 + 0\sqrt{2}$를 뽑아내고 $1 + 0\sqrt{2}$와 $0 + 1\sqrt{2}$를 이진 탐색 트리에 새로 넣는다.

이진 탐색 트리에서 그다음 최솟값인 $1 + 0\sqrt{2}$를 뽑아내고, $2 + 0\sqrt{2}$와 $1 + 1\sqrt{2}$를 넣는다.

이제 이진 탐색 트리에는 $0 + 1\sqrt{2} = 1.414, 2 + 0\sqrt{2} = 2, 1 + 1\sqrt{2} = 2.414$가 들어 있다.

최솟값인 $0 + 1\sqrt{2}$를 뽑아내고 $1 + 1\sqrt{2}$와 $0 + 2\sqrt{2}$를 집어넣는다.

첫 번째 값은 이미 존재하므로 최종적으로 $2 + 0\sqrt{2} = 2, 1 + 1\sqrt{2} = 2.414, 0 + 2\sqrt{2} = 2.828$이 이진 탐색 트리에 들어 있게 된다. (이 작은 예제에선 보이지 않겠지만, 이진 탐색 트리에 넣는 값이 이미 존재하는 값보다 더 작을 수도 있으므로, 이진 탐색 트리는 모든 값을 들고 있어야 한다.)

```java
public static class ABSqrt2 implements Comparable<ABSqrt2> {
    public int a, b;
    public double val;

    public ABSqrt2(int a, int b) {
        this.a = a;
        this.b = b;
        val = a + b * Math.sqrt(2);
    }

    @Override
    public int compareTo(ABSqrt2 o) { return Double.compare(val, o.val); }
}
```

반복할 때마다 한 번의 삭제와 두 번의 삽입 연산을 수행한다. 이런 삽입을 k번 시도하므로 시간 복잡도는 $O(k \log k)$가 된다. 최대 2k번의 삽입을 시도하므로 공간 복잡도는 $O(k)$가 된다.

이제 $O(n)$ 시간의 해법을 소개할 것이다. 구현하기는 쉽지만 이진 탐색 트리를 기반으로 하는 방법보다 이해하기는 쉽지 않다. 기본적으로 (n + 1)번째 값은 1혹은 $\sqrt{2}$와 이전 값을 더한 결과이다. 모든 결과를 순회하면서 n번째 값보다 큰 값 중에서 가장 작은 값을 구할 수도 있지만, 이렇게 하면 (n + 1)번째 결과를 구하는 데 $O(n)$ 시간이 소요된다.

직관적으로 (n + 1)번째 값을 구하는 데 이전의 값을 전부 살펴볼 필요는 없다. 배열 A에 결과를 저장하고 있다고 하자. 우리는 여기서 두 개의 엔트리만 추적하면 된다. $A[i] + 1 \gt A[n - 1]$을 만족하는 가장 작은 인덱스 i와 $A[j] + \sqrt{2} \gt A[n - 1]$을 만족하는 가장 작은 인덱스 j. (n + 1)번째 값은 $A[i] + 1$과 $A[j] + \sqrt{2}$ 중에서 작은 값이 된다. (n + 1)번째 값이 $A[i] + 1$이라면 i를 증가시키고, $A[j] + \sqrt{2}$라면 j를 증가시킨다. 만약 이 둘의 값이 같다면 i와 j 모두 증가시킨다.

A가 <0>으로 초기화되어 있고 i와 j가 0이라고 가정했을 때 계산 과정은 다음과 같다.

1. $A[0] + 1 = 1 \lt A[0] + \sqrt{2} = 1.414$이므로 1을 A에 넣고 i를 증가시킨다. 이제 $A = <0, 1>, i = 1, j = 0$이 된다.
2. $A[i] + 1 = 2 > A[0] + \sqrt{2} = 1.414$이므로 1.414를 A에 넣고 j를 증가시킨다. 이제 $A = <0, 1,1.414>, i = 1, j = 1$이 된다.
3. $A[1] + 1 = 2 < A[1] + \sqrt{2} = 2.414$이므로 2를 A에 넣고 i를 증가시킨다. 이제 $A = <0, 1,1.414,2>, i = 2, j = 1$이 된다.
4. $A[2] + 1 = 2.414 = A[1] + \sqrt{2} = 2.414$이므로 2.414을 A에 넣고 j를 증가시킨다. 이제 $A = <0, 1,1.414,2,2.414>, i = 3, j = 2$이 된다.
5. $A[3] + 1 = 3 > A[2] + \sqrt{2} = 2.828$이므로 2.828을 A에 넣고 j를 증가시킨다. 이제 $A = <0, 1,1.414,2,2.828>, i = 3, j = 3$이 된다.
6. $A[3] + 1 = 3 < A[3] + \sqrt{2} = 3.414$이므로 3을 A에 넣고 ㅑ를 증가시킨다. 이제 $A = <0, 1,1.414,2,2.828,3>, i = 4, j = 3$이 된다.

```java
public static List<Double> generateFirstKABSqrt2(intk) {
    // a + b * sqrt(2) 꼴인 숫자 중에서 처음 k개의 숫자를 저장한다.
    List<GeneratingABSqrt2.ABSqrt2> cand = new ArrayList<>();
    cand.add(new GeneratingABSqrt2.ABSqrt2(0, 0));
    int i = 0, j = 0;
    for (int n = 1; n < k; n++) {
        GeneratingABSqrt2.ABSqrt2 candIPlus1 = new GeneratingABSqrt2.ABSqrt2(cand.get(i).a + 1, cand.get(i).b);
        GeneratingABSqrt2.ABSqrt2 candJPlusSqrt2 = new GeneratingABSqrt2.ABSqrt2(cand.get(i).a, cand.get(j).b + 1);
        cand.add(candIPlus1.val < candJPlusSqrt2.val ? candIPlus1 : candJPlusSqrt2);

        if (candIPlus1.compareTo(cand.get(cand.size() - 1)) == 0) {
            ++i;
        }
        if (candJPlusSqrt2.compareTo(cand.get(cand.size() - 1)) == 0) {
            ++j;
        }
    }
    List<Double> result = new ArrayList<>();
    for (GeneratingABSqrt2.ABSqrt2 c : cand) {
        result.add(c.val);
    }
    return result;
}
```

각 원소를 구하는 데 $O(1)$ 시간이 걸리므로 $a + b\sqrt{2}$ 꼴의 숫자 중에서 처음 n개의 숫자를 구하는 데는 $O(n)$ 시간이 걸린다.

## 문제 14.8 정렬된 배열에서 높이가 최소인 이진 탐색 트리 만들기

정렬된 배열이 주어졌을 때, 만들 수 있는 이진 탐색 트리의 개수는 배열의 크기가 커질수록 무지막지하게 증가한다. 어떤 트리는 한쪽으로 기울어져 있거나 심지어 리스트에 가깝다. 또 다른 트리는 균형 잡혀 있다. 예제는 그림 14.3에서 찾아볼 수 있다.

정렬된 배열에서 높이가 가능한 최소가 되는 이진 탐색 트리를 어떻게 만들 수 있는가?

> 힌트: 어떤 원소가 루트가 되어야 할까?

무식한 방법은 별로 도움이 되지 않는다. 주어진 배열로 만들 수 있는 모든 이진 탐색 트리를 나열한 뒤에 높이가 최소가 되는 트리를 탐색한다. 이 방법은 재귀로 구현하기도 쉽지 않고 시간 복잡도도 무지막지하다.

직관적으로 높이가 최소가 되는 이진 탐색 트리는 가능한 부분 트리가 최대한 균형 잡혀 있어야 한다. 트리의 높이는 부분 트리 중 높이가 긴 부분 트리에 의해 결정되므로 하나를 다른 하나보다 짧게 만들 이유가 없다. 더 엄밀히 말해서 부분 트리의 노드 개수를 가능하면 비슷하게 유지해야 한다.

배열의 길이를 n이라 하자. 최적으로 균형 잡힌 트리를 만들기 위해선 배열의 중앙에 있는 원소 $\lfloor\frac{n}{2}\rfloor$을 루트로 하고 양쪽의 부분배열을 사용해서 재귀적으로 높이가 최소인 이진 탐색 트리를 만들어 나가면 된다.

예제를 통해 살펴보자. 만약 배열이 <2,3,5,7,11,13,17,19,23>이라면 루트는 중앙의 원소인 11이 된다. 왼쪽 부분 트리는 <2,3,5,7>을 통해 만들고 오른쪽 부분 트리는 <13,17,19,23>을 통해 만든다. 부분 트리의 높이를 최소로 만들기 위해 같은 함수를 재귀적으로 호출한다.

```java
public static BSTNode<Integer> buildMinHeightBSTFromSortedArray(List<Integer> A) {
    return buildMinHeightBSTFromSortedASubrray(A, 0, A.size());
}

private static BSTNode<Integer> buildMinHeightBSTFromSortedASubrray(List<Integer> A, int start, int end) {
    if (start >= end) {
        return null;
    }
    int mid = start + ((end - start) / 2);
    return new BSTNode<>(A.get(mid),
                         buildMinHeightBSTFromSortedASubrray(A, start, mid),
                         buildMinHeightBSTFromSortedASubrray(A, mid + 1, end));
}
```

시간 복잡도 $T(n)$은 재귀적으로 $T(n) = 2T(n/2) + O(1)$이므로 $T(n) = O(n)$이 된다. 다른 방식으로 설명하자면, 재귀 함수를 정확히 n번 호출했고 매번 $O(1)$의 시간을 사용했으므로 총 시간 복잡도는 $O(1)$이 된다.

## 문제 14.9 이진 탐색 트리의 노드 세 개가 완전히 정렬되어 있는지 확인하기

이진 탐색 트리의 노드 두 개와 '중간' 노드인 또 다른 세 번째 노드가 주어졌을 때, 두 노드 중 하나가 '중간' 노드의 조상이고 다른 하나는 '중간' 노드의 자손인지 확인하는 프로그램을 작성하라. (조상 노드는 '중간' 노드와 동일하지 않으며, 자손 노드도 마찬가지다.) 예를 들어 그림 14.1에서 '중간' 노드가 J이고, 두 노드가 {A,K} 혹은 {I,M}인 경우에는 true를 반환해야 한다. 두 노드가 {I,P} 혹은 {J,K}라면 false를 반환한다. 중복된 키는 없다고 가정해도 좋다. 각 노드에는 부모를 가리키는 포인터가 존재하지 않는다.

> 힌트: 세 개의 노드가 어떻게 배열되어 있어야 하는가?

무식한 방법은 첫 번째 노드가 중간 노드의 조상인지 확인하고 두 번째 노드가 중간 노드의 자손인지 확인한다. 만약 참이라면, 그래도 true를 반환한다. 참이 아니라면, 첫 번째 노드와 두 번째 노드를 교환한 뒤에, 동일한 작업을 반복한다. 그림 14.1에 나오는 이진 탐색 트리에서 두 노드가 {L,I}이고 중간 노드가 K라면 L에서 시작해서 K를 찾을 순 없지만, I에서 시작해 K를 찾을 순 있다. 또한 K에서 시작해 L을 찾을 수 있으므로 true를 반환한다.

트리의 높이가 h일 때 한 번 탐색하는 데 걸리는 시간은 $O(h)$이다. 이진 탐색 트리의 속성을 사용하면 두 자식 노드 중에서 하나를 제거할 수 있다. 탐색을 최대 세 번 반복하므로 전체 시간 복잡도는 $O(h)$가 된다.

이 방법은 두 노드 중 어떤 노드가 중간 노드의 조상인지 모른다는 단점이 있다. 따라서 실제로는 자손인 노드에서 시작해서 중간 노드를 찾는 경우에는 최대 $O(h)$의 시간이 소요된다. 아무리 세 노드가 가까이 놓여 있더라도 말이다. (예를 들어 중간 노드는 I고 두 노드가 {A,J}인 경우다.)

따라서 두 노드를 번갈아 가며 중간 노드를 찾는다면 이런 단점을 보완할 수 있다. 둘 중 하나가 중간 노드를 만났다면, 곧바로 중간 노드에서 시작해서 자손 노드를 탐색하면 된다. 이렇게 하면 부분 트리가 큰 경우에 탐색에 성공하지 못하는 상황을 피할 수 있다. 예를 들어 그림 14.1에서 두 노드가 {A,J}이고 중간 노드가 I일 때, A와 J에서 동시에 시작해서 I를 찾는다. A에서 시작해서 I를 찾은 순간 탐색을 구만둘 수 있으므로 J에서 시작한 탐색이 끝내 I를 찾지 못하는 상황을 피할 수 있다.(하지만 여전히 I에서 시작해서 J를 찾는 탐색을 수행해야 한다.)

```java
public static boolean pairIncludesAncestorAndDescendantOfM(
    BSTNode<Integer> possibleAncOrDesc0,
    BSTNode<Integer> possibleAncOrDesc1,
    BSTNode<Integer> middle)
{
    BSTNode<Integer> search0 = possibleAncOrDesc0;
    BSTNode<Integer> search1 = possibleAncOrDesc1;

    // possibleAncOrDesc0와 possibleAncOrDesc1에서 시작해서 번갈아 가며
    // 중간 노드를 찾는다.
    while (search0 != possibleAncOrDesc1 &&
           search0 != middle &&
           search1 != possibleAncOrDesc0 &&
           search1 !- middle &&
           (search0 != null || search1 != null))
    {
        if (search0 != null) {
            search0 = search0.data > middle.data ? search0.left : search0.right;
        }
        if (search1 != null) {
            search1 = search1.data > middle.data ? search1.left : search1.right;
        }
    }

    // 두 노드 모두 탐색에 실패하거나, possibleAncOrDesc1에서 시작해서 중간 노드를 찾지
    // 못하고 possibleAncOrDesc1에 도달했거나, possibleAncOrDesc1에서 시작해서
    // 중간 노드를 찾지 못하고 possibleAncOrDesc0에 도달했다면,
    // 중간 노드는 possibleAncOrDesc0과 possibleAncOrDesc1 사이에 놓여 있지 않다.
    if (search0 == possibleAncOrDesc1 ||
        search1 == possibleAncOrDesc0 ||
        (search0 != middle && search1 != middle))
    {
        return false;
    }

    // 코드가 여기에 도달했다면, possibleAncOrDesc0 혹은 possibleAncOrDesc1 중의 하나에서
    // 중간 노드에 도달했다는 의미이다. 이제 중간 노드에서 possibleAncOrDesc1 혹은
    // possibleAncOrDesc0 노드에 도달할 수 있는지 확인한다.
    return search0 == middle ? searchTarget(middle, possibleAncOrDesc1)
                             ? searchTarget(middle, possibleAncOrDesc0);
}

private static boolean searchTarget(BSTNode<Integer> from, BSTNode<Integer> target) {
    while (from != null && from != target) {
        from = from.data > target.data ? from.left : from.right;
    }
    return from == target;
}
```

중간 노드와 한 쌍의 노드가 자손과 조상의 관계에 있다면 시간 복잡도는 $O(d)$가 된다. 여기서 d는 조상과 자손 사이의 높이 차를 말한다. 왜냐하면 두 노드가 번갈아 가면 중간 노드를 탐색할 때 최대 $O(d)$번 탐색을 하면 자손을 찾을 수 있기 때문이다. 만약 이들이 자손과 조상의 관계가 없다면, 전체 시간 복잡도는 트리의 높이와 같은 $O(h)$가 된다. 이는 이진 탐색 트리의 탐색에 필요한 시간 복잡도와 같다.

## 문제 14.10 범위 확인 문제

지리적 위치 정보가 주어졌을 때, 가장 가까운 레스토랑을 반환하는 웹 서비스를 개발하는 문제를 생각해 보자. 이 서비스는 레스토랑의 위치 정보로 X와 Y좌표를 사용한다. 위치와 관련된 쿼리가 들어오면 가장 가까운 레스토랑을 반환해야 한다. (거리가 같은 레스토랑이 여러 개라면 아무거나 반환해도 된다.)

한 가지 접근법은 두 개의 이진 탐색 트리를 사용해서 레스토랑의 위치를 저장하는 것이다. $T_x$에는 X좌표가 정렬되어 있고, $T_y$에는 Y좌표가 정렬되어 있다. (p,q)의 위치가 쿼리로 들어오면, X 좌표가 [p - D, p + D] 구간에 포함된 모든 레스토랑과 Y 좌표가 [q - D, q + D] 구간에 포함된 모든 레스토랑 중 교집합을 골라낸 뒤, 그중에서 (p, q)와 가장 가까운 레스토랑을 찾으면 된다. D만 잘 결정하면 선택된 부분 집합의 크기가 작아서 무식하게 탐색해도 가장 가까운 레스토랑을 빠르게 찾을 수 있다. 작은 값에서 시작해서 교집합이 공집합이 아닐 때까지 D의 값을 두 배씩 늘려가며 탐색한다.

물론 더 적합한 다른 자료구조, 예를 들어 쿼드트리(Quadtrees)와 k-d 트리가 있긴 하지만 이 접근법으로도 실무에서 잘 동작한다.

이진 탐색 트리와 구간이 입력으로 주어졌을 때, 해당 구간 안에 존재하는 이진 탐색 트리의 키를 반환하는 프로그램을 작성하라. 예를 들어 그림 14.1의 트리에서 구간이 [16, 31]이라면 17,19,23,29,31을 반환해야 한다.

> 힌트: 후임자(successor) 함수를 m번 반복적으로 호출했을 때 얼마나 많은 간선을 순회하는가?

무식한 방법은 이진 탐색 트리를 순회(전위 순회, 중위 순회, 후위 순회)하면서 해당 구간 안에 있는 키를 모두 기록하면 된다. 노드가 n개일 때 이 방법의 시간 복잡도는 $O(n)$이다.

하지만 이 방법은 보통의 이진 트리에서도 동작하므로 이진 탐색 트리의 속성을 제대로 활용하지 않았다.

불필요한 순회를 제거하기 위해 다음과 같은 이진 탐색 트리의 속성을 사용해 보자.

- 만약 루트의 키가 구간의 왼쪽 끝보다 작다면, 왼쪽 부분 트리의 어떤 노드도 구간 안에 속하지 않는다.
- 만약 루트의 키가 구간의 오른쪽 끝보다 크다면, 오른쪽 부분 트리의 어떤 노드도 구간 안에 속하지 않는다.
- 만약 루트의 키가 구간 안에 속한다면, 왼쪽과 오른쪽 부분 트리 모두 구간 안에 속할 가능성이 있다.

예를 들어 그림 14.1의 트리와 [16, 42]가 입력으로 주어졌다고 가정하자. 키값이 19인 A에서 순회를 시작한다. 19는 [16, 42]에 속하므로 A의 자식인 B와 I를 모두 탐색한다. B의 키값인 7은 16보다 작으므로 B의 왼쪽 부분 트리는 [16, 42] 구간에 속하지 않는다. 비슷하게 I의 키값인 43은 42보다 크기 때문에 I의 오른쪽 부분 트리는 탐색할 필요가 없다.

```java
private static class Interval {
    public int left, right;

    public Interval(int left, int right) {
        this.left = left;
        this.right = right;
    }
}

public static List<Integer> rangeLookupInBST(BSTNode<Integer> tree, Interval interval) {
    List<Integer> result = new ArrayList<>();
    rangeLookupInBSTHelper(tree, interval, result);
    return result;
}

public static void rangeLookupInBSTHelper(BSTNode<Integer> tree, Interval interval, List<Integer> result) {
    if (tree == null) {
        return;
    }
    if (interval.left <= tree.data && tree.data <= interval.right) {
        // tree.data는 구간 안에 속한다.
        rangeLookupInBSTHelper(tree.left, interval, result);
        result.add(tree.data);
        rangeLookupInBSTHelper(tree.right, interval, result);
    } else if (interval.left > tree.data) {
        rangeLookupInBSTHelper(tree.right, interval, result);
    } else { // interval.right >= tree.data
        rangeLookupInBSTHelper(tree.left, interval, result);
    }
}
```

시간 복잡도 분석은 살짝 까다롭다. 시간 복잡도를 특정 구간에 속한 키의 개수인 m과 관련있다고 생각할 수 있다. 노드를 두 그룹으로 나눠보자. 하나는 재귀 호출을 했던 그룹이고 다른 하나는 호출하지 않았던 그룹이라고 하자. 우리의 예제에서 프로그램은 A,B,F,G,H,I,J,K,L,M,N을 재귀적으로 호출한다. 이 키들이 전부 특정 구간에 속하는 건 아니지만, 이 키들 외의 노드들은 절대 구간에 속하지 않는다. 잘 살펴보면 이들을 세 가지 부분 집합으로 나눌 수 있다. 16의 탐색경로상에 있는 노드, 42의 탐색경로상에 있는 노드, 나머지 노드, 세 번째 부분 집합에 속한 노드들은 반드시 구간 안에 존재하지만, 앞의 두 부분 집합에 있는 노드들은 그럴 수도 있고 아닐 수도 있다. 처음 두 부분 집합을 구하는 데 걸리는 시간은 $O(h)$이고 세 번째 부분 집합을 구하는 데 걸리는 시간은 $O(m)$이다. 모든 간선은 트리를 밑으로 순회할 때와 위로 돌아올 때 두 번씩 방문한다. 따라서 전체 시간 복잡도는 $O(m + h)$가 된다. 이 방법은 트리가 균형 잡혀 있고 특정 구간 안에 속한 키의 개수가 적다면, 무식한 방법인 $O(n)$보다 훨씬 낫다.

### 이진 탐색 트리 보강

지금까지 우리가 생각했던 이진 탐색 트리는 각 노드가 키, 왼쪽 자식, 오른쪽 자식, 가능하면 부모 정보까지 가지고 있는 트리였다. 노드에 변수를 추가하면 특정 쿼리를 빠르게 처리할 수 있다. 예를 들어 다음 문제를 생각해 보겠다.

삽입, 삭제, 정수값인 키 탐색, 구간 검색(해당 구간에 존재하는 키의 개수)을 효율적으로 수행하는 자료구조가 필요하다고 가정해 보자.

이진 탐색 트리를 사용하면 삽입, 삭제, 탐색을 효율적으로 수행할 수 있다. [U,V] 구간에 존재하는 키의 개수를 셀 때는 U보다 크거나 같은 첫 번째 노드를 찾은 뒤 V보다 키값이 큰 노드(혹은 더 이상 노드가 없을 때까지)를 만날 때까지 후임자 함수(문제 9.10)를 호출하면 된다. h가 트리의 높이고 m이 구간 안에 속한 노드의 개수일 때 전체 시간 복잡도는 $O(h + m)$이 된다. m이 크다면 이 방법은 느릴 수밖에 없다.

이진 탐색 트리의 노드에 변수를 추가하면 더 빠르게 할 수 있다. 특히, 각 노드를 루트로 하는 부분 트리의 전체 노드의 개수를 저장하는 size 변수를 추가한다.

특정 값보다. 작은 원소의 개수를 찾는 경우만 우선 생각해 보자. 예를 들어 그림 14.1의 이진 탐색 트리의 각 노드가 size 정보를 가지고 있을 때, 40보다 작은 키의 개수를 찾는다. 루트 A의 키값인 19는 40보다 작으므로 이진 탐색 트리의 속성에 의해 A의 왼쪽 부분 트리는 모두 40보다 작다. 따라서 7(왼쪽 자식의 size를 통해 알 수 있다.)과 1(A 자신)을 더한 뒤에 A의 오른쪽 자식을 재귀 호출 하면 된다.

이를 일반화해서 v보다 작은 모든 원소를 세어 보자. 일단 count 변수를 0으로 초기화한다. 트리에 중복된 키가 있을 수 있으므로 문제 14.2의 해법인 중위 순회를 사용해서 처음 등장하는 v를 찾는다. (만약 v가 존재하지 않는다면 그 사실을 알았을 때 탐색을 중지한다.) 왼쪽 자식을 순회할 때 count는 변하지 않는다. 오른쪽 자식을 순회할 때, '1 + 왼쪽 자식의 크기'만큼 count 변수에 더한다. 만약 v가 존재한다면 첫 번째 등장하는 v에 도달했을 때, v의 왼쪽 자식의 크기만큼 더해 준다. 같은 방법으로 v보다 큰 원소의 개수, v보다 작거나 같은 원소의 개수, v보다 크거나 같은 원소의 개수를 셀 수도 있다.

예를 들어 그림 14.1의 이진 탐색 트리에서 40보다 작은 원소의 개수를 세어 보자.

- A의 키값인 19는 40보다 작으므로 7 + 1 = 8을 count에 더해 주고 I로 넘어간다.
- I의 키값인 43은 40보다 크므로 I의 왼쪽 자식인 J로 넘어간다.
- J의 키값인 23은 40보다 작으므로 count를 8 + 1 = 9로 갱신하고 K로 넘어간다.
- K의 키값인 37은 40보다 작으므로 count를 9 + 2 + 1 = 12로 갱신하고 N으로 넘어간다.
- N의 키값인 41은 40보다 크므로 N의 왼쪽 자식으로 넘어간다.
- 40보다 작은 키값이 더 이상 존재하지 않으므로 12를 반환한다.

여기서 어떻게 A와 K의 왼쪽 부분 트리를 탐색하지 않게 되었는지 잘 살펴보길 바란다.

탐색을 할 때마다 트리 아래로 내려가므로 시간 복잡도의 상한은 $O(h)$이다. m값이 큰 경우에는 (예를 들어 m값이 전체 노드 개수와 비슷한 경우) 이 방법이 반복적으로 후임자를 호출하는 것보다 훨씬 빠르다.

[L, U] 구간 사이에 있는 키의 개수를 셀 때는 L보다 작은 키의 개수를 세고, U보다 큰 키의 개수를 센 뒤에 전체 노드의 개수(루트에 저장된 size값)에서 이들을 뺀다.

size 변수는 삽입 혹은 삭제를 할 때 갱신되는데, 그 시간 복잡도가 $O(h)$를 벗어나지 않는다. 본질적으로, size 변수를 수정해야 하는 노드는 추가된 노드 혹은 삭제된 노드의 탐색 경로 상에 있는 노드들뿐이다. 이 경로상에 있는 각 노드에 대해 일부 조건부 검사가 필요하지만 상수 시간에 해결되므로 삽입/삭제에 소요되는 $O(h)$ 시간 복잡도를 벗어나지 않는다.

## 문제 14.11 신용 정보 관리 서버 설계하기

많은 수의 고객과 연결되어 있는 서버를 생각해 보자. 각 고객은 문자열로 구별한다. 각 고객은 음이 아닌 정수값인 '신용' 정보가 있다. 이 서버에는 어떤 고객이 추가됐는지, 삭제됐는디, 갱신됐는디, 탐색을 했는지 알 수 있는 자료구조가 필요하다. 추가로 이 서버는 모든 고객의 신용에 특정 값을 동시에 더할 수 있어야 한다.

다음 메서드를 구현하는 자료구조를 설계하라.

- 삽입: 특정 신용값과 함께 고객을 추가한다. 해당 고객이 존재한다면 새로운 고객 정보로 대체한다.
- 삭제: 특정 고객을 삭제한다.
- 탐색: 특정 고객의 신용값을 반환한다.
- 모두의 신용값에 더하기: 모든 고객의 신용값에 특정 값을 더한다.
- 최댓값: 신용값이 최대인 고객을 반환한다.

> 힌트: 전역 상태를 추가로 사용해서 필요한 정보를 저장하라.

이런 애플리케이션에서는 자연스럽게 해시 테이블을 떠올리게 된다. 하지만 해시 테이블은 최댓값을 효율적으로 찾는 연산이 없고, 모든 원소를 순회하면서 동시에 값을 더하는 확실한 방법도 없다. 이진 탐색 트리를 사용하면 최댓값을 효율적으로 찾을 수 있지만, 기본적으로 전체에 더하는 연산을 지원하지 않는다.

객체에 어떤 행동을 추가하는 일반적인 원칙은 객체를 감싸는 래퍼(wrapper)를 만들어서 여기에 함수를 추가하는 것이다. 그리고 그 결과를 반환하기 전이나 후에 해당 행동을 적용한다. 여기서는 이진 탐색 트리에 고객을 저장하고, 전체 증가한 양을 추적하는 래퍼를 사용할 것이다.

예를 들어 고객이 A,B,C이고, 각각 신용이 1,2,3이라고 해보자. 전체 신용에 5를 더하려면 래퍼에 총 증가한 양이 5라고 설정한다. 이진 탐색 트리에서 B의 신용값을 탐색하면 2를 반환하고, 여기에 5를 더한 값을 최종적으로 반환한다. 전체 신용에 4만큼 더하고 싶으면 단순하게 전체 증가한 양을 9로 갱신하면 된다.

그런데 '모두에게 더하기' 연산을 호출한 후에 고객이 추가되면 문제가 발생한다. 앞의 예제를 계속해서 살펴보자. 이제 신용값이 6인 D를 추가한 뒤, D의 신용값을 탐색하면 6 + 9를 반환하게 된다. 실제로는 6을 반환해야 한다.

이를 해결하는 해법은 간단하다. 전체 증가한 양을 신용값에서 뺀다. 즉, D를 추가할 때, 신용값을 6으로 설정하지 않고 6 - 9 = -3으로 설정한 뒤 이진 탐색 트리에 삽입한다. 이제 D의 신용값을 탐색하면 올바르게 -3 + 9 = 6을 반환한다.

이진 탐색 트리의 키는 신용값이고, 이에 상응하는 값은 고객이 된다. 이렇게 하면 최댓값을 빠르게 찾을 수 있다. 하지만 고객을 빠르게 탐색하거나 삭제하려면, 이진 탐색 트리만으로는 부족하다. (고객ID가 아닌 신용값으로 순서가 매겨져 있기 때문에). 이때 키가 고객이고, 값이 신용값인 해시 테이블을 추가로 사용하면 이 문제를 해결할 수 있다. 탐색은 간단하다. 삭제를 하려면 해시 테이블을 통해 해당 고객의 신용값을 얻은 뒤, 이진 탐색 트리에서 해당 신용값과 같은 고객의 집합을 찾고 최종적으로 해당 고객을 집합에서 제거한다.

```java
public static class ClientsCreditsInfo {
    private int offset = 0;
    private Map<String, Integer> clientToCredit = new HashMap<>();
    private NavigableMap<Integer, Set<String>> creditToClients = new TreeMap<>();

    public void insert(String clientID, int c) {
        remove(clientID);
        clientToCredit.put(clientID, c - offset);
        Set<String> set = creditToClients.get(c - offset);
        if (set == null) {
            set = new HashSet<>();
            creditToClients.put(c - offset, set);
        }
        set.add(clientID);
    }

    public boolean remove(String clientID) {
        Integer clientCredit = clientToCredit.get(clientID);
        if (clientCredit != null) {
            creditToClients.get(clientCredit).remove(clientID);
            if (creditToClients.get(clientCredit).isEmpty()) {
                creditToClients.remove(clientCredit);
            }
            clientToCredit.remove(clientID);
            return true;
        }
        return false;
    }

    public int lookup(String clientID) {
        Integer clientCredit = clientToCredit.get(clientID);
        return clientCredit == null ? -1 : clientCredit + offset;
    }

    public void addAll(int c) {
        offset += c;
    }

    public String max() {
        return creditToClients.isEmpty()
            ? ""
            : creditToClients.lastEntry().getValue().iterator().next();
    }
}
```

삽입과 삭제 연산은 이진 탐색 트리의 특징에 따라 $O(\log n)$이 된다. 여기서 n은 자료구조 내의 고객 수에 해당된다. 탐색과 '모두에게 더하기' 연산은 해시테이블만 사용하므로 $O(1)$ 시간이 걸린다. 라이브러리의 이진 탐색 트리 구현은 최댓값 찾는 연산을 $O(1)$에 수행하기 위해 캐시를 사용한다.
