# 14장 이진 탐색 트리

이진 탐색 트리(BST)는 배열과 비슷하지만 저장된 값(키)이 정렬되어 있다. 이진 탐색 트리에서 키값을 탐색할 수도 있고 최솟값 혹은 최댓값을 찾을 수도 있다. 탐색할 키값(꼭 이진 탐색 트리에 없어도 된다)의 전임자(predecessor) 혹은 후임자(successor)를 찾을 수도 있고, 정해진 범위에서 키값을 정렬된 상태로 나열할 수도 있다. 또한 정렬된 배열과 다르게 이진 탐색 트리에서는 원소를 추가하거나 삭제하는 작업을 효율적으로 할 수 있다.

이진 탐색 트리는 9장에서 말한 것처럼 비교 가능한(예를 들어 정수값이나 문자열) 키가 노드에 저장된 이진 트리를 말한다. 노드에 저장된 키는 이진 탐색 트리의 속성을 만족해야 한다. 어떤 노드의 키값은 그 노드보다 왼쪽에 놓인 부분 트리의 노드 키값보다 커야 하고, 오른쪽에 놓인 부분 트리의 노드 키값보다 작거나 같아야 한다. 그림 14.1에는 첫 16개의 소수를 키값으로 하는 이진 탐색 트리가 예제로 주어졌다.

탐색, 삽입, 삭제 연산의 시간 복잡도는 트리의 높이에 비례한다. 따라서 삽입과 삭제를 단순하게 구현하면 최악의 경우에 $O(n)$이 될 수도 있다. 하지만 트리의 높이 상한을 $O(\log n)$으로 유지하는 삽입 및 삭제 구현 방식이 존재한다. 이를 위해선 트리의 노드에서 추가적인 데이터를 저장하거나 갱신하기도 한다. 레드-블랙 트리는 높이가 균형 잡힌 이진 트리의 한 예제이며 자료구조 라이브러리에서 널리 사용되고 있다.

이진 탐색 트리의 흔한 실수 중 하나는 이진 탐색 트리의 객체를 갱신할 때 생긴다. 객체가 이진 탐색 트리에 존재하더라도 제대로 찾지 못하는 경우가 발생하는 것이다. 이진 탐색 트리의 객체를 갱신할 때는, 일단 트리에서 해당 객체를 삭제한 뒤 다시 추가해야 한다. (일반적으로 수정 가능한 객체는 이진 탐색 트리에 집어 넣지 않도록 하자.)

다음은 이진 탐색 트리의 프로토타입이다.

```java
public class BSTNode<T> {
    public T data;
    public BSTNode<T> left, right;
}
```

## 이진 탐색 트리 부트 캠프

이진 탐색 트리가 사용되는 가장 기본적인 예는 탐색이다. 해시 테이블과 달리 이진 탐색 트리에서는 최솟값과 최댓값을 찾을 수 있고, 그 다음으로 큰 원소 혹은 그 다음으로 작은 원소를 찾을 수도 있다. 이러한 연산은 라이브러리에 구현된 이진 탐색 트리를 사용하면 탐색, 삭제, 연산과 마찬가지로 $O(\log n)$의 시간이 걸린다. 이진 탐색 트리와 해시 테이블 모두 $O(n)$의 공간을 사용하지만, 실제로 이진 탐색 트리는 공간을 그보다 조금 더 사용한다.

다음 프로그램은 주어진 값이 이진 탐색 트리에 존재하는지 확인하는 프로그램이다. 이진 탐색 트리에서 연산을 수행할 때 재귀가 얼마나 강력한지 보여 준다.

```java
public static BSTNode<Integer> searchBST(BSTNode<Integer> tree, int key) {
    return tree == null || tree.data == key
        ? tree
        : key < tree.data ? searchBST(tree.left, key)
                          : searchBST(tree.right, key);
}
```

이 프로그램은 각 단계마다 트리의 밑으로 내려가고, 각 높이에서 $O(1)$ 시간을 사용하므로 전체 시간 복잡도는 $O(h)$가 된다. 여기서 h는 트리의 높이를 말한다.

## 이진 탐색 트리 문제를 풀기 전 꼭 알고 있어야 할 내용

- 이진 탐색 트리에서는 $O(n)$ 시간에 원소를 **정렬된 순서로 순회**할 수 있다.(균형이 잡혀 있지 않아도 된다.) [문제 14.2]
- 어떤 문제는 **이진 탐색 트리와 해시 테이블을 함께 사용**해야 한다. 예를 들어 학생 객체를 GPA를 기준으로 정렬해 이진 탐색 트리에 삽입했다고 가정하자. 이때 학생의 GPA를 갱신해야 한다면, 그리고 주어진 정보가 학생의 이름과 새로운 GPA뿐이라면, 학생의 이름으로 트리를 모두 순회해야 한다. 하지만 추가로 해시테이블을 사용한다면 필요한 노드에 직접 도달할 수 있다.
- 때로는 간격(interval)과 같은 더 복잡한 데이터를 제어하고, 범위의 요소 개수와 같은 더 복잡한 쿼리를 효과적으로 지원하기 위해 이진 탐색 트리를 **보강(augment)**할 필요가 있다. [문제 14.11]
- 이진 탐색 트리의 속성은 **전역적인(global) 속성**이다. 즉, 이진 트리는 각 노드의 키가 왼쪽 자식 키보다 크고 오른쪽 자식 키보다 작은 속성을 가질 수 있지만, 그렇더라도 이진 탐색 트리가 아닐 수 있다. [문제 14.1]

## 이진 탐색 트리 라이브러리 이해하기

Java에서 흔히 사용되는 이진 탐색 트리 기반 자료구조는 TreeSet과 TreeMap이다. TreeSet는 Set 인터페이스를 구현했고, TreeMap은 Map 인터페이스를 구현했다. Set와 Map의 기능을 다시 보려면 '12장 해시테이블'을 참고하라.

이진 탐색 트리에서는 키가 정렬되었다는 속성 때문에 TreeSet와 TreeMap의 기능은 Set와 Map보다 많은 기능을 제공한다. 먼저, TreeSet를 통해 원소를 삽입했을 때의 기능은 다음과 같다.

- iterator()에 의해 반환된 반복자(iterator)는 오름차순으로 키를 순회한다. (내림차순으로 순회하고 싶다면 descendingIterator()를 사용하면 된다.)
- first()와 last()는 트리에서 가장 작은 키와 가장 큰 키를 찾는다.
- lower(12)와 higher(3)은 각각 주어진 숫자보다 작은 숫자 중에서 가장 큰 수와 주어진 숫자보다 큰 숫자 중에서 가장 작은 숫자를 찾는다.
- floor(4.9)와 ceiling(5.7)은 주어진 숫자보다 작거나 같은 숫자 중에서 가장 큰 수와 주어진 숫자보다 크거나 같은 숫자 중에서 가장 작은 수를 찾는다.
- headSet(10), tailSet(5), subSet(1, 12)는 주어진 범위 안에 있는 키의 뷰를 반환한다. 기본적으로 트리에 기반하기 때문에 이들의 시간 복잡도가 $O(\log n)$이라는 사실이 특히 중요하다. 따라서 트리를 수정하면 뷰도 수정된다. 결국, size()와 같은 연산의 시간 복잡도도 $O(n)$이 된다.

언제나 그렇듯이 여기에도 미묘한 상황이 존재한다. 예를 들어 비어 있는 트리에서 first()가 어떻게 처리되는지, 널(null)인 경우에 lower()를 호출하면 어떻게 되는지, subSet()의 범위는 닫힌 구간인지 등의 상황이다.

TreeMap에 추가된 기능 중에서, floor(12)는 floorKey(12)와 비슷하고 headMap(28)은 hashSet(28)과 비슷하다.

TreeSet과 TreeMap의 생성자는 키의 순서를 정하는 데 필요한 비교 객체를 명시적으로 지정할 수 있으므로, 이 구문에 익숙해져야 한다. (13장 앞부분에 비교 객체의 구문이 예제로 나와 있다.)

## 문제 14.1 이진 트리가 이진 탐색 트리의 속성을 만족하는지 확인하기

이진 트리가 입력으로 주어졌을 때 해당 트리가 이진 탐색 트리의 속성을 만족하는지 확인하는 프로그램을 작성하라.

> 힌트: 각 노드에 대해서 해당 노드의 키가 왼쪽 자식의 키보다 크거나 작은지 확인하고 오른쪽 자식의 키보다 작거나 같은지 확인하는 게 맞는 걸까?

직접적인 접근 방법은 먼저 이진 탐색 트리의 정의에 따라 루트에서 시작해서 루트의 왼쪽 부분 트리에서 가장 큰 키를 구하고 루트의 오른쪽 부분 트리에서 가장 작은 키를 구하는 것이다. 그다음 루트의 키가 왼쪽 부분 트리에서 가장 큰 키보다 크거나 같고 오른쪽 부분 트리에서 가장 작은 키보다 작거나 같은지 확인한다. 만약 두 조건을 모두 만족하면 루트의 왼쪽 부분 트리와 오른쪽 부분 트리를 재귀적으로 확인한다. 만약 하나라도 조건을 만족하지 않으면 false를 반환한다.

이진 트리에서 가장 작은 키를 찾는 작업은 단순하다. 루트, 왼쪽 부분 트리, 오른쪽 부분 트리에 저장된 키 중에서 가장 작은 키를 찾으면 된다. 가장 큰 키를 찾는 작업도 비슷하다. 일반적인 이진 트리는 이진 탐색 트리의 속성을 만족하지 않을 수 있으므로 최솟값을 찾을 때는 부분 트리의 키를 모두 확인해야 한다.

이 방법의 문제는 부분 트리를 반복해서 탐색한다는 점이다. 최악의 경우엔 한쪽으로 기울어져 있는 이진 탐색 트리의 경우에는 $O(n^2)$의 시간이 걸린다. 여기서 n은 노드의 개수이다. 캐시를 사용해서 각 노드에서 가장 작은 키와 가장 큰 키를 저장하고 있으면 $O(n)$ 시간으로 개선할 수 있다. 하지만 캐시를 사용하느라 $O(n)$의 추가 공간이 든다.

트리의 높이가 h일 때, 시간 복잡도는 $O(n)$이고 공간 복잡도는 $O(h)$가 되는 두 가지 방법을 소개할 것이다.

첫 번째 방법은 각 부분 트리에서 주어진 제약조건을 확인하는 것이다. 처음에는 루트에서 시작한다. 각 노드의 왼쪽(오른쪽) 부분 트리는 반드시 루트의 키보다 작거나 같아야(크거나 같아야) 한다. 이 사실을 일반화하면 다음과 같다. 트리에 있는 모든 노드의 키값 범위를 [l, u]라고 하고 루트의 키를 w라고 했을 때, w는 반드시 [l, u] 사이에 있어야 하고, 왼쪽 부분 트리는 [l, w] 사이에 있어야 하고, 오른쪽 부분 트리의 모든 키는 [w, u] 사이에 있어야 한다.

예제를 살펴보자. 그림 14.1의 이진 탐색 트리에 적용해 보면, 처음 키의 범위는 [$-\infty$, $\infty$]이다. B를 루트로 하는 부분 트리를 재귀 호출하면 키의 범위가 [$-\infty$, 19]가 된다. 여기서 19는 A의 왼쪽 부분 트리가 가질 수 있는 키의 상한이 된다. F를 루트로 하는 부분 트리를 재귀 호출하면 키의 범위는 [7, 19]가 된다. K를 루트로 하는 부분 트리를 재귀 호출하면 키의 범위는 [23, 43]이 된다. 그림 9.1에 나와 있는 이진 트리는, 재귀 호출을 통해 C까지 내려가 보면 이진 탐색 트리가 아니라는 사실을 알 수 있다. C의 키의 범위는 [$-\infty$, 6]이지만 F의 키는 271이므로 이진 탐색 트리의 속성을 만족하지 못한다.

```java
public static boolean isBinaryTreeBST(BinaryTreeNode<Integer> tree) {
    return areKeysInRange(tree, Integer.MIN_VALUE, Integer.MAX_VALUE);
}

private static boolean areKeysInRange(BinaryTreeNode<Integer> tree, Integer lower, Integer upper) {
    if (tree == null) {
        return true;
    } else if (Integer.compare(tree.data, lower) < 0 || Integer.compare(tree.data, upper) > 0) {
        return false;
    }

    return areKeysInRange(tree.left, lower, tree.data) &&
           areKeysInRange(tree.right, tree.data, upper);
}
```

시간 복잡도는 $O(n)$이고, 추가적인 공간 복잡도는 $O(h)$이다. h는 트리의 높이다.

중위 순회를 사용하는 방법도 있다. 중위 순회는 키값을 정렬된 순서로 방문한다. 따라서 중위 순회의 결과가 정렬되어 있다면, 해당 이진 트리는 반드시 이진 탐색 트리이다. (이것은 이진 탐색 트리의 정의와 중위 순회의 정의를 그대로 따른다.) 따라서 중위 순회를 통해 가장 최근에 방문한 노드의 키를 저장함으로써 이진 탐색 트리의 속성을 확인할 수 있다. 새로운 노드를 방문할 때마다 바로 이전에 방문했던 키와 비교한다. 만약 이전에 방문한 키보다 현재 노드의 키가 크다면 이진 탐색 트리의 속성을 위반한 것이다.

두 방법 모두 왼쪽 부분 트리를 먼저 순회한다. 따라서 이진 탐색 트리의 속성을 만족하지 않는 노드가 루트에 가까이 있다고 하더라도(예를 들어 오른쪽 자식의 키가 루트의 키보다 작은 경우), 시간 복잡도는 여전히 $O(n)$이 된다.

너비 우선 탐색과 같은 방식으로 이진 탐색 트리의 속성을 위반하는 경우를 찾아보자. 이 방법은 이진 탐색 트리의 속성을 만족하지 않는 노드가 루트에 가까이 있는 경우를 보다 빠르게 찾을 수 있다.

구체적으로, 큐에 인접한 노드와 해당 노드의 하한값과 상한값을 함께 삽입한다. 처음에는 큐에 루트 노드와 하한 $-\infty$와 상한 $\infty$를 함께 삽입한다. 반복적으로 각 노드에서 범위의 조건을 확인한다. 만약 해당 조건을 만족하지 않는 노드를 발견하면 탐색을 중지한다. 조건을 만족한 경우에는 자식 노드와 자식 노드의 하한을 함께 큐에 삽입한다.

예를 들어 그림 14.1을 살펴보자. 큐에는 초깃값으로 (A, [$-\infty$, $\infty$])를 삽입한다. 매번 큐에서 노드를 꺼내고 조건을 확인한다. 첫 번째 엔트리 (A, [$-\infty$, $\infty$])를 꺼낸 뒤 A 노드의 자식 노드를 알맞은 범위와 함께 큐에 삽입한다. 예를 들면 (B, [$-\infty$, 19])와 (I, [19, $\infty$])다. 계속해서, (B, [$-\infty$, 19])의 노드를 꺼내서 자식 노드를 더한다. 즉, (C, [$-\infty$, 7])과 (D, [7, 19])를 삽입한다. 이 과정을 반복한다. 모든 노드가 조건을 만족하면 해당 트리는 이진 탐색 트리의 조건을 만족하게 된다.

만약 특정 깊이에서 이진 탐색 트리의 속성을 만족하지 않는 부분 트리가 발견됐다면, 더 이상 깊이 들어가지 않아도 된다. 왜냐하면 각 노드의 키가 될 수 있는 하한과 상한을 가능한 아주 엄격하게 설정했기 때문이다. 해당 조건을 만족하지 않는 순간 해당 트리는 이진 탐색 트리의 속성을 만족하지 않게 된다.

```java
public static class QueueEntry {
    public BinaryTreeNode<Integer> treeNode;
    public Integer lowerBound, upperBound;

    public QueueEntry(BinaryTreeNode<Integer> treeNode, Integer lowerBound, Integer upperBound) {
        this.treeNode = treeNode;
        this.lowerBound = lowerBound;
        this.upperBound = upperBound;
    }
}
```

시간 복잡도는 $O(n)$이고, 추가적인 공간 복잡도는 $O(n)$이다.

## 문제 14.2 이진 탐색 트리에서 주어진 값보다 큰 첫 번째 키 찾기

이진 탐색 트리와 값 하나가 입력으로 주어졌을 때, 중위 순회의 결과 해당 값보다 큰 첫 번째 키를 반환하는 프로그램을 작성하라. 예를 들어 그림 14.1의 이진 탐색 트리와 입력값 23이 주어진다면 29를 반환해야 한다.

> 힌트: 추가적인 상태를 유지하면서 이진 탐색을 수행하라.

이진 탐색 트리의 노드가 n개일 때, 단순하게 중위 순회를 하면 $O(n)$ 시간에 해당 노드를 찾을 수 있다. 하지만 이 방법은 이진 탐색 트리의 속성을 사용하지 않았다.

이보다 더 나은 접근법은 이진 탐색 트리의 탐색 특성을 사용하는 것이다. 가장 적합한 후보를 저장한 뒤 트리를 한 칸씩 내려가면서 해당 후보를 반복적으로 갱신한다. 부분 트리의 키와 입력값을 비교한 뒤 탐색하지 않아도 될 부분 트리를 제거해 나간다. 즉, 현재 부분 트리의 루트값이 입력값보다 작거나 같으면 오른쪽 부분 트리를 탐색한다. 만약 현재 부분 트리의 루트값이 입력값보다 크다면, 후보를 현재 루트로 갱신한 뒤 왼쪽 부분 트리를 탐색해 나간다. 우리가 원하는 결과는 현재 노드를 루트로 하는 트리 내에 반드시 존재해야 하기 때문에 이 알고리즘은 올바르게 동작한다.

예를 들어 그림 14.1의 이진 탐색 트리에서 23보다 큰 첫 번째 노드를 찾아야 한다고 하면, A,I,J,K,L의 순서로 노드를 방문하게 될 것이다. L은 왼쪽 자식이 없고 이 노드의 키는 29이기 때문에 29가 결과가 된다.

```java
public static BSTNode<Integer> findFirstGreaterThanK(BSTNode<Integer> tree, Integer k) {
    BSTNode<Integer> subtree = tree, firstSoFar = null;
    while (subtree != null) {
        if (subtree.data > k) {
            firstSoFar = subtree;
            subtree = subtree.left;
        } else { // 루트와 왼쪽 부분 트리의 모든 키는 k보다 작거나 같으므로 이들은 건너뛴다.
            subtree = subtree.right;
        }
    }
    return firstSoFar;
}
```

트리의 높이가 h일 때 시간 복잡도는 $O(h)$가 된다. 공간 복잡도는 $O(1)$이다.

## 문제 14.3 이진 탐색 트리에서 가장 큰 k개의 원소 찾기

이진 탐색 트리는 정렬된 자료구조이므로 k번째로 큰 원소를 찾는 작업은 쉽다.

이진 탐색 트리와 정수값 k가 입력으로 주어졌을 때, 이진 탐색 트리에서 가장 큰 k개의 원소를 반환하는 프로그램을 작성하라. 예를 들어 이진 탐색 트리가 그림 14.1로 입력되고 k = 3이면 (53,47,43)을 반환해야 한다.

> 힌트: 중위 순회로 얻을 수 있는 결과는 무엇인가?

무식한 방법으로 접근해 보자. 중위 순회를 통해 키를 오름차순으로 순회하면서 그중에서 마지막 k개의 키를 반환하면 된다. 큐를 사용하면 k번 이전에 방문했던 노드를 손쉽게 빼낼 수 있으므로, 방문한 노드를 저장할 때 사용하면 좋다. 하지만 이 방법은 불필요한 노드를 또한 처리한다는 단점이 있다. 예를 들어 k값이 작으면서 왼쪽 부분 트리가 큰 경우다.

이보다 더 나은 방법은 원하는 노드에서 시작해서 거꾸로 찾아 나가는 방법이다. 먼저 가능한 오른쪽 부분 트리로 재귀적으로 내려간다. 만약 오른쪽 부분 트리가 존재하지 않는 경우에는 왼쪽 부분 트리로 내려간다. 이 방법은 거꾸로 중위 순회를 하는 것과 같다. 그림 14.1의 이진 탐색 트리를 거꾸로 중위 순회를 한다면 그 결과는 `<P,O,I,N,K,M,L,J,A,G,H,F,B,E,C,D>`가 된다.

k개의 노드를 모두 방문한 순간 순회를 중단한다. 다음은 찾고자 하는 키를 동적 배열에 저장하는 코드이다. 배열의 원소가 k개가 되는 수간 해당 배열을 반환한다. 문제에 나와 있는 대로 새롭게 방문하는 노드를 배열의 끝에 저장한다.

```java
public static List<Integer> findKLargestInBST(BSTNode<Integer> tree, int k) {
    List<Integer> kLargestElements = new ArrayList<>();
    findKLargestInBSTHelper(tree, k, kLargestElements);
    return kLargestElements;
}

private static void findKLargestInBSTHelper(BSTNode<Integer> tree, int k, List<Integer> kLargestElements) {
    // 중위 순회를 거꾸로 순회한다.
    if (tree != null && kLargestElements.size() < k) {
        findKLargestInBSTHelper(tree.right, k, kLargestElements);
        if (kLargestElements.size() < k) {
            kLargestElements.add(tree.data);
            findKLargestInBSTHelper(tree.left, k, kLargestElements);
        }
    }
}
```

그림 14.1에서 가장 큰 5개의 키를 찾고자 할 때, 먼저 재귀적으로 A,I,O,P를 순서대로 방문한다. 그 다음에 P,O,I의 순서대로 방문하고 이들을 결과에 추가한다. 그리고 재귀적으로 J,K,N을 순서대로 방문한다. 마지막에 N과 K를 방문한 순간 이들을 결과에 저장한다. 배열에 저장한 키가 다섯 개가 되었으므로 순회를 중단한다.

시간 복잡도는 $O(h + k)$이다. 이는 트리가 균형 잡혀 있고 k가 작은 경우에 일반적인 중위 순회보다 더 빠르다. 복잡도의 상한은 다음과 같이 구할 수 있다. 이 프로그램은 많아야 h번 트리를 내려가고, 그 횟수는 적어도 트리를 다시 올라가는 횟수보다 많다. 또한 결과에 추가할 노드를 방문을 한 뒤에야 트리를 다시 올라간다. k개의 노드를 결과에 넣은 뒤에는 프로그램이 종료된다.

