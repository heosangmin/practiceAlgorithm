# 17장 그리디 알고리즘과 불변식

```text
그리디 알고리즘

그리디 알고리즘은 해법을 단계적으로 계산한다. 각 단계마다 지역적으로(locally) 최적의 결정을 내리며, 이 결정은 절대 변경되지 않는다.
```

그리디 알고리즘이 늘 최적의 해법을 생성하는 것은 아니다. 과거 영국은 1,3,6,12,24,30펜스를 사용했다. 이 동전을 사용해서 48펜스틔 거스름돈을 만든다고 해보자. 동전의 수는 최소한으로 사용해야 한다. 자연스러운 그리디 알고리즘은 가장 액수가 큰 동전을 선택한 뒤 잔돈을 그보다 작거나 같은 동전을 반복해서 선택할 것이다. 48펜스를 만든다고 한다면 30 + 12 + 6, 이렇게 세 개의 동전을 사용할 것이다. 하지만 최적해법은 24펜스짜리 두 개의 동전을 이용하는 것이다.

일반적인 형태의 동전 교환 문제는 NP-난해(hard) 문제이다. 하지만 일부 동전 교환 문제는 그리디 알고리즘으로 풀 수 있다. 예를 들어 동전의 단가가 {1,r,$r^2$,$r^3$}인 경우이다. (미국 동전도 그리디 알고리즘으로 최적해를 구할 수 있다.) 일반적인 문제는 동적 프로그래밍을 사용해서 유사-다항(pseudo-polynomial) 시간에 풀 수 있는데, 문제 16.6과 비슷한 방법을 사용한다.

때로는 문제 대한 그리디 알고리즘이 여러 개 존재하면, 이들 중 일부만 최적의 해법을 제공하기도 한다. 예를 들어 2n의 도시가 한 줄로 늘어 서 있고, 이 중 절반은 흰색, 남은 절반은 검은색이라고 하자. 흰색 도시와 검은색 도시를 일대일 방식으로 짝지어서, 짝지어진 도시를 연결하는 데 필요한 도로 구간의 총 길이가 최소화되도록 해야 한다. 여러 쌍의 도시가 하나의 단일 구간을 공유할 수 있다. 예를 들어 (0,4)와 (1,2)를 짝지으면, 도시 0과 4 사이의 도로 구간을 도시 1과 2에서 사용할 수 있다.

이 문제에 대한 가장 단순한 그리디 알고리즘은 흰색 도시를 순회하면서, 각 흰색 도시와 가장 인접한 검은색 도시 중에 아직 짝이 없는 도시를 짝짓는 것이다. 하지만 이 알고리즘은 가장 최적의 해법이 아니다. 예를 들어 흰색 도시가 0과 3에 있고, 검은색 도시가 2와 5에 있다고 하자. 흰색 도시 3이 먼저 처리되면, 검은색 도시 2와 짝을 이룬다. 그러면 남아 있는 흰색 도시 0은 검은색 도시 5와 짝을 이루게 되므로, 도로 길이는 5가 된다. 반면에 도시 0과 2를 짝짓고, 3과 5를 짝지었다면 도로 길이는 4가 된다.

이렇게 보면, 약간 더 복잡한 그리디 알고리즘이 더 나은 결과를 가져온다. 모든 도시를 왼쪽에서 오른쪽 순서로 반복하면서, 아직 짝이 없는 다른 색깔의 도시와 짝짓는 것이다.

첫 번째 도시에 대한 짝은 최적의 해법이어야 한다. 만약 최적의 짝이 아닌 다른 도시와 짝지어지면, 도로를 추가할 필요가 없는 가장 가까운 검은색 도시와 짝을 이루도록 항상 변경될 수 있기 때문이다. 이러한 관찰은 전체적인 최적성의 귀납적 증거에 사용될 수 있다.

## 그리디 알고리즘 부트 캠프

미국 동전은 1,5,10,25,50,100 센트짜리가 있다. 그리디 알고리즘을 쓰면 최소 개수의 동전으로 필요한 거스름돈을 만들 수 있다. 다음은 이 알고리즘을 구현한 코드다. 특정 값의 동전 수를 한번 선택한 뒤에는, 절대 이 선택을 변경하지 않는 것이 그리디 알고리즘의 특징이다.

```java
public static int changeMaking(int cents) {
    final int[] CONIS = {100,50,25,10,5,1};
    int numCoins = 0;
    for (int i = 0; i < COINS.length; i++) {
        numCoins += cents / COINS[i];
        cents %= COINS[i];
    }
    return numCoins;
}
```

매번 일정한 양의 계산을 하고, 그 과정을 총 여섯 번 반복했으므로 시간 복잡도는 $O(1)$이 된다.

## 그리디 알고리즘 문제를 풀기 전 꼭 알고 있어야 할 내용

- 그리디 알고리즘은 보통, **각 단계에서 가장 최선의 선택**을 할 수 있는 **최적화 문제**에 적합한 선택이다. [문제 17.1]
- 그리디 알고리즘을 재귀적으로 추상화한 뒤에, 성능 향상을 위해 반복문을 써서 **구현**하면 더 쉬운 경우가 많다. [문제 24.31]
- 그리디 방법이 최적 해법을 찾지 못하더라도, 최적 알고리즘을 찾는 통찰력 혹은 휴리스틱에 대한 힌트가 될 수 있다.
- 때로는 어떤 그리디 알고리즘을 선택해야 올바른지 **명확하지 않은** 경우도 있다.

## 문제 17.1 최적의 업무 할당 구하기

노동자에게 업무를 할당하는 문제에 관해 생각해 보자. 각 노동자는 정확히 두 개의 업무를 할당받아야 한다. 각 업무를 완료하는 데 걸리는 시간은 고정되어 있으며, 각 업무는 서로 독립적이다. "3번 업무가 끝나기 전에 4번 업무를 수행할 수 없다"와 같은 제약사항은 없다. 누구나 어떤 업무든 할당받을 수 있다.

모든 업무를 완료하는 데 걸리는 시간이 최소가 되도록 노동자에게 업무를 할당해야 한다. 예를 들어 각각 5,2,1,6,4,4 시간이 걸리는 6개의 업무가 있을 때, 이를 최적으로 할당하는 방법은 처음 두 업무(5시간, 2시간짜리 업무)를 첫 번째 노동자에게 할당하고, 그 다음 두 업무(1시간, 6시간짜리 업무)를 두 번째 노동자에게 할당하고, 그 다음 두 업무(4시간, 4시간짜리 업무)를 세 번째 노동자에게 할당하는 것이다. 이렇게 하면, 모든 업무를 완료하는 데 걸리는 시간은 max(5 + 2, 1 + 6, 4 + 4) = 8시간이 된다.

업무 집합이 입력으로 주어졌을 때, 최적 할당을 반환하는 알고리즘을 설계하라.

> 힌트: 가장 오랜 시간이 걸리는 업무를 할당받은 노동자에게, 얼마만큼의 시간이 필요한 업무를 두 번째로 할당하는 것이 좋을까?

모든 가능한 업무의 쌍을 나열하는 방법은 실행 불가능하다. 그러한 쌍의 개수가 너무 많기 때문이다(n개의 업무가 있을 떄 정확히 $\binom{n}{2}\binom{n-2}{2}\binom{n-4}{2}...\binom{4}{2}\binom{2}{2} = n!/2^{n/2}$의 개수가 존재한다).

이 문제의 구조를 좀 더 자세히 살펴보자. 극단적인 값을 잘 처리하는 게 중요하다. 가장 오래 걸리는 일은 그만큼 많은 도움이 필요하다. 특히, 가장 오래 걸리는 업무를, 가장 빨리 끝낼 수 있는 업무와 쌍으로 묶는 것이 타당해 보인다. 이 사실은 가장 오래 걸리는 업무를 그 외의 업무와 쌍을 이루도록 할당했을 때와 비교해보면 알 수 있다. 가장 긴 시간이 걸리는 업무와 가장 짧은 시간이 걸리는 업무를 쌍으로 묶으면 최소한 더 좋은 결과를 얻을 수 있다.

물론 가장 오래 걸리는 업무와 가장 짧게 걸리는 업무의 합이 늘 최적이 되는 건 아니다. 가장 긴 업무 두 개는 걸리는 시간이 비슷하지만, 가장 짧은 업무 두 개는 걸리는 시간이 많이 차이 나는 경우를 생각해 보면 쉽다. 예를 들어 업무에 걸리는 시간이 각각 1,8,9,10인 경우 모든 업무를 마치는 데 걸리는 시간은 1+10이 아니고 8+9=17이다.

결론적으로 업무에 걸리는 시간순으로 정렬한 뒤, 가장 짧게 걸리는 업무와 가장 오래 걸리는 업무끼리 차례대로 쌍으로 묶어 주면 된다. 예를 들어 업무에 걸리는 시간이 각각 5,2,1,6,4,4라고 하자. 이를 정렬하면 1,2,4,4,5,6이 되고, 따라서 (1,6),(2,5),(4,4)를 쌍으로 묶어주면 된다.

```java
private static class PairedTasks {
    public Integer task1;
    public Integer task2;

    public PairedTasks(Integer task1, Integer task2) {
        this.task1 = task1;
        this.task2 = task2;
    }
}

public static List<PairedTasks> optimumTaskAssignment(List<Integer> taskDurations) {
    Collections.sort(taskDurations);
    List<PairedTasks> optimumAssignments = new ArrayList<>();
    for (int i = 0, j = taskDurations.size() - 1; i < j; i++,j--) {
        optimumAssignments.add(
            new PairedTasks(taskDurations.get(i), taskDurations(j))
        );
    }
    return optimumAssignments;
}
```

시간 복잡도는 정렬하는 데 걸리는 시간인 $O(n \log n)$과 같다.

## 문제 17.2 기다리는 시간을 최소화하기

데이터베이스는 SQL 쿼리에 대한 응답을 반환해야 한다. 각 쿼리를 처리하는 데 걸리는 시간은 이미 알고 있다. 이 애플리케이션에서 데이터베이스는 임의의 순서대로 한번에 하나의 쿼리만 처리해야 한다. 따라서 각 쿼리를 처리하기 전에 기다리는 시간이 존재한다.

각 쿼리를 처리하는 데 걸리는 시간이 주어졌을 때, 총 대기 시간이 최소화되려면 어떤 순서로 쿼리를 실행해야 하는지 알아보자. 예를 들어 각 쿼리를 처리하는 데 걸리는 시간이 <2,5,1,3>일 때, 이대로 쿼리를 처리하면 전체 기다리는 시간은 0 + (2) + (2 + 5) + (2 + 5 + 1) = 17이다. 하지만 가장 오래 걸리는 쿼리부터 시간이 감소하는 순서대로 처리한다면 기다리는 시간은 0 + (5) + (5 + 3) + (5 + 3 + 2) = 23이다. 아래에서 보겠지만, 가장 최소로 기다리는 시간의 합은 10이다.

> 힌트: 극단적인 값에 초점을 맞추라.

모든 가능한 스케줄을 나열한 뒤에 가장 적게 기다리는 것을 고르면 된다. 그런데 이 방법의 복잡도는 굉장히 높다. n개의 쿼리가 있을 때, $O(n!)$ 시간이 걸린다.

직관적으로 생각하면 시간이 적게 걸리는 쿼리를 먼저 처리하는 게 나아 보인다. 왜냐하면 각 쿼리를 처리하는 데 걸리는 시간은 남아 있는 모든 쿼리의 기다리는 시간에 추가되기 때문이다. 따라서 시간이 오래 걸리는 쿼리가 시간이 적게 걸리는 쿼리 앞에 있을 때, 이를 맞바꾸면 이 둘 사이에 존재하는 모든 쿼리의 기다리는 시간을 줄일 수 있고, 다른 쿼리의 기다리는 시간에 영향을 미치지도 않는다. 물론 시간이 오래 걸리는 쿼리 자체의 기다리는 시간은 증가하지만, 그만큼 시간이 적게 걸리는 쿼리의 기다리는 시간이 줄어들어서 상쇄된다. 따라서 처리 시간이 증가하는 순서대로 쿼리를 정렬한 뒤 차례대로 실행하면 된다.

주어진 예제에서 최적의 스케줄은 처리 시간이 증가하는 순서대로 쿼리를 배치했을 때이다. 따라서 전체 기다리는 시간은 0 + (1) + (1 + 2) + (1 + 2 + 3) = 10이 된다. 가장 오래 걸리는 쿼리부터 시간이 감소하는 순서대로 스케줄링한 결과는 최악의 방법이었다.

```java
public static int minimumTotalWaitingTime(List<Integer> serviceTimes) {
    // serviceTimes을 증가하는 순서대로 정렬한다.
    Collections.sort(serviceTimes);

    int totalWaitingTime = 0;
    for (int i = 0; i < serviceTimes.size(); i++) {
        int numRemainingQueries = serviceTimes.size() - (i + 1);
        totalWaitingTime += serviceTimes.get(i) * numRemainingQueries;
    }
    return totalWaitingTime;
}
```

시간 복잡도는 정렬하는 데 걸리는 시간과 같은 $O(n \log n)$이다.

## 문제 17.3 모든 구간을 커버하기

공장에서 몇 가지 업무를 책임져야 하는 현장감독을 생각해 보자. 각 업무는 정해진 시간에 시작해서 정해진 시간에 끝난다. 현장감독은 공장에 직접 방문해서 업무가 잘 돌아가는지 확인하고 싶어 한다. 여러분이 해야 할 일은 현장감독이 공장을 방문하는 횟수를 최소화하는 것이다. 현장감독은 매번 방문할 때마다, 현재 진행 중인 모든 업무를 확인한다. 현장감독은 특정 시간에 현장을 방문하고, 정확히 그 시간에 수행되는 업무만을 확인할 수 있다. 예를 들어 [0,3], [2,6], [3,4], [6,9]의 시간에 수행되는 업무 4개가 있을 때, 현장감독이 0,2,3,6시간에 방문하면 모든 업무를 확인할 수 있다. 하지만 3,6시간에만 방문해도 모든 업무를 확인할 수 있다. 이 문제를 추상화하면 다음과 같다.

닫힌 구간의 집합이 주어졌을 때, 가장 적은 숫자로 모든 구간을 커버할 수 있는 알고리즘을 설계하라.

> 힌트: 극단적인 입력값을 생각해 보라.

각 구간의 끝에 있는 숫자만 고려해도 이 문제를 풀 수 있다는 사실을 기억하길 바란다. 무식한 방법은 모든 가능한 끝부분의 숫자의 부분 집합을 나열한 뒤, 해당 부분 집합이 모든 구간을 커버하는지 확인하는 것이다. 만약 모든 구간을 커버하고 현재의 부분 집합의 크기가 이전보다 작다면 그 결과를 갱신한다. 모든 부분 집합의 개수는 $2^k$이므로, 이 방법의 시간 복잡도는 굉장히 높다.

간단하게 모든 구간의 왼쪽 끝지점을 반환해도 된다. 이렇게 하면 굉장히 빠르게 부분 집합을 구할 수 있지만 앞에서도 살펴봤듯이 그 결과가 항상 최소의 개수는 아니다. 이와 비슷하게, 가장 많은 구간을 지나치는 지점을 그리디하게 선택하더라도 그 결과가 부분최적이 될 가능성이 있다. 예를 들어 [1,2], [2,3], [3,4], [2,3], [3,4], [4,5]의 경우를 생각해 보자. 3은 여섯 개의 구간 중, 네 개의 구간에서 등장한다. 하지만 3을 선택한다면 [1,2]와 [4,5]를 커버하지 못하므로 추가로 두 개의 지점을 더 선택해야 한다. 그런데 2와 4 지점을 선택한다면, 각각 3개의 구간을 커버해서 단 두개의 지점으로 모든 구간을 커버할 수 있다.

극단적인 경우에 초점을 두는 것이 좋다. 특히 첫 번째로 끝나는 지점, 즉 구간의 오른쪽 끝점의 위치가 가장 작은 것에 집중해 보자. 이 지점을 커버하기 위해서는 해당 구간을 지나는 부분을 선택해야 한다. 그중에서도 반드시 오른쪽 끝 지점을 선택해야 한다. 왜냐하면 그 앞의 어떤 지점을 선택하든지 끝 지점을 선택하는 것보다 더 나은 선택이 아니기 때문이다. (이게 참이 아니라면, 우리가 선택한 그 구간의 끝지점이 첫 번째로 끝나는 지점이 아니라는 뜻이 된다.) 끝 지점을 선택한 뒤에, 커버되는 모든 구간을 삭제한 뒤 남아 있는 구간들로 앞의 과정을 반복한다.

앞의 과정을 다음 알고리즘으로 나타낼 수 있다. 모든 구간을 오른쪽 끝 지점을 기준으로 정렬한다. 첫 번째 구간의 오른쪽 끝 지점을 선택한다. 커버되지 않는 첫 번째 구간이 나올 때까지 정렬된 구간을 차례대로 순회한다. 커버되지 않는 구간을 발견하는 순간 해당 구간의 오른쪽 끝 지점을 선택하고 앞의 과정을 반복한다.

[1,2],[2,3],[3,4],[2,3],[3,4],[4,5]의 예제가 있을 때, 이를 오른쪽 끝점을 기준으로 정렬하면 [1,2],[2,3],[2,3],[3,4],[3,4],[4,5]가 된다. 첫 번째 구간의 오른쪽 끝 지점은 2이고, 이 지점은 처음 세 개의 구간을 커버한다. 다음에 [3,4]를 만나게 되면 이 구간의 오른쪽 끝 지점인 4를 선택해서 [3,4],[3,4],[4,5]를 커버한다.  남아 있는 구간이 더 이상 없으므로 {2,4}가 모든 구간을 커버하는 가장 적은 숫자의 집합이 된다.

```java
public static class Interval {
    public int left, right;

    public Interval(int l, int r) {
        this.left = l;
        this.right = r;
    }
}

public static Integer findMinimumVisits(List<Interval> intervals) {
    // 오른쪽 끝점을 기준으로 구간을 정렬한다.
    Collections.sort(intervals, new Comparator<Interval>(){
        @Override
        public int compare(Interval i1, Interval i2) {
            return Integer.compare(i1.right, i2.right);
        }
    });
    List<Integer> visits = new ArrayList<>();
    Integer lastVisitTime = Integer.MIN_VALUE;
    Integer numVisits = 0;
    for (Interval interval : intervals) {
        if (interval.left > lastVisitTime) {
            // 현재의 오른쪽 끝점인 lastVisitTime은 더 이상 커버하는 구간이 없다.
            lastVisitTime = interval.right;
            ++numVisits;
        }
    }
    return numVisits;
}
```

각 인덱스에서 걸린 시간은 $O(1)$이므로 정렬을 한 이후에 걸린 시간은 총 $O(n)$이다. 여기서 n의 구간은 개수이다. 하지만 그전에 정렬을 해야 하므로 이 알고리즘의 전체 시간 복잡도는 정렬을 하는 데 필요한 $O(n \log n)$과 같다.
