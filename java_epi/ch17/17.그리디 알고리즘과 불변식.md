# 17장 그리디 알고리즘과 불변식

```text
그리디 알고리즘

그리디 알고리즘은 해법을 단계적으로 계산한다. 각 단계마다 지역적으로(locally) 최적의 결정을 내리며, 이 결정은 절대 변경되지 않는다.
```

그리디 알고리즘이 늘 최적의 해법을 생성하는 것은 아니다. 과거 영국은 1,3,6,12,24,30펜스를 사용했다. 이 동전을 사용해서 48펜스틔 거스름돈을 만든다고 해보자. 동전의 수는 최소한으로 사용해야 한다. 자연스러운 그리디 알고리즘은 가장 액수가 큰 동전을 선택한 뒤 잔돈을 그보다 작거나 같은 동전을 반복해서 선택할 것이다. 48펜스를 만든다고 한다면 30 + 12 + 6, 이렇게 세 개의 동전을 사용할 것이다. 하지만 최적해법은 24펜스짜리 두 개의 동전을 이용하는 것이다.

일반적인 형태의 동전 교환 문제는 NP-난해(hard) 문제이다. 하지만 일부 동전 교환 문제는 그리디 알고리즘으로 풀 수 있다. 예를 들어 동전의 단가가 {1,r,$r^2$,$r^3$}인 경우이다. (미국 동전도 그리디 알고리즘으로 최적해를 구할 수 있다.) 일반적인 문제는 동적 프로그래밍을 사용해서 유사-다항(pseudo-polynomial) 시간에 풀 수 있는데, 문제 16.6과 비슷한 방법을 사용한다.

때로는 문제 대한 그리디 알고리즘이 여러 개 존재하면, 이들 중 일부만 최적의 해법을 제공하기도 한다. 예를 들어 2n의 도시가 한 줄로 늘어 서 있고, 이 중 절반은 흰색, 남은 절반은 검은색이라고 하자. 흰색 도시와 검은색 도시를 일대일 방식으로 짝지어서, 짝지어진 도시를 연결하는 데 필요한 도로 구간의 총 길이가 최소화되도록 해야 한다. 여러 쌍의 도시가 하나의 단일 구간을 공유할 수 있다. 예를 들어 (0,4)와 (1,2)를 짝지으면, 도시 0과 4 사이의 도로 구간을 도시 1과 2에서 사용할 수 있다.

이 문제에 대한 가장 단순한 그리디 알고리즘은 흰색 도시를 순회하면서, 각 흰색 도시와 가장 인접한 검은색 도시 중에 아직 짝이 없는 도시를 짝짓는 것이다. 하지만 이 알고리즘은 가장 최적의 해법이 아니다. 예를 들어 흰색 도시가 0과 3에 있고, 검은색 도시가 2와 5에 있다고 하자. 흰색 도시 3이 먼저 처리되면, 검은색 도시 2와 짝을 이룬다. 그러면 남아 있는 흰색 도시 0은 검은색 도시 5와 짝을 이루게 되므로, 도로 길이는 5가 된다. 반면에 도시 0과 2를 짝짓고, 3과 5를 짝지었다면 도로 길이는 4가 된다.

이렇게 보면, 약간 더 복잡한 그리디 알고리즘이 더 나은 결과를 가져온다. 모든 도시를 왼쪽에서 오른쪽 순서로 반복하면서, 아직 짝이 없는 다른 색깔의 도시와 짝짓는 것이다.

첫 번째 도시에 대한 짝은 최적의 해법이어야 한다. 만약 최적의 짝이 아닌 다른 도시와 짝지어지면, 도로를 추가할 필요가 없는 가장 가까운 검은색 도시와 짝을 이루도록 항상 변경될 수 있기 때문이다. 이러한 관찰은 전체적인 최적성의 귀납적 증거에 사용될 수 있다.

## 그리디 알고리즘 부트 캠프

미국 동전은 1,5,10,25,50,100 센트짜리가 있다. 그리디 알고리즘을 쓰면 최소 개수의 동전으로 필요한 거스름돈을 만들 수 있다. 다음은 이 알고리즘을 구현한 코드다. 특정 값의 동전 수를 한번 선택한 뒤에는, 절대 이 선택을 변경하지 않는 것이 그리디 알고리즘의 특징이다.

```java
public static int changeMaking(int cents) {
    final int[] CONIS = {100,50,25,10,5,1};
    int numCoins = 0;
    for (int i = 0; i < COINS.length; i++) {
        numCoins += cents / COINS[i];
        cents %= COINS[i];
    }
    return numCoins;
}
```

매번 일정한 양의 계산을 하고, 그 과정을 총 여섯 번 반복했으므로 시간 복잡도는 $O(1)$이 된다.

## 그리디 알고리즘 문제를 풀기 전 꼭 알고 있어야 할 내용

- 그리디 알고리즘은 보통, **각 단계에서 가장 최선의 선택**을 할 수 있는 **최적화 문제**에 적합한 선택이다. [문제 17.1]
- 그리디 알고리즘을 재귀적으로 추상화한 뒤에, 성능 향상을 위해 반복문을 써서 **구현**하면 더 쉬운 경우가 많다. [문제 24.31]
- 그리디 방법이 최적 해법을 찾지 못하더라도, 최적 알고리즘을 찾는 통찰력 혹은 휴리스틱에 대한 힌트가 될 수 있다.
- 때로는 어떤 그리디 알고리즘을 선택해야 올바른지 **명확하지 않은** 경우도 있다.

## 문제 17.1 최적의 업무 할당 구하기

노동자에게 업무를 할당하는 문제에 관해 생각해 보자. 각 노동자는 정확히 두 개의 업무를 할당받아야 한다. 각 업무를 완료하는 데 걸리는 시간은 고정되어 있으며, 각 업무는 서로 독립적이다. "3번 업무가 끝나기 전에 4번 업무를 수행할 수 없다"와 같은 제약사항은 없다. 누구나 어떤 업무든 할당받을 수 있다.

모든 업무를 완료하는 데 걸리는 시간이 최소가 되도록 노동자에게 업무를 할당해야 한다. 예를 들어 각각 5,2,1,6,4,4 시간이 걸리는 6개의 업무가 있을 때, 이를 최적으로 할당하는 방법은 처음 두 업무(5시간, 2시간짜리 업무)를 첫 번째 노동자에게 할당하고, 그 다음 두 업무(1시간, 6시간짜리 업무)를 두 번째 노동자에게 할당하고, 그 다음 두 업무(4시간, 4시간짜리 업무)를 세 번째 노동자에게 할당하는 것이다. 이렇게 하면, 모든 업무를 완료하는 데 걸리는 시간은 max(5 + 2, 1 + 6, 4 + 4) = 8시간이 된다.

업무 집합이 입력으로 주어졌을 때, 최적 할당을 반환하는 알고리즘을 설계하라.

> 힌트: 가장 오랜 시간이 걸리는 업무를 할당받은 노동자에게, 얼마만큼의 시간이 필요한 업무를 두 번째로 할당하는 것이 좋을까?

모든 가능한 업무의 쌍을 나열하는 방법은 실행 불가능하다. 그러한 쌍의 개수가 너무 많기 때문이다(n개의 업무가 있을 떄 정확히 $\binom{n}{2}\binom{n-2}{2}\binom{n-4}{2}...\binom{4}{2}\binom{2}{2} = n!/2^{n/2}$의 개수가 존재한다).

이 문제의 구조를 좀 더 자세히 살펴보자. 극단적인 값을 잘 처리하는 게 중요하다. 가장 오래 걸리는 일은 그만큼 많은 도움이 필요하다. 특히, 가장 오래 걸리는 업무를, 가장 빨리 끝낼 수 있는 업무와 쌍으로 묶는 것이 타당해 보인다. 이 사실은 가장 오래 걸리는 업무를 그 외의 업무와 쌍을 이루도록 할당했을 때와 비교해보면 알 수 있다. 가장 긴 시간이 걸리는 업무와 가장 짧은 시간이 걸리는 업무를 쌍으로 묶으면 최소한 더 좋은 결과를 얻을 수 있다.

물론 가장 오래 걸리는 업무와 가장 짧게 걸리는 업무의 합이 늘 최적이 되는 건 아니다. 가장 긴 업무 두 개는 걸리는 시간이 비슷하지만, 가장 짧은 업무 두 개는 걸리는 시간이 많이 차이 나는 경우를 생각해 보면 쉽다. 예를 들어 업무에 걸리는 시간이 각각 1,8,9,10인 경우 모든 업무를 마치는 데 걸리는 시간은 1+10이 아니고 8+9=17이다.

결론적으로 업무에 걸리는 시간순으로 정렬한 뒤, 가장 짧게 걸리는 업무와 가장 오래 걸리는 업무끼리 차례대로 쌍으로 묶어 주면 된다. 예를 들어 업무에 걸리는 시간이 각각 5,2,1,6,4,4라고 하자. 이를 정렬하면 1,2,4,4,5,6이 되고, 따라서 (1,6),(2,5),(4,4)를 쌍으로 묶어주면 된다.

```java
private static class PairedTasks {
    public Integer task1;
    public Integer task2;

    public PairedTasks(Integer task1, Integer task2) {
        this.task1 = task1;
        this.task2 = task2;
    }
}

public static List<PairedTasks> optimumTaskAssignment(List<Integer> taskDurations) {
    Collections.sort(taskDurations);
    List<PairedTasks> optimumAssignments = new ArrayList<>();
    for (int i = 0, j = taskDurations.size() - 1; i < j; i++,j--) {
        optimumAssignments.add(
            new PairedTasks(taskDurations.get(i), taskDurations(j))
        );
    }
    return optimumAssignments;
}
```

시간 복잡도는 정렬하는 데 걸리는 시간인 $O(n \log n)$과 같다.

## 문제 17.2 기다리는 시간을 최소화하기

데이터베이스는 SQL 쿼리에 대한 응답을 반환해야 한다. 각 쿼리를 처리하는 데 걸리는 시간은 이미 알고 있다. 이 애플리케이션에서 데이터베이스는 임의의 순서대로 한번에 하나의 쿼리만 처리해야 한다. 따라서 각 쿼리를 처리하기 전에 기다리는 시간이 존재한다.

각 쿼리를 처리하는 데 걸리는 시간이 주어졌을 때, 총 대기 시간이 최소화되려면 어떤 순서로 쿼리를 실행해야 하는지 알아보자. 예를 들어 각 쿼리를 처리하는 데 걸리는 시간이 <2,5,1,3>일 때, 이대로 쿼리를 처리하면 전체 기다리는 시간은 0 + (2) + (2 + 5) + (2 + 5 + 1) = 17이다. 하지만 가장 오래 걸리는 쿼리부터 시간이 감소하는 순서대로 처리한다면 기다리는 시간은 0 + (5) + (5 + 3) + (5 + 3 + 2) = 23이다. 아래에서 보겠지만, 가장 최소로 기다리는 시간의 합은 10이다.

> 힌트: 극단적인 값에 초점을 맞추라.

모든 가능한 스케줄을 나열한 뒤에 가장 적게 기다리는 것을 고르면 된다. 그런데 이 방법의 복잡도는 굉장히 높다. n개의 쿼리가 있을 때, $O(n!)$ 시간이 걸린다.

직관적으로 생각하면 시간이 적게 걸리는 쿼리를 먼저 처리하는 게 나아 보인다. 왜냐하면 각 쿼리를 처리하는 데 걸리는 시간은 남아 있는 모든 쿼리의 기다리는 시간에 추가되기 때문이다. 따라서 시간이 오래 걸리는 쿼리가 시간이 적게 걸리는 쿼리 앞에 있을 때, 이를 맞바꾸면 이 둘 사이에 존재하는 모든 쿼리의 기다리는 시간을 줄일 수 있고, 다른 쿼리의 기다리는 시간에 영향을 미치지도 않는다. 물론 시간이 오래 걸리는 쿼리 자체의 기다리는 시간은 증가하지만, 그만큼 시간이 적게 걸리는 쿼리의 기다리는 시간이 줄어들어서 상쇄된다. 따라서 처리 시간이 증가하는 순서대로 쿼리를 정렬한 뒤 차례대로 실행하면 된다.

주어진 예제에서 최적의 스케줄은 처리 시간이 증가하는 순서대로 쿼리를 배치했을 때이다. 따라서 전체 기다리는 시간은 0 + (1) + (1 + 2) + (1 + 2 + 3) = 10이 된다. 가장 오래 걸리는 쿼리부터 시간이 감소하는 순서대로 스케줄링한 결과는 최악의 방법이었다.

```java
public static int minimumTotalWaitingTime(List<Integer> serviceTimes) {
    // serviceTimes을 증가하는 순서대로 정렬한다.
    Collections.sort(serviceTimes);

    int totalWaitingTime = 0;
    for (int i = 0; i < serviceTimes.size(); i++) {
        int numRemainingQueries = serviceTimes.size() - (i + 1);
        totalWaitingTime += serviceTimes.get(i) * numRemainingQueries;
    }
    return totalWaitingTime;
}
```

시간 복잡도는 정렬하는 데 걸리는 시간과 같은 $O(n \log n)$이다.
