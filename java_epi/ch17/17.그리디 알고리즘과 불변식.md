# 17장 그리디 알고리즘과 불변식

```text
그리디 알고리즘

그리디 알고리즘은 해법을 단계적으로 계산한다. 각 단계마다 지역적으로(locally) 최적의 결정을 내리며, 이 결정은 절대 변경되지 않는다.
```

그리디 알고리즘이 늘 최적의 해법을 생성하는 것은 아니다. 과거 영국은 1,3,6,12,24,30펜스를 사용했다. 이 동전을 사용해서 48펜스틔 거스름돈을 만든다고 해보자. 동전의 수는 최소한으로 사용해야 한다. 자연스러운 그리디 알고리즘은 가장 액수가 큰 동전을 선택한 뒤 잔돈을 그보다 작거나 같은 동전을 반복해서 선택할 것이다. 48펜스를 만든다고 한다면 30 + 12 + 6, 이렇게 세 개의 동전을 사용할 것이다. 하지만 최적해법은 24펜스짜리 두 개의 동전을 이용하는 것이다.

일반적인 형태의 동전 교환 문제는 NP-난해(hard) 문제이다. 하지만 일부 동전 교환 문제는 그리디 알고리즘으로 풀 수 있다. 예를 들어 동전의 단가가 {1,r,$r^2$,$r^3$}인 경우이다. (미국 동전도 그리디 알고리즘으로 최적해를 구할 수 있다.) 일반적인 문제는 동적 프로그래밍을 사용해서 유사-다항(pseudo-polynomial) 시간에 풀 수 있는데, 문제 16.6과 비슷한 방법을 사용한다.

때로는 문제 대한 그리디 알고리즘이 여러 개 존재하면, 이들 중 일부만 최적의 해법을 제공하기도 한다. 예를 들어 2n의 도시가 한 줄로 늘어 서 있고, 이 중 절반은 흰색, 남은 절반은 검은색이라고 하자. 흰색 도시와 검은색 도시를 일대일 방식으로 짝지어서, 짝지어진 도시를 연결하는 데 필요한 도로 구간의 총 길이가 최소화되도록 해야 한다. 여러 쌍의 도시가 하나의 단일 구간을 공유할 수 있다. 예를 들어 (0,4)와 (1,2)를 짝지으면, 도시 0과 4 사이의 도로 구간을 도시 1과 2에서 사용할 수 있다.

이 문제에 대한 가장 단순한 그리디 알고리즘은 흰색 도시를 순회하면서, 각 흰색 도시와 가장 인접한 검은색 도시 중에 아직 짝이 없는 도시를 짝짓는 것이다. 하지만 이 알고리즘은 가장 최적의 해법이 아니다. 예를 들어 흰색 도시가 0과 3에 있고, 검은색 도시가 2와 5에 있다고 하자. 흰색 도시 3이 먼저 처리되면, 검은색 도시 2와 짝을 이룬다. 그러면 남아 있는 흰색 도시 0은 검은색 도시 5와 짝을 이루게 되므로, 도로 길이는 5가 된다. 반면에 도시 0과 2를 짝짓고, 3과 5를 짝지었다면 도로 길이는 4가 된다.

이렇게 보면, 약간 더 복잡한 그리디 알고리즘이 더 나은 결과를 가져온다. 모든 도시를 왼쪽에서 오른쪽 순서로 반복하면서, 아직 짝이 없는 다른 색깔의 도시와 짝짓는 것이다.

첫 번째 도시에 대한 짝은 최적의 해법이어야 한다. 만약 최적의 짝이 아닌 다른 도시와 짝지어지면, 도로를 추가할 필요가 없는 가장 가까운 검은색 도시와 짝을 이루도록 항상 변경될 수 있기 때문이다. 이러한 관찰은 전체적인 최적성의 귀납적 증거에 사용될 수 있다.

## 그리디 알고리즘 부트 캠프

미국 동전은 1,5,10,25,50,100 센트짜리가 있다. 그리디 알고리즘을 쓰면 최소 개수의 동전으로 필요한 거스름돈을 만들 수 있다. 다음은 이 알고리즘을 구현한 코드다. 특정 값의 동전 수를 한번 선택한 뒤에는, 절대 이 선택을 변경하지 않는 것이 그리디 알고리즘의 특징이다.

```java
public static int changeMaking(int cents) {
    final int[] CONIS = {100,50,25,10,5,1};
    int numCoins = 0;
    for (int i = 0; i < COINS.length; i++) {
        numCoins += cents / COINS[i];
        cents %= COINS[i];
    }
    return numCoins;
}
```

매번 일정한 양의 계산을 하고, 그 과정을 총 여섯 번 반복했으므로 시간 복잡도는 $O(1)$이 된다.

## 그리디 알고리즘 문제를 풀기 전 꼭 알고 있어야 할 내용

- 그리디 알고리즘은 보통, **각 단계에서 가장 최선의 선택**을 할 수 있는 **최적화 문제**에 적합한 선택이다. [문제 17.1]
- 그리디 알고리즘을 재귀적으로 추상화한 뒤에, 성능 향상을 위해 반복문을 써서 **구현**하면 더 쉬운 경우가 많다. [문제 24.31]
- 그리디 방법이 최적 해법을 찾지 못하더라도, 최적 알고리즘을 찾는 통찰력 혹은 휴리스틱에 대한 힌트가 될 수 있다.
- 때로는 어떤 그리디 알고리즘을 선택해야 올바른지 **명확하지 않은** 경우도 있다.

