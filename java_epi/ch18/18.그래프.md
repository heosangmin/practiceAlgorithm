# 18장 그래프

비공식적으로 그래프는 노드(vertex)와 연결된 간선(edge)의 집합을 말한다. 공식적으로 방향 그래프(directed graph)는 노드의 집합 V와 간선의 집합 $E \subset V \times V$를 말한다. 간선 $e = (u,v)$가 주어졌을 때, u는 소스(source) 노드라 하고, v는 싱크(sink) 노드라 한다. 기본적인 그래프 위에 여러 가지 장식을 얹을 수 있는데 예를 들어 간선에 길이를 추가하거나, 노드에 가중치를 추가하거나, 시작 노드를 설정한다. 방향 그래프는 그림 18.1과 같이 표현할 수 있다.

방향 그래프에서 u에서 v까지의 경로(path)는 노드의 수열인 <$v_0, v_1, ..., v_{n-1}$>로 나타낼 수 있다.여기서 $v_0 = u$이고, $v_{n-1} = v$가 된다. 그리고 ($v_i, v_{i+1}$)은 간선을 나타낸다. 경로상의 수열은 하나의 노드로만 이루어질 수 있다. 경로 <$v_0, v_1, ..., v_{n-1}$>의 길이는 n-1이다. 직관적으로 경로의 길이는 경로상의 간선의 개수와 같다. u에서 v로의 경로가 존재한다면, v는 u에서 도달 가능하다고 말한다. 예를 들어 그림 18.1에서 <a,c,e,d,h>는 하나의 경로를 나타낸다.

비순환 방향 그래프(directed acyclie graph, DAG)는 사이클(cycle)이 없는(즉, 하나 이상의 간선을 포함하며, 동일한 노드에서 시작하고 끝나는 경로가 존재하지 않는) 방향 그래프를 말한다. 그림 18.2에 비순환 방향 그래프에 대한 예제가 나와 있다. 비순환 방향 그래프의 노드 중에서 유입 간선(incoming edge)이 없는 노드를 싱크(source)라 한다. 또한 유츨 간선(outgoing edge)이 없는 노드를 싱크(sink)라 한다. 비순환 방향 그래프 노드를 위상적 순서로 배치한다는 뜻은 모든 간선에 대해서 시작 노드를 끝 노드보다 앞에 놓는 것을 말한다. 문제 18.8의 해법에서 위상적 순서 개념을 사용한다.

무방향 그래프(undirected graph) 또한 (V,E)로 나타낸다. 하지만 여기서 E는 순서가 없는 노드 쌍의 집합을 뜻한다. 그림 18.3에서 볼 수 있듯이 시각적으로 두 노드 사이에 방향이 없는 간선을 그린 것과 같다.

G가 무방향 그래프일 때 노드 u와 v가 연결되어 있다는 뜻은 u에서 v로의 경로가 존재한다는 뜻이다. 이 둘이 연결되어 있지 않다면 u와 v는 연결이 끊어졌다고 말한다. 연결된 컴포넌트(connected component)란 G의 노드의 부분 집합인 C가 있을 때 C에 포함된 모든 노드 쌍이 연결되어 있는 최대집합을 말한다. 모든 노드는 정확히 하나의 연결된 컴포넌트에 속해 있다.

예를 들어 그림 18.3의 그래프는 모두 연결되어 있으므로 단 하나의 연결된 컴포넌트로 구성되어 있다. 만약 간선 (h,i)를 제거하더라도, 이 그래프는 여전히 연결되어 있다. 만약 추가로 (f,i)를 제거한다면 이 그래프는 끊어지고 두 개의 연결된 컴포넌트가 된다.

방향 그래프의 모든 간선을 무방향 간선으로 바꾸었을 때 모든 노드가 연결되어 있다면 이러한 방향 그래프를 약하게 연결되어 있다(weakly connected)고 말한다. 모든 노드의 쌍 {u,v}에 대해 u에서 v로의 방향 경로 혹은 v에서 u로의 방향 경로가 존재한다면 이 그래프를 연결되어 있다고 말한다. 만약 u에서 v로의 방향 경로와 v에서 u로의 방향 경로가 동시에 존재한다면 이러한 그래프를 강하게 연결되어 있다(strongly connected)고 말한다.

그래프는 자연스럽게 기하학 문제를 모델링할 때 사용된다. 예를 들면 도시의 연결 여부를 확인하는 문제다. 하지만 더 일반적으로 말하면 그래프는 다양한 종류의 관계를 모델링하기 위해 사용한다.

그래프는 인접 리스트(adjacency list) 혹은 인접 행렬(adjacency matric), 이렇게 두 가지 방법으로 구현할 수 있다. 인접 리스트는 모든 노드 v에 대해 v와 연결된 간선을 리스트로 표현하며, 인접 행렬은 $|V| \times |V|$의 불 행렬로 표현한다. 즉, 각 노드에 인덱스를 부여해서 i번째 노드와 j번째 노드가 연결되어 있으면 (i,j)에 1로 표시한다. 그래프 알고리즘의 시간 혹은 공간 복잡도는 노드와 간선의 함수로 표현한다.

자유 트리(free tree)라고도 부르는, 트리는 그래프의 특별한 종류다. 트리는 방향이 없는 그래프로 연결되어 있지만 사이클이 존재하지 않는다. (트리에 대한 정의를 다양한 방법으로 내릴 수 있다. 예를 들어 모든 노드 쌍 사이에 유일한 경로가 존재하는 그래프를 자유 트리라 한다.) 트리에 대한 기본적인 생각에는 여러 가지 변형이 존재한다. 루트 트리(rooted tree)는 특정한 노드를 루트로 표기한 뒤, 노드 사이의 관계를 부모-자식의 관계로 표현한다. 순서 트리(ordered tree)는 루트 트리의 한 종류로서 각 노드의 자식들 사이에 순서가 존재한다. 9장에서 언급한 이진 트리(binary tree)는 순서 트리와 다르다. 이진 트리의 각 노드는 하나의 자식을 가지고 있을 수 있지만, 그 자식이 왼쪽 자식일 수도 있고 오른쪽 자식일 수도 있다. 하지만 순서트리에서는 자식이 한 명일 경우에 이와 비슷한 표기법이 존재하지 않는다. 특히 이진 트리에서는 자식 노드와 관련된 위치뿐 아니라 순서도 존재한다.

예를 들어 그림 18.4의 그래프는 트리이다. 이 트리의 간선 집합은 그림 18.3의 무방향 그래프에서 사용된 간선 집합의 부분 집합과 같다. 그래프 G = (V,E)가 주어지고 $E' \subset E$인 간선 $E'$에 대해 $G' = (V,E')$가 트리라면, 트리 $G'$을 그래프 G에 대한 신장 트리(spanning tree)라 한다.

## 그래프 부트 캠프

그래프는 두 객체 사이의 관계를 모델링하거나 분석할 때 적합하다. 예를 들어 두 팀 간의 경기 결과 리스트가 주어졌다고 하자. 자연스럽게 이기고 지는 관계를 방향 간선으로 표현한 뒤 A팀에서 시작해서 B팀으로 끝나는 경로가 존재하는지 질문할 수 있을 것이다.

그래프를 사용해서 모델링하면 문제를 매끄럽게 풀 수 있다. 각 팀이 노드가 되고, 팀 사이의 관계를 간선으로 만든다. 즉, 이긴 팀에서 진 팀으로의 방향 간선을 만든다. 이제 두 팀이 도달 가능한지 깊이 우선 탐색(Depth-First Search)이나 너비 우선 탐색(Breadth-First Search)으로 확인해 보면 된다. 다음 프로그램은 깊이 우선 탐색을 사용했다.

```java
public static class MatchResult {
    public String winningTeam;
    public String losingTeam;

    public MatchResult(String winningTeam, String losingTeam) {
        this.winningTeam = winningTeam;
        this.losingTeam = losingTeam;
    }
}

public static boolean canTeamABeatTeamB(List<MatchResult> matches, String teamA, String teamB) {
    Set<String> visited = new HashSet<>();
    return isReachableDFS(buildGraph(matches), teamA, teamB, visited);
}

private static Map<String, Set<String>> buildGraph(List<MatchResult> matches) {
    Map<String, Set<String>> graph = new HashMap<>();
    for (MatchResult match : matches) {
        Set<String> edges = graph.get(match.winningTeam);
        if (edges == null) {
            edges = new HashSet<>();
            graph.put(match.winningTeam, edges);
        }
        edges.add(match.losingTeam);
    }
    return graph;
}

private static boolean isReachableDFS(Map<String, Set<String>> graph, String curr, String dest, Set<String> visited) {
    if (curr.equals(dest)) {
        return true;
    } else if (visited.contains(curr) || graph.get(curr) == null) {
        return false;
    }
    visited.add(curr);
    for (String team : graph.get(curr)) {
        if (isReachableDFS(graph, team, dest, visited)) {
            return true;
        }
    }
    return false;
}
```

경기 결과의 개수가 E일 때 이 문제의 시간 및 공간 복잡도는 $O(E)$이다.

## 그래프 문제를 풀기 전 꼭 알고 있어야 할 내용

- **공간상에서 객체가 연결**되어 있는 문제, 예를 들어 두 도시가 도로로 연결되어 있는 경우에는 자연스럽게 그래프를 사용하면 된다. [문제 18.1, 18.2]
- **실무에서** 웹페이지 간의 연결 관계, 소셜 그래프에서의 팔로워 같은 **객체 간의 이진 관계**를 분석해야 한다면, 그래프 사용을 고려해 보기 바란다. [문제 18.7, 18.8]
- 어떤 그래프 문제는 **구조를 분석**해야 할 필요도 있다. 예를 들어 컴포넌트 사이의 연결 관계 혹은 사이클의 존재 유무 등이다. **깊이 우선 탐색**은 이러한 애플리케이션에 특히 유용하다. [문제 18.4]
- 어떤 그래프 문제는 **최적화** 문제와 관련이 있다. 예를 들면 한 노드에서 다른 노드로의 최단 경로를 찾는 문제가 있다. **너비 우선 탐색, 다익스트라(Dijkstra) 최단 경로 알고리즘, 최소 신장 트리**와 같은 그래프 알고리즘들이 최적화 문제를 풀 때 유용하다.

## 그래프 탐색

어떤 노드에서 다른 노드로 도달 가능한지 확인할 때 사용하는 두 가지 전통적인 방법이 있다. 바로 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)이다. 둘 다 정확히 $O(|V| + |E|)$의  선형 시간 복잡도를 가진다. 깊이 우선 탐색에서 최악은 어떤 노드에서 시작해서 중복 없이 모든 노드를 전부 지나는 패스가 존재하고, 경로상의 모든 간선을 선택하게 되는 경우이다. 이때의 공간 복잡도는 $O(|V|)$가 된다. (여기서 공간 복잡도는 함수 호출 스택에 사용된 암묵적 존재다.) 최악의 경우에 너비 우선 탐색의 공간 복잡도 또한 $O(|V|)$가 된다. 왜냐하면 너비 우선 탐색에서 최악의 경우는 하나의 노드에서 모든 노드로의 연결이 존재할 때이고, 이러한 경우에 너비 우선 탐색 큐에 모든 노드를 삽입해야 하기 때문이다.

깊이 우선 탐색과 너비 우선 탐색은 추가로 알 수 있는 정보가 다르다. 예를 들어 너비 우선 탐색은 시작 지점에서의 거리를 계산할 때 쓰이지만, 깊이 우선 탐색은 사이클이 존재하는지 확인할 때 쓰인다. 깊이 우선 탐색의 핵심 개념에는 노드의 탐색 시간과 종료 시간 개념이 포함된다.

