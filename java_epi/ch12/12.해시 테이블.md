# 12장 해시 테이블

해시 테이블은 키를 저장하거나 해당 키와 관련된 값을 저장하는 데 사용되는 자료구조다. 삽입, 삭제, 조회가 평균 $O(1)$ 시간에 수행된다.

기본 개념은 키를 배열에 저장하는 것이다. 배열에 저장되는 위치(슬롯)는, 키를 '해시 코드(hash code)'한 결과에 따라 결정된다. 해시 코드란 키값에 해시 함수를 적용해서 계산된 정수값을 말한다. 해시 함수를 잘 고른다면, 객체를 배열에 균일하게 분배할 수 있다.

서로 다른 두 개의 키가 동일한 위치로 매핑되면 충돌이 발생한다고 한다. 충돌을 처리하는 일반적인 방법 중 하나는 각 배열의 인덱스에서 연결리스트를 통해 객체를 저장하는 것이다. 해시 함수가 객체를 충분히 균등하게 저장할 만큼 잘 동작하고 해시 코드를 계산하는 데 $O(1)$ 시간이 걸린다면, 조회(lookup), 삽입(insert), 삭제(delete) 연산을 하는 데 평균적으로 $O(1 + n/m)$ 시간이 걸린다. 여기서 n은 객체의 개수이고 m은 배열의 길이이다. n은 계속 커지는데, m이 그대로면 n/m의 값도 증가한다. 이때는 해시 테이블에 재해싱(rehashing)을 적용해야 한다. 더 많은 공간으로 이루어진 새로운 배열을 할당하고, 객체를 새로운 배열로 옮긴다. 재해싱은 $O(n+m)$ 시간이 걸리는 만큼 비용이 큰 연산이지만, 재해싱이 드물게 발생한다면(예를 들어 크기를 두 배로 늘릴 때마다), 분할 상환 비용(amortized cost)은 낮아진다.

해시 테이블은 정렬된 배열과 질적으로 다르다. 예를 들어 키가 순서대로 저장될 필요가 없으며, 랜덤화(특히, 해시 함수)가 중심 역할을 한다. 14장에서 다룰 이진 탐색 트리와 비교해 보면, (재해싱이 드물게 발생한다는 가정하에) 해시 테이블에서의 삽입과 삭제 연산이 훨씬 효율적이다. 해시 테이블에 단점이 있다면 좋은 해시 함수가 필요하다는 점인데 실무에서는 크게 문제가 되지 않는다. 이와 비슷하게 재해싱도 실시간 시스템(realtime system)이 아니라면 큰 문제가 되지 않고, 설사 실시간 시스템이더라도 다른 스레드를 사용해서 재해싱을 하면 된다.

해시 함수의 필수 요구사항 중 하나는 키값이 같으면 해시 코드도 같아야 한다는 점이다. 당연하지만 실수하기 쉬운 부분이다. 예를 들어 데이터 자체가 아닌 주소값을 이용해 해시 함수를 만든다든가 프로필 데이터를 포함해서 해시 함수를 만든다면 키값이 같더라도 해시 코드가 달라질 수 있다.

필수는 아니지만 좋은 해시 함수는 키를 가능한 한 널리 퍼뜨린다. 즉, 객체의 부분 집합에 대한 해시 코드가 배열 전체에 걸쳐 균등하게 분배되는 게 좋다. 또한 효율적으로 계산하는 해시 함수가 좋다.

쉽게 저지를 수 있는 실수는 해시 테이블에 있는 키값을 갱신할 때 발생한다. 잘못하면 해당 키가 해시 테이블에 있더라도 찾지 못할 수 있다. 키값을 갱신하고 싶으면 먼저 해당 키를 제거하고 갱신한 뒤, 해당 키값을 다시 해시 테이블에 추가해야 한다. 그래야 갱신된 키를 새로운 위치로 옮길 수 있다. 기본적으로 가변 객체(mutable object)를 키로 설정하면 안 된다.

이제 문자열에 적합한 해시 함수의 설계 방법에 대해 살펴보자. 먼저, 해시 함수는 문자열의 모든 문자를 사용해야 한다. 넓은 범위의 값을 생성해야 하고, 문자 하나가 해시 코드를 결정짓도록 해서는 안 된다. 예를 들어 문자를 숫자로 바꾼 뒤 이들을 모두 곱한 값을 해당 문자열의 해시 코드라고 해 보자. 0으로 매핑되는 문자가 하나라도 있다면, 해시 코드가 언제나 0이 된다. 또한, 롤링 해시(rolling hash), 즉 문자열 맨 앞의 문자를 삭제하고 맨 뒤에 문자를 추가하는 방식의 해시 함수는 새로운 해시 코드를 $O(1)$ 시간 내에 계산할 수 있다(문제 6.13의 해법). 다음 해시 함수는 이러한 롤링 해시의 속성을 가지고 있다.

```java
public static int stringHash(String str, int modulus) {
    int kMult = 997;
    int val = 0;
    for (int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        val = (val * kMult * c) % modulus;
    }
    return val;
}
```

해시 테이블은 사전, 즉 문자열 집합을 표현하기 좋은 자료구조이다. 트라이(trie)라는 트리 자료구조는 동적으로 변하는 문자열 집합을 저장할 때 유용한데, 애플리케이션이 트라이를 사용하면 계산이 효율적이다. 트라이는 이진 탐색 트리와 달리 노드에 키를 저장하지 않고 노드의 위치 자체가 키가 된다.

## 해시 테이블 부트 캠프

두 가지 예제를 통해 해시 테이블을 소개할 것이다. 하나는 애플리케이션에서 해시 테이블을 사용하여 알고리즘을 개선하는 경우고, 다른 하나는 클래스 설계에 관한 내용이다.

## 해시 테이블을 사용하는 애플리케이션

철자 바꾸는 놀이(anagram)는 일반적인 단어 퍼즐 중 하나이다. 단어 집합이 주어지면 철자의 순서를 바꿔서 새로운 단어 집합을 만드는 놀이이다. 예를 들어 "eleven plus two"의 철자를 바꾸면 "twelve plus one"이 된다. 스크래블이나 가로세로 퍼즐 맞추기를 좋아하는 사람이라면 주어진 문자 집합에서 바꾸어 볼 수 있는 모든 가능한 철자를 남들보다도 쉽게 찾을 수 있을 것이다.

단어 집합을 입력으로 받은 후 철자를 바꾸어 다른 단어가 될 수 있는 것들끼리 그룹으로 묶고, 그 그룹을 반환하는 프로그램을 작성해 보자. 각 그룹에는 적어도 두 단어 이상이 들어 있어야 한다.

예를 들어 입력이 "debitcard", "elvis", "silent", "badcredit", "lives", "freedom", "listen", "levis", "money"라면, 다음과 같은 세 개의 그룹이 나올 수 있다. (1) "debitcard", "badcredit", (2) "elvis", "lives", "levis", (3) "silent", "listen". ("money"는 철자를 바꾸어 만들 수 있는 다른 단어가 없으므로 어떤 그룹에도 속하지 않는다.)

먼저 두 개의 단어가 주어졌을 때, 한 단어의 철자를 바꾸어 다른 단어로 만들 수 있는지 확인하는 프로그램을 생각해 보자. 문자열에 등장하는 문자의 순서는 전혀 관계 없으므로, 각 문자열을 기준으로 정렬한 뒤에 둘을 비교해 볼 수 있다. 두 단어의 정렬 결과가 동일하다면, 이 둘은 철자를 재배치해서 서로를 만들 수 있다. 예를 들어 "logarithmatic"과 "algorithmic"을 정렬하면 둘 다 "acghiilmort"가 된다.

이중 루프를 사용해 모든 문자열의 쌍을 비교하는 식으로 그룹을 만들 수도 있다. 철자를 바꾸어 서로 다른 문자열을 만들 수 있다면, 두 번째 문자열은 다시 고려하지 않는다. 전체 문자열이 n개이고 최대 문자열의 길이가 m일 때 이 알고리즘의 시간 복잡도는 $O(n^2m \log m)$이 된다.

이 방법을 좀 더 자세히 살펴보자. 여기서 중요한 점은 어떤 문자열을 또 다른 대표 문자열로 매핑한다는 점이다. 즉, 임의의 문자열이 주어졌을 때, 이 문자열을 정렬한 문자열이 해당 그룹을 대표하는 고유한 식별자가 된다. 우리가 원하는 것은 정렬된 문자열과 이 문자열의 대표 문자열을 매핑시키는 것이다. 문자열 집합을 저장할 때는 해시 테이블을 사용하는 것이 좋다. 따라서 모든 문자열 s에 대해 sort(s)를 해시 테이블에 추가한다. 정렬된 문자열이 키값이 되고, 입력으로 주어진 문자열 리스트가 값이 된다.

```java
public static List<List<String>> findAnagrams(List<String> dictionary) {
    Map<String, List<String>> sortedStringToAnagrams = new HashMap<>();
    for (String s : dictionary) {
        // 문자열을 정렬한 뒤, 이 정렬된 문자열을 키값으로 사용한다.
        // 그 뒤에 기존 문자열을 해시 테이블의 값에 추가한다.
        char[] sortedCharArray = s.toCharArray();
        Arrays.sort(sortedCharArray);
        String sortedStr = new String(sortedCharArray);
        if (!sortedStringToAnagrams.containsKey(sortedStr)) {
            sortedStringToAnagrams.put(sortedStr, new ArrayList<String>());
        }
        sortedStringToAnagrams.get(sortedStr).add(s);
    }

    List<List<String>> anagramGroups = new ArrayList<>();
    for (Map.Entry<String, List<String>> p : sortedStringToAnagrams.entrySet()) {
        if (p.getValue().size() >= 2) { // 그룹을 찾았다.
            anagramGroups.add(p.getValue());
        }
    }
    return anagramGroups;
}
```

이 방법은 정렬 알고리즘을 n번 호출하고 해시 테이블에 n번 삽입한다. 모든 키를 정렬하려면 $O(nm \log m)$ 시간 복잡도가 필요하고, 삽입을 하는 데 $O(nm)$ 시간이 걸리므로, 전체 시간 복잡도는 $O(nm \log m)$이 된다.

## 해시 테이블 클래스 설계하기

핸드폰의 연락처를 표현하는 클래스를 생각해 보자. 문제를 간단히 하기 위해 각 연락처는 문자열 하나로만 이루어져 있고, 리스트에 들어 있다고 가정하자. 또한 같은 연락처가 중복되어 저장될 수 있다. 만약 두 연락처 클래스의 내부 리스트가 순서에 상관 없이 같은 문자열을 가지고 있다면 두 연락처 클래스는 동일하다고 볼 수 있다. 중복 여부는 중요하지 않다. 즉, 똑같은 연락처가 리스트에 세 번 중복해서 들어 있는 것과 해당 연락처가 리스트에 한 번 들어간 것은 모두 동일하게 다룬다. 연락처를 해시 테이블에 저장하기 위해서는 먼저 동등성(equality)을 정의해야 된다. 그래야 리스트의 집합을 표현할 수 있고, 집합끼리 비교를 할 수 있다.

이 경우에 해시 함수는 문자열의 순서가 아니라 문자열의 존재 유무에 따라 값으로 표현되어야 한다. 또한 동일한 연락처가 여러 개 존재하더라도 하나 있을 때와 결괏값이 동일해야 한다. 리스트를 집합으로 표현한 뒤, 집합에 대해서 해시 함수를 호출하면 가능하다. 집합에 대한 해시 함수 라이브러리는 순서에 독립적이고 집합에 대해선 자동으로 중복을 방지하므로, 우리가 원하는 해시 함수와 같다. 다음 코드에 나오는 해시 함수와 동등성 함수는 굉장히 비효율적이다. 실무에서는 집합과 해시 코드를 캐시에 저장하는 게 좋다. 단, 캐시를 사용할 때에는 갱신할 때마다 해당 값을 삭제해야 한다는 사실을 명심하라.

```java
public static List<ContactList> mergeContactLists(List<ContactList> contacts) {
    return new ArrayList<>(new HashSet(contracts));
}

public static class ContactList {
    public List<String> names;

    ContactList(List<String> names) { this.names = names; }

    @Override
    public boolean equals(Object obj) {
        if (obj == null || !(obj instanceof ContactList)) {
            return false;
        }
        return this == obj
            ? true
            : new HashSet(names).equals(new HashSet(((ContactList)obj).names));
    }

    @Override
    public int hashCode() {
        return new HashSet(names).hashCode();
    }
}
```

연락처 리스트에 n개의 문자열이 들어 있을 때 해시 값을 계산하려면 $O(n)$시간이 걸린다. 성능 향상을 위해 해시 코드를 캐시에 저장해도 된다. 단, 이때 해시 함수가 가리키는 객체가 갱신됐을 때 해당 캐시를 반드시 비워야 한다.

## 해시 테이블 문제를 풀기 전 꼭 알고 있어야 할 내용

- 해시 테이블은 `이론에서뿐 아니라 실무에서도` 탐색(lookup), 삽입(insert), 삭제(delete) 연산에 대해 최고의 성능을 나타낸다. 각 연산의 시간 복잡도는 $O(1)$이다. 삽입에 대한 $O(1)$ 시간 복잡도는 평균 시간 복잡도이다. 해시 테이블의 크기를 조정할 때 단일 삽입 연산은 $O(n)$ 시간이 걸릴 수 있다. [문제 12.2]
- 후보자를 걸러 내는 등의 상황에서 성능을 향상하고 싶다면 `해시 코드`를 사용해 볼 수 있다. [문제 12.12]
- 예를 들어 문자에서 값으로 혹은 문자에서 문자로의 매핑일 경우 if-then 코드를 나열해서 하나씩 매핑하기보단 룩업테이블을 미리 만들어 두는 게 좋다. [문제 6.9]
- 자신이 만든 자료형을 해시 테이블에 삽입할 때, `논리적 동등성`과 해시 함수가 사용하게 될 필드의 관계를 이해하고 있어야 한다. 특히, 해당 자료형의 동등성을 구현하고자 할 때는 반드시 올바른 해시 함수가 구현되어 있어야 한다. 그렇지 않으면 해당 객체를 해시 함수에 삽입할 때 논리적으로 동일한 두 객체가 다르게 구분될 수도 있다. 이러면 해당 객체가 해시 테이블에 들어 있더라도 탐색에 실패할 수 있다.
- 종종 하나의 키가 하나 이상의 값에 매핑되는 멀티맵(multimap)을 사용할 때가 있다. 만약 지금 사용하는 언어에서 멀티맵에 대한 표준 라이브러리를 제공하지 않는다면, 리스트를 사용해서 멀티맵을 구현해야 한다. 혹은 멀티맵 라이브러리를 제공하는 `외부 라이브러리`를 찾아야 한다.

## 해시 테이블 라이브러리 이해하기

HashSet과 HashMap은 자바에서 흔하게 사용하는 해시 테이블 기반 자료구조이다. HashMap은 키와 값의 쌍을 저장하는 데 반해 HashSet는 키만 저장한다는 점이 다르다. 이 둘 모두 LinkedList나 PriorityQueue와는 다르게, 중복된 키를 저장할 수 없다. 기술적으로 HashSet는 Set 인터페이스를 구현하였고, HashMap은 Map 인터페이스를 구현했다.

HashSet에서 가장 중요한 메서드는 Set에 정의되어 있는 add(144), remove("Cantor"), contains(24), iterator(), isEmpty(), size()가 있다. add(144)와 remove("Cantor") 모두 추가/삭제가 제대로 되었는지 확인할 수 있는 불값을 반환한다. null 또한 유효한 값이 될 수 있다는 사실을 명심하라.

- iterator()로 모든 키를 순회할 때, 키의 순서가 정해져 있지 않다. 심지어 시간에 따라 그 순서가 바뀔 수도 있다. LinkedHashSet 클래스는 HashSet의 하위 클래스지만, iterator()가 반환하는 키의 순서가 집합에 삽입된 순서와 같다는 점이 다르다. 이 순서는 s.contains(x)가 참일 때, s.add(x)를 다시 호출해서 원소를 재삽입하더라도 바뀌지 않는다.
- HashSet에는 교집합을 찾을 때 사용하는 retainAll(C) 메서드가 구현되어 있기 때문에 손으로 처음부터 구현할 필요가 없다. 이와 연관된 메서드로는 removeAll(C)가 있다.

HashMap에서 가장 중요한 메서드로는 Map에 정의되어 있는 put('z', 26), get("Hardy"), remove('z'), containsKey("Hardy")가 있다.

- entrySet(), keySet(), values()와 같이 반복자와 연관된 다양한 메서드가 존재한다. 정적 내부 클래스(static inner class) Map.Entry는 키와 값의 쌍을 순회하는 데 사용되곤 한다. 순회하는 순서가 정해져 있지는 않지만, 무엇을 기준으로 순회하든 그 순서는 동일하다.
- 정해진 순서대로 순회하고 싶을 때는 LinkedHashMap을 사용하면 된다. LinkedHashMap은 LinkedHashSet보다 조금 더 복잡하다. 예를 들어 삽입된 순서대로 순회가 진행되도록 할 수도 있고, 원소에 접근한 순서대로 (즉, get(42)를 호출하는 순간 해당 원소의 순서가 앞으로 당겨진다.) 순회를 진행할 수도 있다. LinkedHashMap에서는 공간의 크기를 한정시킬 수 있고, LRU를 통한 원소 삭제 정책을 적용할 수도 있다.

Objects 클래스는 몇 가지 정적 메서드를 제공하는데, 이들은 equals(obj)나 hashCode()를 작성해야 하는 부담을 상당히 줄여 준다. 예를 들어 Objects.equals(x, y), Objects.deepEquals(A, B), Objects.hash(42, "Douglas Adams", 3.14, new Date())와 같은 메서드들이 있다.

```text
보통 두 객체의 비교를 동일성(identity) 비교와 동등성(equality) 비교로 구분한다. 동일성 비교는 참조 주소를 비교하는 것으로 == 연산자를 사용하고, 동등성 비교는 두 객체가 같다고 논리적으로 인정할 수 있는, 예를 들면 id나 name 등을 비교하는 것으로 equals()를 사용한다.
```

## 문제 12.1 회문 순열 확인하기

회문이란 "level", "rotator", "foobaraboof"처럼 앞으로 읽을 때와 뒤로 읽을 때가 같은 문자열을 말한다.

문자열을 구성하는 문자를 재배치해서 회문을 만들 수 있는지 확인하는 프로그램을 작성하라. 예를 들어 "edified"는 "deified"로 재배치가 가능하다.

> 힌트: 문자열의 문자들을 간단하게 재배치해서 회문으로 만들 수 있는지 확인해 보자.

무식한 방법 중 하나는 문자열의 모든 순열을 구한 뒤에 각각이 회문인지 확인하는 것으로 시간 복잡도가 굉장히 높다. 그런데 이 방법을 좀 더 자세히 살펴보면 'a'로 시작하는 문자열이 회문이 되려면, 'a'로 끝나야 한다는 사실을 알 수 있다. 이 사실을 이용해 무식한 방법을 조금 개선해 보자. 어떤 문자열이 회문이 되려면 (길이가 홀수인 경우에 가운데 문자를 제외한) 모든 문자가 쌍을 이루어야 한다. 예를 들어 "edified"의 길이는 홀수(7)이고, 'e', 'd', 'i'가 두 개씩 있고, 'f'가 한 개 있다. 따라서 "edified"의 순열 중에 회문이 존재한다는 사실을 알 수 있다.

좀 더 수학적으로 말해 보자. 길이가 짝수인 문자열이 회문이 되기 위한 필요충분조건은 문자열을 구성하는 모든 문자의 개수가 짝수여야 한다는 것이다. 만약 문자열의 길이가 홀수라면, 문자 하나를 제외한 모든 문자의 개수가 짝수여야 한다. 따라서 두 경우 모두, 홀수 번 나타나는 문자가 1개인지 확인하면 된다. 이는 해시 테이블을 통해 문자와 해당 문자의 등장 횟수를 매핑하는 방법으로 확인할 수 있다.

```java
public static boolean canFormPalindrome(String s) {
    Set<Character> charsWithOddFrequency = new HashSet<>();
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (charsWithOddFrequency.contains(c)) {
            // c는 이제 짝수 번 나타났다.
            charsWithOddFrequency.remove(c);
        } else {
            // c는 이제 홀수 번 나타났다.
            charsWithOddFrequency.add(c);
        }
    }

    // 홀수 번 나타난 문자가 최대 1인 경우에만 문자열을 치환하여 회문을 만들 수 있다.
    return charsWithOddFrequency.size() <= 1;
}
```

문자열의 길이가 n일 때 시간 복잡도는 $O(n)$이 된다. 문자열을 구성하는 서로 다른 문자의 개수가 c일 떄 공간 복잡도는 $O(c)$가 된다.

## 문제 12.8 서로 다른 엔트리를 포함하는 가장 긴 부분배열 구하기

배열이 주어졌을 때, 중복된 원소가 없는 가장 긴 부분배열의 길이를 반환하는 프로그램을 작성하라. 예를 들어 <f,s,f,e,t,w,e,n,w,e>가 주어졌을 때, 중복되지 않은 가장 긴 부분배열은 <s,f,e,t,w>가 된다.

> 힌트: i에서 j까지의 부분배열은 이 조건을 만족하지만, i에서 j+1까지의 부분배열은 그렇지 않다면 어떻게 해야할까?

무식한 방법부터 생각해 보자. 해시 테이블을 이용해서 모든 부분배열에 중복된 원소가 존재하는지 확인하면 된다. 이 방법의 시간 복잡도는 배열의 길이가 n일 때 $O(n^3)$이 된다. 왜냐하면 부분 배열의 전체 개수는 $O(n^2)$이고, 이들의 평균 길이는 $O(n)$이기 때문이다.

이 방법을 개선해 보자. 어떤 부분 배열에 중복된 원소가 존재한다면, 해당 부분 배열을 포함하는 모든 배열은 중복된 원소를 가지고 있을 것이다. 따라서 주어진 시작 인덱스에 대해서 중복된 원소가 없는 가장 긴 부분배열은 $O(n)$ 시간에 구할 수 있다. 시작 지점에서 배열을 차례대로 훑으면서 이전에 등장하지 않았던 원소를 하나씩 해시 테이블에 추가해 보면 된다. 이 방법의 시간 복잡도는 $O(n^2)$이다. 중복된 원소를 발견하는 순간 시작 인덱스를 옮기면 된다.

이전 결과를 재사용하면 시간 복잡도를 더 개선할 수 있다. 예를 들어 어떤 인덱스로 끝나는 가장 긴 중복이 없는 부분배열을 알고 있다고 가정하자. 이때 그 다음 인덱스에서 끝나는 가장 긴 중복이 없는 부분배열은 다음 두 가지 경우 중 하나가 된다. 첫 번째는, 다음 인덱스의 원소가 현재 인덱스 기준으로 가장 긴 중복 없는 부분배열에 없는 원소라면, 단순히 이 부분배열 뒤에 다음 원소를 추가한다. 두 번째로 이미 부분배열에 존재한다면, 중복된 원소가 생기지 않도록 시작 인덱스를 앞으로 옮겨준다. 이 케이스 분석을 배열을 순회하는 동시에 수행하면 된다. 그러기 위해선 해시 테이블에 각 원소가 등장한 가장 최근의 인덱스와 현재 원소에서 끝나는 가장 긴 부분배열을 저장하면 된다.

<f,s,f,e,t,w,e,n,w,e>에서 두 번째 위치의 원소를 처리한다고 해 보자. 1번 인덱스에서 끝나고 중복이 없는 가장 긴 부분배열은  0에서 1까지의 부분배열이다. 해시 테이블에 2번 인덱스의 원소, 즉 f가 이미 존재하므로 2번 인덱스에서 끝나고 중복이 없는 가장 긴 부분배열은 1에서 2까지의 부분배열이다. 3에서 5 사이의 인덱스는 모두 처음 등장하는 원소이다. 6번 인덱스의 원소인 e는 5번 인덱스에서 끝나는 가장 긴 부분배열에 등장한다. 정확히 말하면 3번 인덱스에 등장한다. 따라서 6번 인덱스에서 끝나는 가장 긴 부분배열은 4번 인덱스에서 시작해야 한다.

```java
public static int longestSubarrayWithDistinctEntries(List<Integer> A) {
    // 각 원소가 등장한 가장 최근의 위치를 기록한다.
    Map<Integer, Integer> mostRecentOccurrence = new HashMap<>();
    int longestDupFreeSubarrayStartIdx = 0, result = 0;
    for (int i = 0; i < A.size(); i++) {
        Integer dupIdx = mostRecentOccurrence.put(A.get(i), i);
        // A.get(i)의 원소가 이전에 등장한 적이 있다.
        // 현재의 가장 긴 부분배열에도 해당 원소가 있는가?
        if (dupIdx != null) {
            if (dupIdx >= longestDupFreeSubarrayStartIdx) {
                result = Math.max(result, i - longestDupFreeSubarrayStartIdx);
                longestDupFreeSubarrayStartIdx = dupIdx + 1;
            }
        }
    }
    result = Math.max(result, A.size() - longestDupFreeSubarrayStartIdx);
    return result;
}
```

각 원소를 처리하는 데 상수 시간이 걸리기 때문에 전체 시간 복잡도는 $O(n)$이 된다.
