# 12장 해시 테이블

## 문제 12.8 서로 다른 엔트리를 포함하는 가장 긴 부분배열 구하기

배열이 주어졌을 때, 중복된 원소가 없는 가장 긴 부분배열의 길이를 반환하는 프로그램을 작성하라. 예를 들어 <f,s,f,e,t,w,e,n,w,e>가 주어졌을 때, 중복되지 않은 가장 긴 부분배열은 <s,f,e,t,w>가 된다.

> 힌트: i에서 j까지의 부분배열은 이 조건을 만족하지만, i에서 j+1까지의 부분배열은 그렇지 않다면 어떻게 해야할까?

무식한 방법부터 생각해 보자. 해시 테이블을 이용해서 모든 부분배열에 중복된 원소가 존재하는지 확인하면 된다. 이 방법의 시간 복잡도는 배열의 길이가 n일 때 $O(n^3)$이 된다. 왜냐하면 부분 배열의 전체 개수는 $O(n^2)$이고, 이들의 평균 길이는 $O(n)$이기 때문이다.

이 방법을 개선해 보자. 어떤 부분 배열에 중복된 원소가 존재한다면, 해당 부분 배열을 포함하는 모든 배열은 중복된 원소를 가지고 있을 것이다. 따라서 주어진 시작 인덱스에 대해서 중복된 원소가 없는 가장 긴 부분배열은 $O(n)$ 시간에 구할 수 있다. 시작 지점에서 배열을 차례대로 훑으면서 이전에 등장하지 않았던 원소를 하나씩 해시 테이블에 추가해 보면 된다. 이 방법의 시간 복잡도는 $O(n^2)$이다. 중복된 원소를 발견하는 순간 시작 인덱스를 옮기면 된다.

이전 결과를 재사용하면 시간 복잡도를 더 개선할 수 있다. 예를 들어 어떤 인덱스로 끝나는 가장 긴 중복이 없는 부분배열을 알고 있다고 가정하자. 이때 그 다음 인덱스에서 끝나는 가장 긴 중복이 없는 부분배열은 다음 두 가지 경우 중 하나가 된다. 첫 번째는, 다음 인덱스의 원소가 현재 인덱스 기준으로 가장 긴 중복 없는 부분배열에 없는 원소라면, 단순히 이 부분배열 뒤에 다음 원소를 추가한다. 두 번째로 이미 부분배열에 존재한다면, 중복된 원소가 생기지 않도록 시작 인덱스를 앞으로 옮겨준다. 이 케이스 분석을 배열을 순회하는 동시에 수행하면 된다. 그러기 위해선 해시 테이블에 각 원소가 등장한 가장 최근의 인덱스와 현재 원소에서 끝나는 가장 긴 부분배열을 저장하면 된다.

<f,s,f,e,t,w,e,n,w,e>에서 두 번째 위치의 원소를 처리한다고 해 보자. 1번 인덱스에서 끝나고 중복이 없는 가장 긴 부분배열은  0에서 1까지의 부분배열이다. 해시 테이블에 2번 인덱스의 원소, 즉 f가 이미 존재하므로 2번 인덱스에서 끝나고 중복이 없는 가장 긴 부분배열은 1에서 2까지의 부분배열이다. 3에서 5 사이의 인덱스는 모두 처음 등장하는 원소이다. 6번 인덱스의 원소인 e는 5번 인덱스에서 끝나는 가장 긴 부분배열에 등장한다. 정확히 말하면 3번 인덱스에 등장한다. 따라서 6번 인덱스에서 끝나는 가장 긴 부분배열은 4번 인덱스에서 시작해야 한다.

```java
public static int longestSubarrayWithDistinctEntries(List<Integer> A) {
    // 각 원소가 등장한 가장 최근의 위치를 기록한다.
    Map<Integer, Integer> mostRecentOccurrence = new HashMap<>();
    int longestDupFreeSubarrayStartIdx = 0, result = 0;
    for (int i = 0; i < A.size(); i++) {
        Integer dupIdx = mostRecentOccurrence.put(A.get(i), i);
        // A.get(i)의 원소가 이전에 등장한 적이 있다.
        // 현재의 가장 긴 부분배열에도 해당 원소가 있는가?
        if (dupIdx != null) {
            if (dupIdx >= longestDupFreeSubarrayStartIdx) {
                result = Math.max(result, i - longestDupFreeSubarrayStartIdx);
                longestDupFreeSubarrayStartIdx = dupIdx + 1;
            }
        }
    }
    result = Math.max(result, A.size() - longestDupFreeSubarrayStartIdx);
    return result;
}
```

각 원소를 처리하는 데 상수 시간이 걸리기 때문에 전체 시간 복잡도는 $O(n)$이 된다.
