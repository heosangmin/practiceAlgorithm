# 12장 해시 테이블

해시 테이블은 키를 저장하거나 해당 키와 관련된 값을 저장하는 데 사용되는 자료구조다. 삽입, 삭제, 조회가 평균 $O(1)$ 시간에 수행된다.

기본 개념은 키를 배열에 저장하는 것이다. 배열에 저장되는 위치(슬롯)는, 키를 '해시 코드(hash code)'한 결과에 따라 결정된다. 해시 코드란 키값에 해시 함수를 적용해서 계산된 정수값을 말한다. 해시 함수를 잘 고른다면, 객체를 배열에 균일하게 분배할 수 있다.

서로 다른 두 개의 키가 동일한 위치로 매핑되면 충돌이 발생한다고 한다. 충돌을 처리하는 일반적인 방법 중 하나는 각 배열의 인덱스에서 연결리스트를 통해 객체를 저장하는 것이다. 해시 함수가 객체를 충분히 균등하게 저장할 만큼 잘 동작하고 해시 코드를 계산하는 데 $O(1)$ 시간이 걸린다면, 조회(lookup), 삽입(insert), 삭제(delete) 연산을 하는 데 평균적으로 $O(1 + n/m)$ 시간이 걸린다. 여기서 n은 객체의 개수이고 m은 배열의 길이이다. n은 계속 커지는데, m이 그대로면 n/m의 값도 증가한다. 이때는 해시 테이블에 재해싱(rehashing)을 적용해야 한다. 더 많은 공간으로 이루어진 새로운 배열을 할당하고, 객체를 새로운 배열로 옮긴다. 재해싱은 $O(n+m)$ 시간이 걸리는 만큼 비용이 큰 연산이지만, 재해싱이 드물게 발생한다면(예를 들어 크기를 두 배로 늘릴 때마다), 분할 상환 비용(amortized cost)은 낮아진다.

해시 테이블은 정렬된 배열과 질적으로 다르다. 예를 들어 키가 순서대로 저장될 필요가 없으며, 랜덤화(특히, 해시 함수)가 중심 역할을 한다. 14장에서 다룰 이진 탐색 트리와 비교해 보면, (재해싱이 드물게 발생한다는 가정하에) 해시 테이블에서의 삽입과 삭제 연산이 훨씬 효율적이다. 해시 테이블에 단점이 있다면 좋은 해시 함수가 필요하다는 점인데 실무에서는 크게 문제가 되지 않는다. 이와 비슷하게 재해싱도 실시간 시스템(realtime system)이 아니라면 큰 문제가 되지 않고, 설사 실시간 시스템이더라도 다른 스레드를 사용해서 재해싱을 하면 된다.

해시 함수의 필수 요구사항 중 하나는 키값이 같으면 해시 코드도 같아야 한다는 점이다. 당연하지만 실수하기 쉬운 부분이다. 예를 들어 데이터 자체가 아닌 주소값을 이용해 해시 함수를 만든다든가 프로필 데이터를 포함해서 해시 함수를 만든다면 키값이 같더라도 해시 코드가 달라질 수 있다.

필수는 아니지만 좋은 해시 함수는 키를 가능한 한 널리 퍼뜨린다. 즉, 객체의 부분 집합에 대한 해시 코드가 배열 전체에 걸쳐 균등하게 분배되는 게 좋다. 또한 효율적으로 계산하는 해시 함수가 좋다.

쉽게 저지를 수 있는 실수는 해시 테이블에 있는 키값을 갱신할 때 발생한다. 잘못하면 해당 키가 해시 테이블에 있더라도 찾지 못할 수 있다. 키값을 갱신하고 싶으면 먼저 해당 키를 제거하고 갱신한 뒤, 해당 키값을 다시 해시 테이블에 추가해야 한다. 그래야 갱신된 키를 새로운 위치로 옮길 수 있다. 기본적으로 가변 객체(mutable object)를 키로 설정하면 안 된다.

이제 문자열에 적합한 해시 함수의 설계 방법에 대해 살펴보자. 먼저, 해시 함수는 문자열의 모든 문자를 사용해야 한다. 넓은 범위의 값을 생성해야 하고, 문자 하나가 해시 코드를 결정짓도록 해서는 안 된다. 예를 들어 문자를 숫자로 바꾼 뒤 이들을 모두 곱한 값을 해당 문자열의 해시 코드라고 해 보자. 0으로 매핑되는 문자가 하나라도 있다면, 해시 코드가 언제나 0이 된다. 또한, 롤링 해시(rolling hash), 즉 문자열 맨 앞의 문자를 삭제하고 맨 뒤에 문자를 추가하는 방식의 해시 함수는 새로운 해시 코드를 $O(1)$ 시간 내에 계산할 수 있다(문제 6.13의 해법). 다음 해시 함수는 이러한 롤링 해시의 속성을 가지고 있다.

```java
public static int stringHash(String str, int modulus) {
    int kMult = 997;
    int val = 0;
    for (int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        val = (val * kMult * c) % modulus;
    }
    return val;
}
```

해시 테이블은 사전, 즉 문자열 집합을 표현하기 좋은 자료구조이다. 트라이(trie)라는 트리 자료구조는 동적으로 변하는 문자열 집합을 저장할 때 유용한데, 애플리케이션이 트라이를 사용하면 계산이 효율적이다. 트라이는 이진 탐색 트리와 달리 노드에 키를 저장하지 않고 노드의 위치 자체가 키가 된다.

## 해시 테이블 부트 캠프

두 가지 예제를 통해 해시 테이블을 소개할 것이다. 하나는 애플리케이션에서 해시 테이블을 사용하여 알고리즘을 개선하는 경우고, 다른 하나는 클래스 설계에 관한 내용이다.

## 해시 테이블을 사용하는 애플리케이션

철자 바꾸는 놀이(anagram)는 일반적인 단어 퍼즐 중 하나이다. 단어 집합이 주어지면 철자의 순서를 바꿔서 새로운 단어 집합을 만드는 놀이이다. 예를 들어 "eleven plus two"의 철자를 바꾸면 "twelve plus one"이 된다. 스크래블이나 가로세로 퍼즐 맞추기를 좋아하는 사람이라면 주어진 문자 집합에서 바꾸어 볼 수 있는 모든 가능한 철자를 남들보다도 쉽게 찾을 수 있을 것이다.

단어 집합을 입력으로 받은 후 철자를 바꾸어 다른 단어가 될 수 있는 것들끼리 그룹으로 묶고, 그 그룹을 반환하는 프로그램을 작성해 보자. 각 그룹에는 적어도 두 단어 이상이 들어 있어야 한다.

예를 들어 입력이 "debitcard", "elvis", "silent", "badcredit", "lives", "freedom", "listen", "levis", "money"라면, 다음과 같은 세 개의 그룹이 나올 수 있다. (1) "debitcard", "badcredit", (2) "elvis", "lives", "levis", (3) "silent", "listen". ("money"는 철자를 바꾸어 만들 수 있는 다른 단어가 없으므로 어떤 그룹에도 속하지 않는다.)

먼저 두 개의 단어가 주어졌을 때, 한 단어의 철자를 바꾸어 다른 단어로 만들 수 있는지 확인하는 프로그램을 생각해 보자. 문자열에 등장하는 문자의 순서는 전혀 관계 없으므로, 각 문자열을 기준으로 정렬한 뒤에 둘을 비교해 볼 수 있다. 두 단어의 정렬 결과가 동일하다면, 이 둘은 철자를 재배치해서 서로를 만들 수 있다. 예를 들어 "logarithmatic"과 "algorithmic"을 정렬하면 둘 다 "acghiilmort"가 된다.

이중 루프를 사용해 모든 문자열의 쌍을 비교하는 식으로 그룹을 만들 수도 있다. 철자를 바꾸어 서로 다른 문자열을 만들 수 있다면, 두 번째 문자열은 다시 고려하지 않는다. 전체 문자열이 n개이고 최대 문자열의 길이가 m일 때 이 알고리즘의 시간 복잡도는 $O(n^2m \log m)$이 된다.

이 방법을 좀 더 자세히 살펴보자. 여기서 중요한 점은 어떤 문자열을 또 다른 대표 문자열로 매핑한다는 점이다. 즉, 임의의 문자열이 주어졌을 때, 이 문자열을 정렬한 문자열이 해당 그룹을 대표하는 고유한 식별자가 된다. 우리가 원하는 것은 정렬된 문자열과 이 문자열의 대표 문자열을 매핑시키는 것이다. 문자열 집합을 저장할 때는 해시 테이블을 사용하는 것이 좋다. 따라서 모든 문자열 s에 대해 sort(s)를 해시 테이블에 추가한다. 정렬된 문자열이 키값이 되고, 입력으로 주어진 문자열 리스트가 값이 된다.

```java
public static List<List<String>> findAnagrams(List<String> dictionary) {
    Map<String, List<String>> sortedStringToAnagrams = new HashMap<>();
    for (String s : dictionary) {
        // 문자열을 정렬한 뒤, 이 정렬된 문자열을 키값으로 사용한다.
        // 그 뒤에 기존 문자열을 해시 테이블의 값에 추가한다.
        char[] sortedCharArray = s.toCharArray();
        Arrays.sort(sortedCharArray);
        String sortedStr = new String(sortedCharArray);
        if (!sortedStringToAnagrams.containsKey(sortedStr)) {
            sortedStringToAnagrams.put(sortedStr, new ArrayList<String>());
        }
        sortedStringToAnagrams.get(sortedStr).add(s);
    }

    List<List<String>> anagramGroups = new ArrayList<>();
    for (Map.Entry<String, List<String>> p : sortedStringToAnagrams.entrySet()) {
        if (p.getValue().size() >= 2) { // 그룹을 찾았다.
            anagramGroups.add(p.getValue());
        }
    }
    return anagramGroups;
}
```

이 방법은 정렬 알고리즘을 n번 호출하고 해시 테이블에 n번 삽입한다. 모든 키를 정렬하려면 $O(nm \log m)$ 시간 복잡도가 필요하고, 삽입을 하는 데 $O(nm)$ 시간이 걸리므로, 전체 시간 복잡도는 $O(nm \log m)$이 된다.

## 문제 12.8 서로 다른 엔트리를 포함하는 가장 긴 부분배열 구하기

배열이 주어졌을 때, 중복된 원소가 없는 가장 긴 부분배열의 길이를 반환하는 프로그램을 작성하라. 예를 들어 <f,s,f,e,t,w,e,n,w,e>가 주어졌을 때, 중복되지 않은 가장 긴 부분배열은 <s,f,e,t,w>가 된다.

> 힌트: i에서 j까지의 부분배열은 이 조건을 만족하지만, i에서 j+1까지의 부분배열은 그렇지 않다면 어떻게 해야할까?

무식한 방법부터 생각해 보자. 해시 테이블을 이용해서 모든 부분배열에 중복된 원소가 존재하는지 확인하면 된다. 이 방법의 시간 복잡도는 배열의 길이가 n일 때 $O(n^3)$이 된다. 왜냐하면 부분 배열의 전체 개수는 $O(n^2)$이고, 이들의 평균 길이는 $O(n)$이기 때문이다.

이 방법을 개선해 보자. 어떤 부분 배열에 중복된 원소가 존재한다면, 해당 부분 배열을 포함하는 모든 배열은 중복된 원소를 가지고 있을 것이다. 따라서 주어진 시작 인덱스에 대해서 중복된 원소가 없는 가장 긴 부분배열은 $O(n)$ 시간에 구할 수 있다. 시작 지점에서 배열을 차례대로 훑으면서 이전에 등장하지 않았던 원소를 하나씩 해시 테이블에 추가해 보면 된다. 이 방법의 시간 복잡도는 $O(n^2)$이다. 중복된 원소를 발견하는 순간 시작 인덱스를 옮기면 된다.

이전 결과를 재사용하면 시간 복잡도를 더 개선할 수 있다. 예를 들어 어떤 인덱스로 끝나는 가장 긴 중복이 없는 부분배열을 알고 있다고 가정하자. 이때 그 다음 인덱스에서 끝나는 가장 긴 중복이 없는 부분배열은 다음 두 가지 경우 중 하나가 된다. 첫 번째는, 다음 인덱스의 원소가 현재 인덱스 기준으로 가장 긴 중복 없는 부분배열에 없는 원소라면, 단순히 이 부분배열 뒤에 다음 원소를 추가한다. 두 번째로 이미 부분배열에 존재한다면, 중복된 원소가 생기지 않도록 시작 인덱스를 앞으로 옮겨준다. 이 케이스 분석을 배열을 순회하는 동시에 수행하면 된다. 그러기 위해선 해시 테이블에 각 원소가 등장한 가장 최근의 인덱스와 현재 원소에서 끝나는 가장 긴 부분배열을 저장하면 된다.

<f,s,f,e,t,w,e,n,w,e>에서 두 번째 위치의 원소를 처리한다고 해 보자. 1번 인덱스에서 끝나고 중복이 없는 가장 긴 부분배열은  0에서 1까지의 부분배열이다. 해시 테이블에 2번 인덱스의 원소, 즉 f가 이미 존재하므로 2번 인덱스에서 끝나고 중복이 없는 가장 긴 부분배열은 1에서 2까지의 부분배열이다. 3에서 5 사이의 인덱스는 모두 처음 등장하는 원소이다. 6번 인덱스의 원소인 e는 5번 인덱스에서 끝나는 가장 긴 부분배열에 등장한다. 정확히 말하면 3번 인덱스에 등장한다. 따라서 6번 인덱스에서 끝나는 가장 긴 부분배열은 4번 인덱스에서 시작해야 한다.

```java
public static int longestSubarrayWithDistinctEntries(List<Integer> A) {
    // 각 원소가 등장한 가장 최근의 위치를 기록한다.
    Map<Integer, Integer> mostRecentOccurrence = new HashMap<>();
    int longestDupFreeSubarrayStartIdx = 0, result = 0;
    for (int i = 0; i < A.size(); i++) {
        Integer dupIdx = mostRecentOccurrence.put(A.get(i), i);
        // A.get(i)의 원소가 이전에 등장한 적이 있다.
        // 현재의 가장 긴 부분배열에도 해당 원소가 있는가?
        if (dupIdx != null) {
            if (dupIdx >= longestDupFreeSubarrayStartIdx) {
                result = Math.max(result, i - longestDupFreeSubarrayStartIdx);
                longestDupFreeSubarrayStartIdx = dupIdx + 1;
            }
        }
    }
    result = Math.max(result, A.size() - longestDupFreeSubarrayStartIdx);
    return result;
}
```

각 원소를 처리하는 데 상수 시간이 걸리기 때문에 전체 시간 복잡도는 $O(n)$이 된다.
