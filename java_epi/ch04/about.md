# 4. 기본 자료형

## 기본 자료형 문제를 풀기 전 꼭 알고 있어야 할 내용
- **비트 연산**, 특히 XOR을 잘 다뤄야 한다.[문제 4.2]
- **히드웨어와 무관**하게 **마스크**를 어떻게 사용하고 만들 수 있는지 알고 있어야 한다.[문제 4.6]
- **1로 세팅된 하위 비트의 값을 최적의 방법으로 지울 수 있어야 한다.** 또한 0으로 세팅된 하위 비트를 1로 세팅하거나, 해당 비트의 인덱스를 구하는 방법 등을 알고 있어야 한다.[문제 4.1]
- **부호**가 있는지 여부 그리고 부호가 있을 때의 **시프트** 연산에 대해 이해하고 있어야 한다.[문제 4.5]
- 입력이 작은 경우 연산 결과를 **캐시**에 저장함으로써 전체 연산을 빠르게 할 수 있어야 한다.[문제 4.3]
- **교환법칙**과 **결합법칙**에 대해 잘 알고 있어야 **병렬** 연산을 수행하거나 연산 **순서**를 바꿀 수 있다.[문제 4.1]

## 기본 자료형 이해하기
기본 자료형의 크기, 구간, 부호 여부, 연산자에 대해 익숙해져 있어야 한다. 또한 Math에서 기본 자로형을 이용한 메서드들의 사용법에 대해서도 알고 있어야 한다. 박스 타입(Integer, Double 등)과 기본 자료형의 차이점, 그리고 자동 박싱(auto boxing)의 기능과 한계에 대해서도 이해하고 있어야 한다. 특히 테스트 코드를 작성할 때 Random 라이브러리는 굉장히 유용하다.

- 6&4, 1|2, 8>>1, -16>>2, 1<<10, ~0, 15^x와 같은 비트 연산을 잘 다루라.
- Integer.MIN_VALUE, Float.MAX_VALUE, Double.SIZE, Boolean.TRUE와 같은 숫자 타입의 최댓값과 최솟값을 어떻게 사용하는지 알아야 한다.
- Double.valueOf("1.23"), Boolean.valueOf(true), Integer.parseInt("42"), Float.toString(-1.23)과 같은 박스 타입의 인스턴스를 만드는 방법에 대해 알고 있어야 한다.
- 값을 비교할 때 x == 1.23보다는 Double.compare(x, 1.23) == 0과 같이 비교 연산을 제공하는 박스 타입의 정적 메서드를 사용한다. 이러한 메서드들은 부동 소수점의 양수 무한대, 음수 무한대, NaN에 대해 보다 탄력적으로 동작한다.
- Math의 핵심 메서드에는 abs(-34.5), ceil(2.17), floor(3.14), min(x, -4), max(3.14, y), pow(2.71, 3.14), sqrt(225) 등이 있다.
- Character[] C = new char[]{'a','b'};가 왜 컴파일이 안 되는지 이해하고, 자동 박싱의 한계에 대해 알아야 한다.
- 정수, 문자, 그리고 문자열 간의 변환 방법을 알아두자. 예를 들어 Character.getNumericValue(x)(혹은 x - '0')은 문자로 나타낸 숫자를 실제 숫자로 바꾸고, String.valueOf(123)는 숫자를 문자열로 바꾼다.
- Random의 핵심 메서드에는 nextInt(16), nextInt(), nextBoolean(), nextDouble() 등이 있다. nextDouble()은 [0, 1) 사이의 값을 반환한다.

## 문제 4.1 패리티 계산하기
2진수의 패리티(parity)는 1로 세팅된 비트의 개수와 같다.(역주: 전체 비트의 개수를 2로 나눈 나머지 값과 같다.) 즉, 1이 홀수 개이면 1, 짝수 개이면 0이 된다. 예를 들어 1011의 패리티는 1이 되고, 10001000의 패리티는 0이 된다. 64비트로 이루어진 숫자가 굉장히 많다면, 패리티를 어떻게 계산해야 할까?

[Parity.java](Parity.java)

## 문제 4.2 비트 스왑
프로그램의 속도를 향상시킬 수 있는 다양한 비트 조작(bit manipulation) 방법들이 있다. 예를 들어 문제 4.1에서 설명한 x & (x - 1)은 x에서 1로 세팅된 최하위 비트를 제거한 결과와 같고, x & ~(x - 1)은 1로 세팅된 최하위 비트만을 뽑아낸 결과와 같다.

64비트 정수가 주어졌을 때 i번째 비트와 j번째 비트를 스왑하는 코드를 작성하라.

[BitSwap.java](BitSwap.java)

## 문제 4.3 비트 뒤집기
64비트 숫자가 주어졌을 때 이를 역순으로 재구성한 숫자를 반환하는 코드를 작성하라.

> 힌트: 룩업테이블을 사용하자.

 ## 문제 4.4 같은 무게를 가진 가장 가까운 정수 찾기
 음이 아닌 어떤 정수 x의 무게는 이 정수를 2진수로 표현했을 때 1로 세팅된 비트의 개수라고 정의해 보자. 예를 들어, 92의 2진수는 (1011100)2이 되므로 92의 무게는 4가 된다.

 음이 아닌 정수 x가 주어졌을 때, x와 무게는 같지만 x와의 차이, 즉 |y-x|가 최소가 되는 y를 반환하는 프로그램을 작성하라. 단 x의 모든 비트가 0 혹은 1인 경우는 고려하지 않아도 된다. 예를 들어 x = 6일 때 5를 반환하면 된다.

 [ClosestIntSameBitCount.java](ClosestIntSameBitCount.java)
 