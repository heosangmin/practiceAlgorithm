# 8장 스택과 큐

## 스택
> 스택에는 push와 pop이라는 두 가지 간단한 연산자가 존재한다. 스택이 비어 있을 때 pop을 수행하면 null을 반환하거나 예외를 던진다.

연결 리스트를 사용해서 O(1) 시간 복잡도로 스택을 구현할 수 있다. 만약 배열로 구현한다 해도 push와 pop 연산의 시간 복잡도는 여전히 O(1)이지만, 최대로 담을 수 있는 원소의 개수는 정해져 있다. 배열의 크기를 동적으로 변경할 수 있다면 push와 pop 연산의 분할 상환 시간은 O(1)이 된다. 스택은 원소를 제거하지 않고 그 값만 반환하는 peek이라는 연산을 추가로 제공하기도 한다.

## 스택 부트캠프
스택의 후입선출법을 사용하면 어떤 원소에서 뒤로 움직이는 것이 어렵거나 불가능한 상황일 때 손쉽게 해당 수열을 역순으로 순회할 수 있다. 다음은 스택을 사용해서 연결리스트를 역순으로 출력하는 프로그램이다.
```java
public static void printLinkedListReverse(ListNode<Integer> head) {
    Deque<Integer> nodes = new LinkedList<>();
    while (head != null) {
        nodes.addFirst(head.data);
        head = head.next;
    }
    while (!nodes.isEmpty()) {
        System.out.println(nodes.poll());
    }
}
```
리스트의 노드가 n개일 때 시간 및 공간 복잡도는 O(n)이 된다.

문제 7.2의 해법을 사용해서 리스트를 뒤집은 뒤 원소를 역순으로 출력하고 다시 뒤집어서 원래대로 돌려놓는 방법을 쓸 수도 있다. 이 방법의 시간 복잡도는 O(n)이고 공간 복잡도는 O(1)이다.

## 스택 문제를 풀기 전 꼭 알고 있어야 할 내용
- 스택의 `LIFO` 특성을 `언제 사용할 수 있을지` 알고 있어야 한다. 예를 들어 `파싱(parsing)`을 할 때는 보통 스택을 사용한다.(문제 8.2, 8.5)
- 기본적인 스택 혹은 큐 자료구조를 `활용해서` 만들 수 있는 또 다른 연산을 생각해 보자. 예를 들어 최대 원소를 찾을 수도 있다.(문제 8.1)

## 스택 라이브러리 이해하기
Java에서 스택을 표현하는 좋은 방법은 Deque 인터페이스를 사용하는 것이다. ArrayDeque 클래스는 이 인터페이스를 구현한 가변 배열이며, O(1)의 분할 상환 시간으로 스택과 큐 기능을 제공한다.

Deque 인터페이스에서 스택과 관련된 핵심 메서드는 push(42), peek(), pop()이다. Deque 메서드인 addFirst(42), peekFirst(), removeFirst()는 push(42), peek(), pop()과 동일하다. 이 책의 해법에서는 push(42), peek(), pop()과 같은 메서드를 사용할 것이다.

- push(e)는 원소를 스택에 집어넣는 연산이다. push 호출이 잘못될 일은 별로 없다. 구현에 따라 용량의 한계를 넘어가면 IllegalStateException 예외를 던지거나, null을 삽입했을 때 NullPointerException 예외를 던질 수 있다. 연결리스트는 용량에 한계도 없고 null도 삽입할 수 있다. 하지만 null을 삽입할 때는 매우 조심해야 한다.
- peek()은 원소를 삭제하지 않고 스택의 위에 있는 원소를 반환하는 연산이다. 스택이 비어 있을 경우에는 null을 반환한다. 하지만 null이 유효한 원소일 수도 있기 때문에 모호한 경우가 생긴다. 따라서 isEmpty()를 사용해서 스택이 비어 있는지 확인하는 것이 좋다.
- pop()은 스택에서 원소를 삭제하고 그 원소를 반환하는 연산이다. 만약 덱이 비어 있다면 NoSuchElementException를 반환한다. 예외상황을 피하려면 isEmpty()로 스택이 비어 있는지 항상 확인하는 것이 좋다.

스택과 관련된 다른 유용한 메서드로는 descendingIterator()와 iterator()가 있다.

