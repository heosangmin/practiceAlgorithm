# 8장 스택과 큐

## 스택
> 스택에는 push와 pop이라는 두 가지 간단한 연산자가 존재한다. 스택이 비어 있을 때 pop을 수행하면 null을 반환하거나 예외를 던진다.

연결 리스트를 사용해서 O(1) 시간 복잡도로 스택을 구현할 수 있다. 만약 배열로 구현한다 해도 push와 pop 연산의 시간 복잡도는 여전히 O(1)이지만, 최대로 담을 수 있는 원소의 개수는 정해져 있다. 배열의 크기를 동적으로 변경할 수 있다면 push와 pop 연산의 분할 상환 시간은 O(1)이 된다. 스택은 원소를 제거하지 않고 그 값만 반환하는 peek이라는 연산을 추가로 제공하기도 한다.

## 스택 부트캠프
스택의 후입선출법을 사용하면 어떤 원소에서 뒤로 움직이는 것이 어렵거나 불가능한 상황일 때 손쉽게 해당 수열을 역순으로 순회할 수 있다. 다음은 스택을 사용해서 연결리스트를 역순으로 출력하는 프로그램이다.
```java
public static void printLinkedListReverse(ListNode<Integer> head) {
    Deque<Integer> nodes = new LinkedList<>();
    while (head != null) {
        nodes.addFirst(head.data);
        head = head.next;
    }
    while (!nodes.isEmpty()) {
        System.out.println(nodes.poll());
    }
}
```
리스트의 노드가 n개일 때 시간 및 공간 복잡도는 O(n)이 된다.

문제 7.2의 해법을 사용해서 리스트를 뒤집은 뒤 원소를 역순으로 출력하고 다시 뒤집어서 원래대로 돌려놓는 방법을 쓸 수도 있다. 이 방법의 시간 복잡도는 O(n)이고 공간 복잡도는 O(1)이다.

## 스택 문제를 풀기 전 꼭 알고 있어야 할 내용
- 스택의 `LIFO` 특성을 `언제 사용할 수 있을지` 알고 있어야 한다. 예를 들어 `파싱(parsing)`을 할 때는 보통 스택을 사용한다.(문제 8.2, 8.5)
- 기본적인 스택 혹은 큐 자료구조를 `활용해서` 만들 수 있는 또 다른 연산을 생각해 보자. 예를 들어 최대 원소를 찾을 수도 있다.(문제 8.1)

## 스택 라이브러리 이해하기
Java에서 스택을 표현하는 좋은 방법은 Deque 인터페이스를 사용하는 것이다. ArrayDeque 클래스는 이 인터페이스를 구현한 가변 배열이며, O(1)의 분할 상환 시간으로 스택과 큐 기능을 제공한다.

Deque 인터페이스에서 스택과 관련된 핵심 메서드는 push(42), peek(), pop()이다. Deque 메서드인 addFirst(42), peekFirst(), removeFirst()는 push(42), peek(), pop()과 동일하다. 이 책의 해법에서는 push(42), peek(), pop()과 같은 메서드를 사용할 것이다.

- push(e)는 원소를 스택에 집어넣는 연산이다. push 호출이 잘못될 일은 별로 없다. 구현에 따라 용량의 한계를 넘어가면 IllegalStateException 예외를 던지거나, null을 삽입했을 때 NullPointerException 예외를 던질 수 있다. 연결리스트는 용량에 한계도 없고 null도 삽입할 수 있다. 하지만 null을 삽입할 때는 매우 조심해야 한다.
- peek()은 원소를 삭제하지 않고 스택의 위에 있는 원소를 반환하는 연산이다. 스택이 비어 있을 경우에는 null을 반환한다. 하지만 null이 유효한 원소일 수도 있기 때문에 모호한 경우가 생긴다. 따라서 isEmpty()를 사용해서 스택이 비어 있는지 확인하는 것이 좋다.
- pop()은 스택에서 원소를 삭제하고 그 원소를 반환하는 연산이다. 만약 덱이 비어 있다면 NoSuchElementException를 반환한다. 예외상황을 피하려면 isEmpty()로 스택이 비어 있는지 항상 확인하는 것이 좋다.

스택과 관련된 다른 유용한 메서드로는 descendingIterator()와 iterator()가 있다.

## 문제 8.1 최댓값 찾는 API로 스택 구현하기
push와 pop 외에 max 연산을 제공하는 스택 클래스를 설계하라. max() 메서드는 스택에 저장된 원소 중에서 가장 값이 큰 원소를 반환한다.

> 힌트: 최댓값을 기억하기 위해 공간을 추가로 사용해보자.

가장 간단한 방법부터 살펴보자. 스택을 배열로 구현했다면, 배열을 순회하면서 가장 값이 큰 원소를 찾으면 된다. 현재 스택의 원소가 n개일 때 이 방법의 시간 복잡도는 O(n)이고 공간 복잡도는 O(1)이다.

힙, BST, 해시 테이블과 같은 추가 자료구조를 사용하면 시간 복잡도를 O(log n)으로 줄일 수 있다. 하지만 공간 복잡도는 O(n)으로 늘어나고 코드도 꽤 복잡해진다.

스택의 최댓값을 기록하기 위해 추가로 M이라는 변수 하나를 사용한다고 생각해 보자. 원소를 삽입할 때 M을 갱신하는 건 쉽다. e가 새로 추가된 원소라고 했을 때 M = max(M,e)가 된다. 하지만 pop 연산을 할 때 M을 갱신하려면 경우에 따라 다시 남아 있는 원소를 모두 순회해야 하므로 시간이 꽤 걸린다.

공간을 조금 더 사용하면 시간 복잡도를 극적으로 개선할 수 있다. 스택의 모든 원소에 대해서 현재 원소 아래에 있는 원소들 중에서 최댓값이 무엇인지 캐싱을 하면 된다. 단, pop 연산을 수행할 때 해당 캐시값도 함께 제거해야 한다.

```java
private static class ElementWithCacheMax {
    public Integer element;
    public Integer max;

    public ElementWithCacheMax(Integer element, Integer max) {
        this.element = element;
        this.max = max;
    }
}

public static class Stack {
    // (원소, 최댓값) 쌍을 저장한다.
    private Deque<ElementWithCacheMax> elementWithCachedMax = new LinkedList<>();

    public boolean empty() {return elementWithCacheMax.isEmpty();}

    public Integer max() {
        if (empty()) {
            throw new IllegalStateException("max(): empty stack");
        }
        return elementWithCacheMax.peek().max;
    }

    public Integer pop() {
        if (empty()) {
            throw new IllegalStateException("pop(): empty stack");
        }
        return elementWithCacheMax.removeFirst().element;
    }

    public void push(Integer x) {
        elementWithCacheMax.addFirst(
            new ElementWithCacheMax(x, Math.max(x, empty() ? x : max()))
        );
    }
}
```

각 메서드의 시간 복잡도는 O(1)이다. 저장된 키에 관계없이 추가 공간 복잡도는 O(n)이 된다.

입력에 따라 필요한 공간을 줄일 수 있다. 만약 새로 추가되는 원소 e가 기존의 최댓값보다 작다면 e는 절대 최댓값이 될 수 없으므로 캐시에 기록할 필요가 없다. 최댓값을 계속 기록하다 보면 중복이 발생하므로 각 최댓값이 몇 번 등장했는지 기록해 중복을 제거한다.

```java
private static class MaxWithCount {
    public Integer max;
    public Integer count;

    public MaxWithCount(Integer max, Integer count) {
        this.max = max;
        this.count = count;
    }
}

public static class Stack {
    private Deque<Integer> element = new LinkedList<>();
    private Deque<MaxWithCount> cachedMaxWithCount = new LinkedList<>();

    public boolean empty() {return element.isEmpty();}

    public Integer max() {
        if (empty()) {
            throw new IllegalStateException("max(): empty stack");
        }
        return cachedMaxWithCount.peekFirst().max;
    }

    public Integer pop() {
        if (empty()) {
            throw new IllegalStateException("pop(): empty stack");
        }
        Integer popElement = element.removeFirst();
        if (popElement.equals(cachedMaxWithCount.peekFirst().max)) {
            cachedMaxWithCount.peekFirst().count = cachedMaxWithCount.peekFirst().count - 1;
            if (cachedMaxWithCount.peekFirst().count.equals(0)) {
                cachedMaxWithCount.removeFirst();
            }
        }
        return popElement;
    }

    public void push(Integer x) {
        element.addFirst(x);
        if (!cachedMaxWithCount.isEmpty()) {
            if (Integer.compare(x, cachedMaxWithCount.peekFirst().max) == 0) {
                cachedMaxWithCount.peekFirst().count += 1;
            } else if (Integer.compare(x, cachedMaxWithCount.peekFirst().max) > 0) {
                cachedMaxWithCount.addFirst(new MaxWithCount(x, 1));
            }
        } else {
            cachedMaxWithCount.addFirst(new MaxWithCount(x, 1));
        }
    }
}
```

최악의 경우(추가되는 키값이 항상 이전보다 큰 경우)의 공간 복잡도는 O(n)이다. 하지만 키값에 중복이 많고 최댓값이 자주 바뀌지 않는다면 추가로 필요한 공간 복잡도는 작을 것이다. 최고의 경우에는 O(1)이 된다. 각 메서드의 시간 복잡도는 여전히 O(1)이다.

## 문제 8.2 RPN 수식 계산하기
다음 조건을 만족하는 문자열은 RPN(Reverse Polish notation, 역 폴란드 표기법)을 따르는 산술 표현식이라 한다.

1. 길이가 1 이상인 숫자로 이루어진 문자열. '-'로 시작하는 경우도 있다. 예를 들어 "6", "123", "-42"가 있다.
2. A와 B가 RPN 수식을 만족하고 ○가 +, -, x, / 중 하나일 때 "A, B, ○"의 형태로 작성된 문자열이다.

RPN 수식을 계산하면 유일한 정수값이 나오는데, 이 값은 재귀적으로 구할 수 있다. 기저 사례(base case)는 1번 규칙, 즉 10진법으로 표기된 정수이다. 재귀 상태(recursive case)는 2번 규칙과 같고, RPN 수식을 자연스럽게 계산하면 된다. 즉, A가 2이고 B가 3일 때 "A, B, *"는 6과 같다.

RPN 수식이 주어졌을 때 이 수식의 계산 결과를 반환하는 프로그램을 작성하라.

> 힌트: 부분 수식을 계산한 뒤 그 값을 스택에 저장한다. 연산자는 어떻게 처리하면 될까?

RPN 예제로 먼저 시작해 보자. "3, 4, +, 2, *, 1, +"은 (3+4) * 2 + 1로 표현할 수 있다. 손으로 이 수식을 계산하려면 왼쪽에서 오른쪽으로 읽으면서 계산하면 된다. 3과 4를 기록한 뒤 +를 3과 4에 적용하고 그 결과를 7을 다시 기록한다. 이제 다시는 3과 4를 읽을 일이 없다. 그 다음에는 2를 곱한 결과인 14를 기록한다. 마지막으로 1을 더하면 최종 결과 15를 얻을 수 있다.

연산자를 만났을 때 중간 결과에 연산자를 적용해야 하므로 중간 결과를 기록해야 한다. 중간 결과는 후입선출법으로 추가되고 제거된다. 따라서 자연스럽게 스택을 사용해서 RPN 수식을 계산할 것이다.

```java
public static int eval(String RPNExpression) {
    Deque<Integer> intermediateResults = new LinkedList<>();
    String delimiter = ",";
    String[] symbols = RPNExpression.split(delimiter);
    for (String token : symbols) {
        if (token.length() == 1 && "+-*/".contains(token)) {
            final int y = intermediateResults.removeFirst();
            final int x = intermediateResults.removeFirst();
            switch (token.charAt(0)) {
                case '+':
                    intermediateResults.addFirst(x + y);
                    break;
                case '-':
                    intermediateResults.addFirst(x - y);
                    break;
                case '*':
                    intermediateResults.addFirst(x * y);
                    break;
                case '/':
                    intermediateResults.addFirst(x / y);
                    break;
                default:
                    throw new IllegalArgumentException("Malformed RPN at : " + token);
            }
        } else {
            // token이 숫자일 경우
            intermediateResults.addFirst(Integer.parseInt(token));
        }
    }
    return intermediateResults.removeFirst();
}
```

각 문자마다 O(1)의 연산을 수행하므로 문자열의 길이가 n일 때 시간 복잡도는 O(n)이 된다.

