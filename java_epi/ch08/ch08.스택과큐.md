# 8장 스택과 큐

## 스택
> 스택에는 push와 pop이라는 두 가지 간단한 연산자가 존재한다. 스택이 비어 있을 때 pop을 수행하면 null을 반환하거나 예외를 던진다.

연결 리스트를 사용해서 O(1) 시간 복잡도로 스택을 구현할 수 있다. 만약 배열로 구현한다 해도 push와 pop 연산의 시간 복잡도는 여전히 O(1)이지만, 최대로 담을 수 있는 원소의 개수는 정해져 있다. 배열의 크기를 동적으로 변경할 수 있다면 push와 pop 연산의 분할 상환 시간은 O(1)이 된다. 스택은 원소를 제거하지 않고 그 값만 반환하는 peek이라는 연산을 추가로 제공하기도 한다.

## 스택 부트캠프
스택의 후입선출법을 사용하면 어떤 원소에서 뒤로 움직이는 것이 어렵거나 불가능한 상황일 때 손쉽게 해당 수열을 역순으로 순회할 수 있다. 다음은 스택을 사용해서 연결리스트를 역순으로 출력하는 프로그램이다.
```java
public static void printLinkedListReverse(ListNode<Integer> head) {
    Deque<Integer> nodes = new LinkedList<>();
    while (head != null) {
        nodes.addFirst(head.data);
        head = head.next;
    }
    while (!nodes.isEmpty()) {
        System.out.println(nodes.poll());
    }
}
```
리스트의 노드가 n개일 때 시간 및 공간 복잡도는 O(n)이 된다.

문제 7.2의 해법을 사용해서 리스트를 뒤집은 뒤 원소를 역순으로 출력하고 다시 뒤집어서 원래대로 돌려놓는 방법을 쓸 수도 있다. 이 방법의 시간 복잡도는 O(n)이고 공간 복잡도는 O(1)이다.

## 스택 문제를 풀기 전 꼭 알고 있어야 할 내용
- 스택의 `LIFO` 특성을 `언제 사용할 수 있을지` 알고 있어야 한다. 예를 들어 `파싱(parsing)`을 할 때는 보통 스택을 사용한다.(문제 8.2, 8.5)
- 기본적인 스택 혹은 큐 자료구조를 `활용해서` 만들 수 있는 또 다른 연산을 생각해 보자. 예를 들어 최대 원소를 찾을 수도 있다.(문제 8.1)

## 스택 라이브러리 이해하기
Java에서 스택을 표현하는 좋은 방법은 Deque 인터페이스를 사용하는 것이다. ArrayDeque 클래스는 이 인터페이스를 구현한 가변 배열이며, O(1)의 분할 상환 시간으로 스택과 큐 기능을 제공한다.

Deque 인터페이스에서 스택과 관련된 핵심 메서드는 push(42), peek(), pop()이다. Deque 메서드인 addFirst(42), peekFirst(), removeFirst()는 push(42), peek(), pop()과 동일하다. 이 책의 해법에서는 push(42), peek(), pop()과 같은 메서드를 사용할 것이다.

- push(e)는 원소를 스택에 집어넣는 연산이다. push 호출이 잘못될 일은 별로 없다. 구현에 따라 용량의 한계를 넘어가면 IllegalStateException 예외를 던지거나, null을 삽입했을 때 NullPointerException 예외를 던질 수 있다. 연결리스트는 용량에 한계도 없고 null도 삽입할 수 있다. 하지만 null을 삽입할 때는 매우 조심해야 한다.
- peek()은 원소를 삭제하지 않고 스택의 위에 있는 원소를 반환하는 연산이다. 스택이 비어 있을 경우에는 null을 반환한다. 하지만 null이 유효한 원소일 수도 있기 때문에 모호한 경우가 생긴다. 따라서 isEmpty()를 사용해서 스택이 비어 있는지 확인하는 것이 좋다.
- pop()은 스택에서 원소를 삭제하고 그 원소를 반환하는 연산이다. 만약 덱이 비어 있다면 NoSuchElementException를 반환한다. 예외상황을 피하려면 isEmpty()로 스택이 비어 있는지 항상 확인하는 것이 좋다.

스택과 관련된 다른 유용한 메서드로는 descendingIterator()와 iterator()가 있다.

## 문제 8.1 최댓값 찾는 API로 스택 구현하기
push와 pop 외에 max 연산을 제공하는 스택 클래스를 설계하라. max() 메서드는 스택에 저장된 원소 중에서 가장 값이 큰 원소를 반환한다.

> 힌트: 최댓값을 기억하기 위해 공간을 추가로 사용해보자.

가장 간단한 방법부터 살펴보자. 스택을 배열로 구현했다면, 배열을 순회하면서 가장 값이 큰 원소를 찾으면 된다. 현재 스택의 원소가 n개일 때 이 방법의 시간 복잡도는 O(n)이고 공간 복잡도는 O(1)이다.

힙, BST, 해시 테이블과 같은 추가 자료구조를 사용하면 시간 복잡도를 O(log n)으로 줄일 수 있다. 하지만 공간 복잡도는 O(n)으로 늘어나고 코드도 꽤 복잡해진다.

스택의 최댓값을 기록하기 위해 추가로 M이라는 변수 하나를 사용한다고 생각해 보자. 원소를 삽입할 때 M을 갱신하는 건 쉽다. e가 새로 추가된 원소라고 했을 때 M = max(M,e)가 된다. 하지만 pop 연산을 할 때 M을 갱신하려면 경우에 따라 다시 남아 있는 원소를 모두 순회해야 하므로 시간이 꽤 걸린다.

공간을 조금 더 사용하면 시간 복잡도를 극적으로 개선할 수 있다. 스택의 모든 원소에 대해서 현재 원소 아래에 있는 원소들 중에서 최댓값이 무엇인지 캐싱을 하면 된다. 단, pop 연산을 수행할 때 해당 캐시값도 함께 제거해야 한다.

```java
private static class ElementWithCacheMax {
    public Integer element;
    public Integer max;

    public ElementWithCacheMax(Integer element, Integer max) {
        this.element = element;
        this.max = max;
    }
}

public static class Stack {
    // (원소, 최댓값) 쌍을 저장한다.
    private Deque<ElementWithCacheMax> elementWithCachedMax = new LinkedList<>();

    public boolean empty() {return elementWithCacheMax.isEmpty();}

    public Integer max() {
        if (empty()) {
            throw new IllegalStateException("max(): empty stack");
        }
        return elementWithCacheMax.peek().max;
    }

    public Integer pop() {
        if (empty()) {
            throw new IllegalStateException("pop(): empty stack");
        }
        return elementWithCacheMax.removeFirst().element;
    }

    public void push(Integer x) {
        elementWithCacheMax.addFirst(
            new ElementWithCacheMax(x, Math.max(x, empty() ? x : max()))
        );
    }
}
```

각 메서드의 시간 복잡도는 O(1)이다. 저장된 키에 관계없이 추가 공간 복잡도는 O(n)이 된다.

입력에 따라 필요한 공간을 줄일 수 있다. 만약 새로 추가되는 원소 e가 기존의 최댓값보다 작다면 e는 절대 최댓값이 될 수 없으므로 캐시에 기록할 필요가 없다. 최댓값을 계속 기록하다 보면 중복이 발생하므로 각 최댓값이 몇 번 등장했는지 기록해 중복을 제거한다.

```java
private static class MaxWithCount {
    public Integer max;
    public Integer count;

    public MaxWithCount(Integer max, Integer count) {
        this.max = max;
        this.count = count;
    }
}

public static class Stack {
    private Deque<Integer> element = new LinkedList<>();
    private Deque<MaxWithCount> cachedMaxWithCount = new LinkedList<>();

    public boolean empty() {return element.isEmpty();}

    public Integer max() {
        if (empty()) {
            throw new IllegalStateException("max(): empty stack");
        }
        return cachedMaxWithCount.peekFirst().max;
    }

    public Integer pop() {
        if (empty()) {
            throw new IllegalStateException("pop(): empty stack");
        }
        Integer popElement = element.removeFirst();
        if (popElement.equals(cachedMaxWithCount.peekFirst().max)) {
            cachedMaxWithCount.peekFirst().count = cachedMaxWithCount.peekFirst().count - 1;
            if (cachedMaxWithCount.peekFirst().count.equals(0)) {
                cachedMaxWithCount.removeFirst();
            }
        }
        return popElement;
    }

    public void push(Integer x) {
        element.addFirst(x);
        if (!cachedMaxWithCount.isEmpty()) {
            if (Integer.compare(x, cachedMaxWithCount.peekFirst().max) == 0) {
                cachedMaxWithCount.peekFirst().count += 1;
            } else if (Integer.compare(x, cachedMaxWithCount.peekFirst().max) > 0) {
                cachedMaxWithCount.addFirst(new MaxWithCount(x, 1));
            }
        } else {
            cachedMaxWithCount.addFirst(new MaxWithCount(x, 1));
        }
    }
}
```

최악의 경우(추가되는 키값이 항상 이전보다 큰 경우)의 공간 복잡도는 O(n)이다. 하지만 키값에 중복이 많고 최댓값이 자주 바뀌지 않는다면 추가로 필요한 공간 복잡도는 작을 것이다. 최고의 경우에는 O(1)이 된다. 각 메서드의 시간 복잡도는 여전히 O(1)이다.

## 문제 8.2 RPN 수식 계산하기
다음 조건을 만족하는 문자열은 RPN(Reverse Polish notation, 역 폴란드 표기법)을 따르는 산술 표현식이라 한다.

1. 길이가 1 이상인 숫자로 이루어진 문자열. '-'로 시작하는 경우도 있다. 예를 들어 "6", "123", "-42"가 있다.
2. A와 B가 RPN 수식을 만족하고 ○가 +, -, x, / 중 하나일 때 "A, B, ○"의 형태로 작성된 문자열이다.

RPN 수식을 계산하면 유일한 정수값이 나오는데, 이 값은 재귀적으로 구할 수 있다. 기저 사례(base case)는 1번 규칙, 즉 10진법으로 표기된 정수이다. 재귀 상태(recursive case)는 2번 규칙과 같고, RPN 수식을 자연스럽게 계산하면 된다. 즉, A가 2이고 B가 3일 때 "A, B, *"는 6과 같다.

RPN 수식이 주어졌을 때 이 수식의 계산 결과를 반환하는 프로그램을 작성하라.

> 힌트: 부분 수식을 계산한 뒤 그 값을 스택에 저장한다. 연산자는 어떻게 처리하면 될까?

RPN 예제로 먼저 시작해 보자. "3, 4, +, 2, *, 1, +"은 (3+4) * 2 + 1로 표현할 수 있다. 손으로 이 수식을 계산하려면 왼쪽에서 오른쪽으로 읽으면서 계산하면 된다. 3과 4를 기록한 뒤 +를 3과 4에 적용하고 그 결과를 7을 다시 기록한다. 이제 다시는 3과 4를 읽을 일이 없다. 그 다음에는 2를 곱한 결과인 14를 기록한다. 마지막으로 1을 더하면 최종 결과 15를 얻을 수 있다.

연산자를 만났을 때 중간 결과에 연산자를 적용해야 하므로 중간 결과를 기록해야 한다. 중간 결과는 후입선출법으로 추가되고 제거된다. 따라서 자연스럽게 스택을 사용해서 RPN 수식을 계산할 것이다.

```java
public static int eval(String RPNExpression) {
    Deque<Integer> intermediateResults = new LinkedList<>();
    String delimiter = ",";
    String[] symbols = RPNExpression.split(delimiter);
    for (String token : symbols) {
        if (token.length() == 1 && "+-*/".contains(token)) {
            final int y = intermediateResults.removeFirst();
            final int x = intermediateResults.removeFirst();
            switch (token.charAt(0)) {
                case '+':
                    intermediateResults.addFirst(x + y);
                    break;
                case '-':
                    intermediateResults.addFirst(x - y);
                    break;
                case '*':
                    intermediateResults.addFirst(x * y);
                    break;
                case '/':
                    intermediateResults.addFirst(x / y);
                    break;
                default:
                    throw new IllegalArgumentException("Malformed RPN at : " + token);
            }
        } else {
            // token이 숫자일 경우
            intermediateResults.addFirst(Integer.parseInt(token));
        }
    }
    return intermediateResults.removeFirst();
}
```

각 문자마다 O(1)의 연산을 수행하므로 문자열의 길이가 n일 때 시간 복잡도는 O(n)이 된다.

## 문제 8.3 문자열이 올바른 형태인지 확인하기
서로 다른 괄호 종류가 올바른 순서로 짝을 이루고 있을 때, 문자열을 '올바른 형태'라고 말한다.

예를 들어 "([]){()}" 혹은 "[()[]{()()}]"은 올바른 형태이다. 하지만 "{)" 혹은 "[()[]{()}()"은 올바른 형태가 아니다.

'(', ')', '[', ']', '{', '}'로 이루어진 문자열이 올바른 형태인지 확인하는 프로그램을 작성하라.

> 힌트: 어떤 왼쪽 괄호와 어떤 오른쪽 괄호가 짝을 이루는가?

"()(())"와 같이 소괄호로만 이루어진 문자열부터 시작하자. 만약 해당 문자열이 올바른 형태라면 오른쪽 괄호는 가장 가까운 왼쪽 괄호와 짝을 이루게 된다. 따라서 왼쪽에서 시작해서 왼쪽 괄호를 만나면 이를 저장한다. 그리고 오른쪽 괄호를 만났을 때 저장된 왼쪽 괄호와 짝을 이루는지 확인한다. 중괄호와 대괄호가 없으므로 현재까지 짝을 이루지 않은 왼쪽 소괄호의 개수를 기록한다.

이를 일반적인 경우에 대입해 보자. 즉, 실제로 짝을 이루지 않은 왼쪽 소괄호, 중괄호, 대괄호를 모두 저장한다. 단순히 변수 세 개를 사용해서 개수만 기록하면 가장 마지막에 짝을 이루지 않는 괄호가 무엇인지 알 수 없다. 따라서 스택을 통해 짝을 이루지 않는 왼쪽 괄호를 기록해 나가면, 스택의 가장 위에 있는 괄호가 가장 마지막에 짝을 짝을 이루지 않는 괄호가 될 것이다.

오른쪽 괄호가 등장했을 때 스택이 비어 있거나 스택의 최근 괄호와 형태가 다르다면 이는 주어진 문자열이 올바른 형태가 아니라는 뜻이다. 예를 들어, 입력 문자열이 "((][)"라면, "]"을 처리할 때 스택의 최근 괄호는 '('이므로 이 문자열은 올바른 형태가 아니다.

반대로 입력 문자열이 "(()[])"이라면, "]"을 처리할 때 스택의 최근 괄호는 '['이므로 계속 진행한다.

만약 모든 문자를 확인했는데도 스택이 비지 않는다면 짝을 이루지 않은 왼쪽 괄호가 남아 있다는 뜻이므로, 이 경우도 올바른 형태가 아니다.

```java
public static boolean isWellFormed(String s) {
    Deque<Character> leftChars = new LinkedList<>();
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(' || s.charAt(i) == '{' || s.charAt(i) == '[') {
            leftChars.addFirst(s.charAt(i));
        } else {
            if (leftChars.isEmpty()) {
                return false;
            }
            if ((s.charAt(i) == ')' && leftChars.peekFirst() != '(')
                || (s.charAt(i) == '}' && leftChars.peekFirst() != '{')
                || (s.charAt(i) == ']' && leftChars.peekFirst() != '[')) {
                return false;
            } else {
                leftChars.removeFirst();
            }
        }
        return leftChars.isEmpty();
    }
}
```

각 문자마다 O(1)의 연산을 수행하므로 시간 복잡도는 O(n)이다.

## 문제 8.4 경로 이름 표준화하기
파일 혹은 디렉터리에는 문자열로 이루어진 경로가 존재한다. 그 경로는 루트에서 시작하는 절대 경로(예를 들어 /usr/bin/gcc)일수도 있고, 현재 디렉터리에서 시작하는 상대 경로(예를 들어 script/test)일 수도 있다.

같은 디렉터리는 여러 가지 방법으로 경로를 표현할 수 있다. 예를 들어 /usr/lib/../bin/gcc와 script//./../scripts/test/././는 앞에서 예로 든 절대 경로와 상대 경로를 나타낸다.

경로가 주어졌을 때 같은 경로를 나타내는 가장 짧은 경로를 반환하라. 각 디렉터리와 파일의 이름은 알파벳과 숫자로만 이루어졌다고 가정해도 좋다. 하위 디렉터리의 이름은 슬래시(/), 현재 디렉터리(.), 부모 디렉터리(..)의 조합으로 나타낼 수 있다.

> 힌트: 각각의 경우를 잘 살펴보라. '.'와 '..'는 어떻게 처리할 것인지 고민하고, 유효하지 않은 경로를 조심하라.

자연스럽게 접근해 보자. 문자열을 왼쪽에서 오른쪽으로 읽으면서 슬래시(/)로 나누어 생각해볼 수 있다. 디렉터리와 파일 이름을 따로 기록한다. 만약 '..'를 만나게 되면 가장 최근의 이름을 삭제하고 디렉터리 계층에서 한 칸 위로 올라간다. 이름은 후입선출법으로 처리되므로 스택을 사용하면 된다. '.'은 건너뛰어도 좋다.

만약 문자열이 '/'로 시작한다면 한 칸 위로 올라갈 수 없다. 이를 스택에 기록한다. 만약 스택이 '/'로 시작하지 않는다면 '..'를 만났을 때 스택이 비어 있을 수도 있다. 여기서 '..'는 현재 경로의 윗단계에서 시작하라는 의미와 같다. 가장 짧은 경로를 표현하기 위해 이것도 기록할 필요가 있다. 최종적으로 스택에는 가장 짧은 경로가 기록되어 있을 것이다.

예를 들어 문자열이 "sc//./../tc/awk/././"일 때 스택에는 <sc> , <>, <tc>, <tc,awk>가 저장된다. 세 개의 '.'와 'sc/' 다음의 '/'는 건너뛰었다.

```java
public static String shortestEquivalentPath(String path) {
    if (path.equals("")) {
        throw new IllegalArgumentException("Empty string is not a legal path.");
    }

    Deque<String> pathNames = new LinkedList<>();
    // 특별한 경우: "/"로 시작한 경우, 절대 경로를 나타낸다.
    if (path.startsWith("/")) {
        pathNames.addFirst("/");
    }

    for (String token : path.split("/")) {
        if (token.equals("..")) {
            if (pathNames.isEmpty() || pathNames.peekFirst().equals("..")) {
                pathNames.addFirst(token);
            } else {
                if (pathNames.peekFirst().equals("/")) {
                    throw new IllegalArgumentException(
                        "Path error, trying to go up root " + path
                    );
                }
                pathNames.removeFirst();
            }
        } else if (!token.equals(".") && !token.isEmpty()) {
            // 이름이 와야 한다.
            pathNames.addFirst(token);
        }
    }

    StringBuilder result = new StringBuilder();
    if (!pathNames.isEmpty()) {
        Iterator<String> it = pathNames.descendingIterator();
        String prev = it.next();
        result.append(prev);
        while (it.hasNext()) {
            if (!prev.equals("/")) {
                result.append("/");
            }
            prev = it.next();
            result.append(prev);
        }
    }
    return result.toString();
}
```
경로의 길이가 n일 때 시간 복잡도는 O(n)이 된다.

## 문제 8.5 노을이 보이는 건물 찾기
서쪽으로 창문이 나 있는 일련의 건물이 입력으로 주어진다. 건물은 서쪽에서 동쪽 방향으로 직선 배치되어 있으므로, 높이가 같거나 낮은 건물이 동쪽에 있다면 그 건물에서는 노을을 볼 수 없다.

동쪽에서 서쪽 방향으로 차례대로 건물을 처리한다고 했을 때 노을을 볼 수 있는 건물의 집합을 반환하는 알고리즘을 설계하라. 모든 건물의 높이는 주어져 있다.

> 힌트: 건물에서 노을을 볼 수 없는 건 언제인가.

무식한 방법을 생각해 보자. 모든 건물을 배열에 저장한 뒤, 배열을 거꾸로 읽으면서 가장 높은 건물의 높이를 기록한다. 해당 높이보다 낮거나 같은 건물은 노을을 볼 수 없다.

건물의 개수를 n이라고 했을 때 시간 및 공간 복잡도는 O(n)이 된다.

더 높은 건물이 서쪽에 있다면 노을을 볼 수 없다. 이 사실을 사용하면 공간 복잡도를 줄일 수 있다. 먼저 노을을 볼 수 있는 건물들의 후보를 기록해 놓는다. 새로운 건물이 등장하면 기존 건물들의 노을 뷰를 가릴 수도 있다. 기존 건물의 집합과 현재 건물의 높이를 비교하면서 새로운 건물이 다른 건물의 노을 뷰를 가리는지 확인한다. 이때 기존 건물들을 해시셋(hash set)에 기록해 놓는데, 해시셋을 이용할 경우 새로운 건물을 처리할 때마다 모든 건물의 노을 뷰를 다 훑어 봐야 한다.

만약 새로운 건물의 높이가 현재 건물들보다 작다면 현재 집합의 건물은 새로운 건물에게 방해받지 않는다. 따라서 후입선출법(last-in first-out)을 통해 건물을 저장한다면 모든 건물을 훑어 보지 않고 빠르게 방해받는 건물들을 골라낼 수 있다.

노을을 볼 수 있는 건물들을 스택에 저장한다. 건물 b를 처리할 때마다, 건물 b보다 높은 건물이 나올 때까지 스택에서 건물을 제외한다. 이를 통해 b보다 낮은 모든 건물을 제거한다.

경우에 따라 스택에서 건물을 반복적으로 빼내야 할 수도 있지만, 전체적으로 각 건물은 최대 한번 스택에 넣었다가 최대 한번 빼내진다. 따라서 건물을 처리하는 시간 복잡도는 O(n)이 되고, 최종적으로 스택에는 현재 노을을 볼 수 있는 건물만 들어 있게 된다.

최악의 경우에는 노을을 볼 수 있는 건물이 오직 한 개만 존재한다. 가장 서쪽에 있는 건물이 제일 높고 나머지 n-1개의 건물들은 동쪽에서 서쪽으로 높이가 낮아지는 경우다. 그렇더라도 메모리는 기껏해야 O(n)만큼 사용한다. 최선의 경우라면, 건물들은 높이가 증가하는 순서대로 나열되어 있다. 이때 O(1)의 공간을 사용한다. 반면에 무식한 방법은 언제나 O(n)의 공간을 사용한다.

```java
private static class BuildingWithHeight {
    public Integer id;
    public Integer height;

    public BuildingWithHeight(Integer id, Integer height) {
        this.id = id;
        this.height = height;
    }
}

public static Deque<BuildingWithHeight> examineBuildingWithSunset(Iterator<Integer> sequence) {
    int buildingIdx = 0;
    Deque<BuildingWithHeight> candidates = new ArrayDeque<>();
    while (sequence.hasNext()) {
        Integer buildingHeight = sequence.next();
        while (!candidates.isEmpty() && (Integer.compare(buildingHeight, candidates.peekLast().height) >= 0)) {
            candidates.removeLast();
        }
        candidates.addLast(new BuildingWithHeight(buildingIdx++, buildingHeight));
    }

    List<Integer> buildingWithSunset = new ArrayList<>();
    while (!candidates.isEmpty()) {
        buildingWithSunset.add(candidates.removeLast().id);
    }
    return buildingWithSunset;
}
```

