# 15장 재귀

재귀는 부분 문제의 해법을 통해 전체 문제에 대한 해법을 구하는 것으로, 컴퓨터 문법처럼 반복 규칙을 사용해서 입력을 표현하는 데 적절하다. 더 일반적으로 얘기하면 탐색, 열거, 분할 정복(divide-and-conquer), 그리고 복잡한 문제를 유사한 작은 문제로 분해할 수 있는 모든 경우에 재귀를 사용할 수 있다.

재귀는 기저 사례(base case)로 구성되며, 다른 인수를 써서 동일한 함수를 호출한다. 재귀를 성공적으로 사용하기 위한 두 가지 주요 요소는 곧바로 풀 수 있는 기저 사례를 식별하는 것과 재귀가 한데 모아져 전체 해법이 완성되도록 보장하는 것이다.

분할 정복 알고리즘도 곧바로 풀 수 있을 정도로 간단해질 때까지 반복적으로 하나의 문제를 두 개 이상의 비슷하면서도 독립된 문제로 쪼개나간다. 그 뒤 부분 문제의 해법을 하나로 합쳐서 기존 문제에 대한 해법을 찾는다. 병합 정렬이나 퀵정렬은 분할 정복 알고리즘의 기본적인 예제이다.

분할 정복과 재귀가 같은 말은 아니다. 분할 정복은 하나의 문제를 두 개 이상의 독립된 문제로 쪼개 나가지만, 독립된 부분 문제가 기존 문제와 비슷한 형태여야 한다. 재귀는 좀 더 일반적인 뜻이다. 이진 탐색과 같이 부분 문제가 하나일 수도 있고, 동적 프로그래밍과 같이 부분 문제가 독립된 형태가 아닐 수도 있다. 또한 정규표현식을 찾는 문제처럼 기존의 문제와 같은 형태가 아닐 수도 있다. 시간 복잡도 혹은 공간 복잡도를 개선하기 위해서 분할 정복 알고리즘을 재귀가 아닌 반복적인 형태로 구현하기도 한다.

## 재귀 부트 캠프

두 숫자의 최대공약수(GCD)를 찾는 유클리드 알고리즘은 재귀의 기본적인 예제이다. y > x인 경우에 x와 y의 최대공약수는 x와 y - x의 최대공약수와 같다는 사실에서 출발한다. 예를 들면 GCD(156, 36) = GCD((156-36) = 120, 36)이다. 이를 확장하면 x와 y의 최대공약수는 x와 y mod x의 최대공약수와 같다는 사실을 알 수 있다. 예를 들어 GCD(156,36) = GCD((156 mod 36) = 12, 36) = GCD(12, (36 mod 12) = 0) = 12가 된다.

```java
public static long GCD(long x, long y) {
    return y == 0 ? x : GCD(y, x % y);
}
```

재귀의 단계를 거칠 때마다 둘 중 하나의 숫자가 적어도 절반씩 줄어들게 되므로, 시간 복잡도는 $O(\log \max(x,y))$가 된다. 다른 방법으로는 n이 입력 숫자를 표현하는 데 필요한 비트의 개수라고 했을 때 $O(n)$이 된다. 공간 복잡도 또한 함수 호출 스택의 최대 깊이와 같으므로 $O(n)$이 된다. (이 문제를 반복적 방법으로 바꾸면 공간 복잡도를 $O(1)$로 줄일 수 있다.)

이번에는 재귀적인 분할 정복 알고리즘으로 우아하게 해결할 수 있는 문제를 설명한다. 트리오미노(triomino)는 3개의 정사각형은 L자 모양으로 결합해서 만든다. 훼손된 체스판(이하 8 x 8 보드)은 그림 15.1(a)에 표시된 것처럼, 왼쪽 상단 사각형을 뺀 8 x 8 사각형으로 배열된 64개의 사각형으로 구성된다.

8 x 8 보드에 21개의 트리오미노를 배치하는 알고리즘을 설계해 보자. 8 x 8보드에는 63개의 사각형이 있고 배치해야 할 트리오미노는 21개이므로, 트리오미노는 서로 겹칠 수 없으며 보드 밖으로 벗어날 수 없다.

분할 정복은 이 문제를 풀 수 있는 좋은 전략이다. n x n 보드로 일반화해 생각해 보자. 2 x 2 보드는 같은 모양이므로 트리오미노로 덮을 수 있다. 왼쪽 상단 정사각형이 빠진 n x n 보드에 대한 트리오미노 배치를 사용하면, (n + 1) x (n + 1) 보드의 배치도 계산할 수 있다고 가정할 수 있다. 하지만 이 가정으로 문제를 풀 수 없다는 걸 곧 알게 될 것이다.

또 다른 가정은 n x n 보드에 대한 배치가 가능하다면, 2n x 2n 보드에 대한 배치도 가능하다는 것이다. 여기에 분할 정복을 적용할 수 있다. 그림 15.1(b)에서와 같이 4개의 n x n 보드를 가져와서 3개의 보드는 누락된 정사각형이 중앙을 향하도록 하고, 1개의 보드는 2n x 2n 보드의 빠진 모서리와 일치하도록 바깥쪽으로 향해 배열한다. 중앙의 공백은 트리오미노로 덮을 수 있고, 앞에서 세운 가설에 따라 4개의 n x n개의 보드도 트리오미노로 덮을 수 있다. 그러므로 2의 거듭제곱인 n에 대한 배치가 가능하다. 특히 $2^3 * 2^3$ 보드에 대한 배치가 가능하며, 증명에 사용된 재귀를 통해 배치를 직접 산출한다.

## 재귀 문제를 풀기 전 꼭 알고 있어야 할 내용

- 재귀는 특히 **입력이 재귀적인 규칙에 따라 표현**될 때 유용하다. [문제 24.23]
- 재귀는 **탐색, 열거, 분할 정복**을 해야 하는 경우에 좋은 선택이다. [문제 15.2, 15.9, 24.24]
- **중첩된 반복문이 여러 개일 경우 재귀를 사용**할 수 있다. 필요한 반복문의 개수가 정확하지 않을 경우에는 재귀가 더 나은 선택이 될 수 있는데, IP 주소 문제에서 IP 주소 대신 k개의 부분 문자열을 입력으로 사용하는 경우를 예로 들 수 있다. [문제 6.10]
- 프로그램에서 **재귀를 삭제**하라는 요구가 있다면 **스택 자료구조**를 사용해서 호출 스택을 흉내 낼 수 있다. [문제 24.13]
- **꼬리-재귀(tail-recursive)** 프로그램은 while을 사용해서 간단하게 재귀를 없앨 수 있다. 스택을 사용하지 않아도 된다. (컴파일러가 자동으로 최적화를 해준다.) [문제 4.7]
- **동일한 인자(arguments)**로 재귀 함수를 한 번 이상 호출할 일이 생긴다면, 그 결과를 **캐시**에 저장하라. 이것이 바로 동적 프로그래밍이다. (16장)
