# 15장 재귀

재귀는 부분 문제의 해법을 통해 전체 문제에 대한 해법을 구하는 것으로, 컴퓨터 문법처럼 반복 규칙을 사용해서 입력을 표현하는 데 적절하다. 더 일반적으로 얘기하면 탐색, 열거, 분할 정복(divide-and-conquer), 그리고 복잡한 문제를 유사한 작은 문제로 분해할 수 있는 모든 경우에 재귀를 사용할 수 있다.

재귀는 기저 사례(base case)로 구성되며, 다른 인수를 써서 동일한 함수를 호출한다. 재귀를 성공적으로 사용하기 위한 두 가지 주요 요소는 곧바로 풀 수 있는 기저 사례를 식별하는 것과 재귀가 한데 모아져 전체 해법이 완성되도록 보장하는 것이다.

분할 정복 알고리즘도 곧바로 풀 수 있을 정도로 간단해질 때까지 반복적으로 하나의 문제를 두 개 이상의 비슷하면서도 독립된 문제로 쪼개나간다. 그 뒤 부분 문제의 해법을 하나로 합쳐서 기존 문제에 대한 해법을 찾는다. 병합 정렬이나 퀵정렬은 분할 정복 알고리즘의 기본적인 예제이다.

분할 정복과 재귀가 같은 말은 아니다. 분할 정복은 하나의 문제를 두 개 이상의 독립된 문제로 쪼개 나가지만, 독립된 부분 문제가 기존 문제와 비슷한 형태여야 한다. 재귀는 좀 더 일반적인 뜻이다. 이진 탐색과 같이 부분 문제가 하나일 수도 있고, 동적 프로그래밍과 같이 부분 문제가 독립된 형태가 아닐 수도 있다. 또한 정규표현식을 찾는 문제처럼 기존의 문제와 같은 형태가 아닐 수도 있다. 시간 복잡도 혹은 공간 복잡도를 개선하기 위해서 분할 정복 알고리즘을 재귀가 아닌 반복적인 형태로 구현하기도 한다.

## 재귀 부트 캠프

두 숫자의 최대공약수(GCD)를 찾는 유클리드 알고리즘은 재귀의 기본적인 예제이다. y > x인 경우에 x와 y의 최대공약수는 x와 y - x의 최대공약수와 같다는 사실에서 출발한다. 예를 들면 GCD(156, 36) = GCD((156-36) = 120, 36)이다. 이를 확장하면 x와 y의 최대공약수는 x와 y mod x의 최대공약수와 같다는 사실을 알 수 있다. 예를 들어 GCD(156,36) = GCD((156 mod 36) = 12, 36) = GCD(12, (36 mod 12) = 0) = 12가 된다.

```java
public static long GCD(long x, long y) {
    return y == 0 ? x : GCD(y, x % y);
}
```

재귀의 단계를 거칠 때마다 둘 중 하나의 숫자가 적어도 절반씩 줄어들게 되므로, 시간 복잡도는 $O(\log \max(x,y))$가 된다. 다른 방법으로는 n이 입력 숫자를 표현하는 데 필요한 비트의 개수라고 했을 때 $O(n)$이 된다. 공간 복잡도 또한 함수 호출 스택의 최대 깊이와 같으므로 $O(n)$이 된다. (이 문제를 반복적 방법으로 바꾸면 공간 복잡도를 $O(1)$로 줄일 수 있다.)

이번에는 재귀적인 분할 정복 알고리즘으로 우아하게 해결할 수 있는 문제를 설명한다. 트리오미노(triomino)는 3개의 정사각형은 L자 모양으로 결합해서 만든다. 훼손된 체스판(이하 8 x 8 보드)은 그림 15.1(a)에 표시된 것처럼, 왼쪽 상단 사각형을 뺀 8 x 8 사각형으로 배열된 64개의 사각형으로 구성된다.

8 x 8 보드에 21개의 트리오미노를 배치하는 알고리즘을 설계해 보자. 8 x 8보드에는 63개의 사각형이 있고 배치해야 할 트리오미노는 21개이므로, 트리오미노는 서로 겹칠 수 없으며 보드 밖으로 벗어날 수 없다.

분할 정복은 이 문제를 풀 수 있는 좋은 전략이다. n x n 보드로 일반화해 생각해 보자. 2 x 2 보드는 같은 모양이므로 트리오미노로 덮을 수 있다. 왼쪽 상단 정사각형이 빠진 n x n 보드에 대한 트리오미노 배치를 사용하면, (n + 1) x (n + 1) 보드의 배치도 계산할 수 있다고 가정할 수 있다. 하지만 이 가정으로 문제를 풀 수 없다는 걸 곧 알게 될 것이다.

또 다른 가정은 n x n 보드에 대한 배치가 가능하다면, 2n x 2n 보드에 대한 배치도 가능하다는 것이다. 여기에 분할 정복을 적용할 수 있다. 그림 15.1(b)에서와 같이 4개의 n x n 보드를 가져와서 3개의 보드는 누락된 정사각형이 중앙을 향하도록 하고, 1개의 보드는 2n x 2n 보드의 빠진 모서리와 일치하도록 바깥쪽으로 향해 배열한다. 중앙의 공백은 트리오미노로 덮을 수 있고, 앞에서 세운 가설에 따라 4개의 n x n개의 보드도 트리오미노로 덮을 수 있다. 그러므로 2의 거듭제곱인 n에 대한 배치가 가능하다. 특히 $2^3 * 2^3$ 보드에 대한 배치가 가능하며, 증명에 사용된 재귀를 통해 배치를 직접 산출한다.

## 재귀 문제를 풀기 전 꼭 알고 있어야 할 내용

- 재귀는 특히 **입력이 재귀적인 규칙에 따라 표현**될 때 유용하다. [문제 24.23]
- 재귀는 **탐색, 열거, 분할 정복**을 해야 하는 경우에 좋은 선택이다. [문제 15.2, 15.9, 24.24]
- **중첩된 반복문이 여러 개일 경우 재귀를 사용**할 수 있다. 필요한 반복문의 개수가 정확하지 않을 경우에는 재귀가 더 나은 선택이 될 수 있는데, IP 주소 문제에서 IP 주소 대신 k개의 부분 문자열을 입력으로 사용하는 경우를 예로 들 수 있다. [문제 6.10]
- 프로그램에서 **재귀를 삭제**하라는 요구가 있다면 **스택 자료구조**를 사용해서 호출 스택을 흉내 낼 수 있다. [문제 24.13]
- **꼬리-재귀(tail-recursive)** 프로그램은 while을 사용해서 간단하게 재귀를 없앨 수 있다. 스택을 사용하지 않아도 된다. (컴파일러가 자동으로 최적화를 해준다.) [문제 4.7]
- **동일한 인자(arguments)**로 재귀 함수를 한 번 이상 호출할 일이 생긴다면, 그 결과를 **캐시**에 저장하라. 이것이 바로 동적 프로그래밍이다. (16장)

## 문제 15.1 하노이 타워 문제

한 말뚝에 고리(ring)가 큰 것부터 작은 것 순으로 정렬되어 있다. 그림 15.2(a)의 상태에서 (b) 상태로 옮기고 싶다. 이때 크기가 큰 고리를 작은 고리 위에 둘 수 없다.

n개의 고리를 다른 말뚝으로 옮기는 연산을 차례대로 출력하는 프로그램을 작성하라. 세 번째 말뚝은 비어 있다. 맨 처음 수행할 수 있는 유일한 연산은 가장 위에 있는 하나의 고리를 꺼낸 뒤 다른 말뚝으로 옮기는 것이다.

> 힌트: n-1개의 고리를 옮기는 방법을 안다고 가정했을 때, n번쨰 고리는 어떻게 옮기겠는가?

몇 개의 예를 통해 문제를 해결할 수 있는 통찰력을 얻을 수 있다. 고리가 세 개 있다면, 위에 있던 고리 두 개를 세 번째 말뚝으로 옮긴 뒤에, 가장 아래(가장 큰)에 있던 고리를 두 번째 말뚝으로 옮긴다. 그다음 첫 번째 말뚝을 사용해서 세 번째 말뚝에 있던 고리 두 개를 두 번째 말뚝으로 옮기면 된다. 고리 네 개를 옮기려면 위에 있던 고리 세 개를 세 번째 말뚝으로 옮긴 뒤에 가장 아래(가장 큰)에 있는 고리를 두 번째 말뚝으로 옮긴다. 그다음 첫 번째 말뚝을 사용해서 세 번째에 있던 고리 세 개를 두 번째 말뚝으로 옮기면 된다. 세 개의 고리를 옮기는 방법과 네 개의 고리를 옮기는 방법에서 첫 번째와 세 번째 단계가 같은 문제를 의미하므로 재귀를 떠올리게 된다. 그림 15.3은 이 방법을 나타내며, 구현 코드는 다음과 같다.

```java
private static final int NUM_PEGS = 3;

public static List<List<Integer>> computeTowerHanoi(int numRings) {

    List<Deque<Integer>> pegs = new ArrayList<>();
    for (int i = 0; i < NUM_PEGS; i++) {
        pegs.add(new ArrayDeque<Integer>());
    }
    // 말뚝의 상태를 초기화한다.
    for (int i = numRings; i >= 1; --i) {
        pegs.get(0).addFirst(i);
    }
    List<List<Integer>> result = new ArrayList<>();
    computeTowerHanoiSteps(numRings, pegs, 0, 1, 2, result);
    return result;
}

private static void computeTowerHanoiSteps(int numRingsToMove,
                                           List<Deque<Integer>> pegs,
                                           int fromPeg, int toPeg, int usePeg,
                                           List<List<Integer>> result)
{
    if (numRingsToMove > 0) {
        computeTowerHanoiSteps(numRingsToMove - 1, pegs, fromPeg, usePeg, toPeg, result);
        pegs.get(toPeg).addFirst(pegs.get(fromPeg).removeFirst());
        result.add(Arrays.asList(fromPeg, toPeg));
        computeTowerHanoiSteps(numRingsToMove - 1, pegs, usePeg, toPeg, usePeg, result);
    }
}
```

실제 고리를 옮긴 횟수는 $T(n) = T(n - 1) + 1 + T(n - 1) = 1 + 2T(n - 1)$과 같다. 처음 $T(n - 1)$은 P1에서 P3으로 n - 1개의 고리를 옮긴 것을 뜻하고, 두 번째 $T(n - 1)$은 P3에서 P2로 n - 1개의 고리를 옮긴 것을 뜻한다. 이 수식을 풀면 $T(n) = 2^n - 1$이 된다. 이 수식을 나열해 보면 다음과 같다. $T(n) = 1 + 2 + 4 + ... + 2^kT(n - k)$가 된다. 고리를 하나 옮기는 데 $O(1)$ 시간이 걸리므로 전체 시간 복잡도는 $O(2^n)$이다.

## 문제 15.2 n개의 퀸이 서로 공격하지 못하는 상황을 모두 나열하기

퀸을 공격받지 않는 안전한 상태로 두려면 같은 행, 열, 대각선상에 다른 퀸을 놓지 않아야 한다. 그림 15.4는 퀸이 안전하게 놓여 있다.

입력으로 n이 주어졌을 때, n x n 크기의 체스판에 n개의 퀸이 안전하게 놓이는 모든 가능한 경우의 수를 반환하라.

> 힌트: 첫 번째 퀸을 (i,j)에 놓았을 때, 나머지 퀸을 놓을 수 없는 곳은 어디인가?

무식한 방법은 n개의 퀸을 가능한 모든 위치에 놓아 보는 것이다. 모든 가능한 횟수는 $\binom{n^2}{n}$이므로 n이 커지면 그 경우의 수가 빠르게 증가한다.

퀸 두 개를 같은 행에 놓을 수 없으므로 모든 퀸을 다른 행에 놓도록 하면 좀 더 빠르게 풀 수 있다. 이렇게 하면 행이 겹치는 상황은 없지만, 열과 대각선에서 겹칠 수 있다. 이를 해결하기 위해 길이가 n인 배열을 사용해, i번째 행에서 퀸을 어디에 놓았는지 표현할 수 있다.

예를 들어 n = 4인 경우에 첫 번째 행의 퀸을 0번 열에 놓았다고 가정하자. 이를 배열로 표현하면 (0,_,_,_)이 된다. 두 번째 행에서는 첫 번째 열에 퀸을 놓으면 안 되므로 (0,0,_,_)의 상황을 전부 제외한다. 두 번째 행에서 두 번째 열에 퀸을 놓으면 대각선으로 겹치므로 (0,1,_,_)의 상황을 전부 제외한다. 이제 (0,2,0,_)의 상황으로 넘어가자. 이렇게 놓으면 첫 번째 열이 겹치게 된다. (0,2,1,_)은 첫 번째 행의 두 번째 열 혹은 두 번째 행의 첫 번째 열의 퀸과 겹치게 된다. (0,2,2,_)는 두 번째 행의 두 번째 열과 겹치게 된다. (0,2,3,_)또한 대각선에서 겹치므로 (0,3,_,_)으로 넘어간다. (0,3,1,_)과 (0,3,2,_) 모두 겹치게 되므로 첫 번쨰 행의 첫 번째 열에 퀸을 놓으면 안 된다는 사실을 알 수 있다. 이를 반복하다 보면 서로 공격하지 않도록 퀸을 놓는 방법은 (1,3,0,2)와 (2,0,3,1)뿐이라는 사실을 알 수 있다.

```java
public static List<List<Integer>> nQueens(int n) {
    List<List<Integer>> result = new ArrayList<>();
    solveNQueens(n, 0, new ArrayList<Integer>(), result);
}

private static void solveNQueens(int n, int row, List<Integer> colPlacement, List<List<Integer>> result) {
    if (row == n) {
        // 모든 퀸을 놓을 수 있다.
        result.add(new ArrayList<>(colPlacement));
    } else {
        for (int col = 0; col < n; col++) {
            colPlacement.add(col);
            if (isValid(colPlacement)) {
                solveNQueens(n, row + 1, colPlacement, result);
            }
            colPlacement.remove(colPlacement.size() - 1);
        }
    }
}

// 새로운 위치에 놓인 퀸이 기존에 있던 다른 퀸들에게 잡아먹히는 상황이 오는지 확인한다.
private static boolean isValid(List<Integer> colPlacement) {
    int rowID = colPlacement.size() - 1;
    for (int i = 0; i < rowID; i++) {
        int diff = Math.abs(colPlacement.get(i) - colPlacement.get(rowID));
        if (diff == 0 || diff == rowID - i) {
            return false;
        }
    }
    return true;
}
```

시간 복잡도의 하한은 퀸을 놓을 수 있는 전체 경우의 수와 같다. n의 함수로 이를 정확히 표현하기는 어렵지만, $n!/c^n$으로 짐작하고 있다. $c \approx 2.54$로 복잡도가 지수 그 이상이다.
