# 5. 배열
- 배열에서는 A[i]의 객체를 읽거나 갱신하는데 O(1)의 시간이 걸린다.
- 배열에서의 삽입 연산은 배열 크기를 늘리는 작업이 필요하다. 즉, 배열의 크기만큼 추가 메모리 공간을 할당하고, 기존의 객체를 새로운 공간에 모두 복사해서 넣어야 한다. 이 때문에 삽입 연산은 최악의 경우의 시간 복잡도가 증가한다. 하지만 배열의 크기를 늘릴 떄 기존보다 상수 배 크게 늘린다면, 배열 복사 작업이 자주 일어나지 않으므로 삽입 연산의 평균 시간 복잡도는 상수 시간이 된다.
- 배열에서 원소를 삭제하면, 그 뒤에 있는 객체를 왼쪽으로 한 칸씩 옮겨야 한다. i번째 인덱스의 원소를 삭제할 떄 소요되는 시간 복잡도는, 배열의 길이가 n일 떄, O(n-1)이 된다.

## 배열 부트캠프
정수 배열이 주어졌을 때 짝수가 먼저 나오도록 재배열해 보라. 이 문제는 배열의 길이가 n이라고 했을 때, 추가 공간을 O(n)만큼 사용하면 쉽게 풀 수 있다. 그런데 추가 공간을 사용하지 않고도 풀 수 있다.

배열에서 양쪽 끝을 손쉽게 접근할 수 있는 이점을 떠올려 보자. 이 문제에서는 배열을 짝수, 정해지지 않은 숫자, 홀수의 세 가지 부분 배열로 나눌 것이다. 초기에는 짝수와 홀수 부분 배열은 비어 있고, 정해지지 않은 숫자는 전체 배열이 될 것이다. 정해지지 않은 숫자를 하나씩 순회하면서 원소를 홀수 혹은 짝수 부분 배열로 옮긴다. 짝수와 홀수 부분 배열의 크기는 증가하고 정해지지 않은 숫자 부분 배열의 크기는 감소한다.

```java
// 달리 말하면 짝수, 홀수 순으로 정렬한다고 할 수 있겠다.
public static void evenOdd(List<Integer> A) {
    int nextEven = 0, nextOdd = A.size() - 1; 
    while (nextEven < nextOdd) {
        if (A.get(nextEven) % 2 == 0) {
            nextEven++;
        } else {
            Collections.swap(A, nextEven, nextOdd--);
        }
    }
}
```

추가 공간 복잡도는 O(1)이다. 인덱스 저장과 스왑을 위해 몇 개의 변수를 사용했을 뿐이다. 각 단계마다 수행한 연산 횟수가 상수이므로 시간 복잡도는 O(n)이 된다.

## 배열 문제를 풀기 전 꼭 알고 있어야 할 내용
- 배열과 관련된 문제는 무식하게 접근하면 O(n) 공간을 사용해서 풀 수도 있다. 그런데 공간 복잡도를 O(1)로 **줄이려면** 풀기 상당히 어려워질 수 있다. [문제 5.1]
- 배열을 앞에서부터 채워 나가면 오래 걸리지만, **뒤에서부터 채워 나가면** 빠를 수도 있다. [문제 5.2]
- 원소를 삭제해서 다른 원소들을 왼쪽으로 옮기기보다는 삭제할 원소에 덮어쓰는 방법이 나을 수도 있다. [문제 5.5]
- 배열로 표현된 정수를 다룰 때에는, **배열의 끝에서부터 숫자를 처리**해 나가는 방법을 고려해 보라. 혹은 배열을 뒤집어서 **최하위 숫자를 배열의 첫 번째 위치에 오도록** 만들 수도 있다. [문제 5.3]
- **부분 배열**을 사용하는 코드를 작성하는 데 익숙해지라. [문제 5.11]
- 배열을 사용할 때 **인덱스를 잘못 사용하는 실수**를 하기가 굉장히 쉽다. [문제 5.4, 문제 5.18]
- 실제 반환할 때까지 배열의 초기 상태를 **유지**(정렬, 균등한 원소 유지 등)하지 않아도 된다. [문제 5.5]
- 원소의 분포를 미리 알고 있을 때 배열은 좋은 자료구조가 될 수 있다. 예를 들어 길이가 W인 불 배열을 사용하면 숫자 집합{0,1,...W-1}의 **부분 집합**을 쉽게 표현할 수 있다. ({1,2,3,...,n}의 부분 집합을 불 배열로 표현할 때 인덱스를 간단히 하기 위해 크기가 n + 1인 배열을 사용해도 된다.) [문제 5.9]
- 2차원 배열을 사용할 때는 **열과 행을 동시에 처리하는 로직**을 사용하라. [문제 5.18]
- 가끔은 문제의 **세부 사항을 따라 해 보는 것**이 문제를 분석적으로 푸는 것보다 쉬울 수 있다. 예를 들어 나선형으로 채워진 n*n 배열의 i번째 원소를 찾는 수식을 작성하는 것보다 첫 번째 원소부터 나선형으로 하나씩 따라가면서 i번째 원소를 찾는 게 더 쉬울 수 있다. [문제 5.18, 문제 5.20]

## 배열 라이브러리 이해하기
Java의 기본 배열은 크기가 정해져 있다. 따라서 Java의 Arrays 유틸리티에 친숙해져야 기본 배열형을 사용한 작업을 단순화할 수 있다. ArrayList를 사용하면 배열의 크기를 동적으로 바꿀 수 있으므로 기본 배열을 대신해 쓰기 좋다. ArrayList는 유연하며, API를 많이 가지고 있다. 그 외에도 기본 배열형에 대해 더 알고 싶다면 7장에서 설명하는 List, ArrayList, Collections를 읽어 보길 바란다.

- 배열을 할당하고 초기화하는 문법을 알고 있어야 한다(예를 들어 `new int[]{1,2,3}`).
- 2차원 배열을 어떻게 초기화하는지 알고 있어야 한다. new Integer[3][]은 행의 개수가 3개인 배열을 만들고 각 행은 반드시 명시적으로 할당되어야 한다.
- length를 통해 배열의 길이를 알 수 있다. Collections에는 size() 메서드가 있고, String에는 length() 메서드가 있다.
- Array 클래스는 몇 가지 정적 유틸리티 메서드를 가지고 있다. asList(), binarySearch(A, 641), copyOf(A), copyOfRange(A, 1, 5), equals(A, B), fill(A, 42), find(A, 28), sort(A), sort(A, cmp), toString() 메서드 모두 중요하다.
  - 이 메서드들의 변종에 대해서도 이해하고 있어야 한다. 예를 들어 어떻게 부분 배열을 복사할 수 있는지 알고 있어야 한다.
  - 배열의 동등성을 확인하거나 해싱을 할 때, '깊은(deep)'의 의미를 알고 있어야 한다. 예를 들어 깊은(deep) 동등성은 '객체'에 대한 동등성을 나타내고, 얕은(shallow) 동등성은 '참조값'에 대한 동등성을 나타낸다.

  Arrays와 Collections 모두 binarySearch()와 sort() 메서드를 가지고 있다. 각 메서드들에는 미묘한 차이가 있는데, 자세한 사항은 11장과 13장에서 다룬다.

## 문제 5.1 네덜란드 국기 문제
퀵정렬 알고리즘은 다음 과정을 재귀적으로 반복한다. 원소(피벗)를 선택한 후 이보다 작거나 같은 그룹은 왼쪽, 이보다 큰 그룹은 오른쪽에 나오도록 재배치한다. 이를 재귀적으로 반복하면 두 부분 배열은 정렬된다.

피벗의 위치에 따라 부분 배열의 크기가 달라지기 때문에 단순하게 구현한다면, 퀵정렬의 수행시간은 커지고, 함수 호출 스택에는 깊은 복사에 의한 중복된 부분 배열이 많을 것이다. 이를 해결할 한 가지 해법은 같은 배열에서 피벗보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소 순으로 재배열하는 것이다. 이를 네덜란드 국기 나누기라고 부른다.

배열 A와 인덱스 i가 주어졌을 때, A[i](피벗)보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소 순으로 원소를 재배열하는 프로그램을 작성하라.

> 힌트: 퀵정렬에서 피벗을 기준으로 원소를 나누는 방법을 다시 생각해보자.

배열 A의 길이를 n이라고 했을 때, O(n)의 공간을 추가로 사용한다면 이 문제는 굉장히 간단하다. 피벗보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소, 이렇게 세 가지 리스트를 만든 뒤에 이들을 차례대로 A에 넣어 주면 된다. 시간 복잡도는 O(n)이다.

```java
public static enum Color { RED, WHITE, BLUE }

public static void dutchFlagPartition(int pivotIndex, List<Color> A) {
    Color pivot = A.get(pivotIndex);
    // 첫 번째 단계: 피벗보다 작은 원소의 그룹을 구한다.
    for (int i = 0; i < A.size(); ++i) {
        // 작은 원소를 찾는다.
        for (int j = 0; j < A.size(); ++i) {
            if (A.get(j).ordinal() < pivot.ordinal()) {
                Collections.swap(A, i, j);
                break;
            }
        }
    }
    // 두 번째 단계: 피벗보다 큰 원소의 그룹을 구한다.
    for (int i = A.size() - 1; i >= 0 && A.get(i).ordinal() >= pivot.ordinal(); --i) {
        // 큰 원소를 찾는다. 피벗보다 작은 원소에 맞딱뜨리게 되면 즉시 멈춘다.
        // 왜냐하면 윗 단계에서 피벗보다 작은 원소들은 이미 A의 앞쪽으로 옮겨졌기 때문이다.
        for (int j = i; j >= 0 && A.get(j).ordinal() >= pivot.ordinal(); ==j) {
            if (A.get(j).ordinal() > pivot.ordinal()) {
                Collections.swap(A, i, j);
                break;
            }
        }
    }
}
```

공간 복잡도는 O(1)이고, 시간 복잡도는 O(n^2)이다.
이 방법의 시간 복잡도는 효율적이지 못하다. 왜냐하면 첫 번째 단계에서 피벗보다 작은 원소를 추가적으로 탐색할 때 항상 앞에서부터 하기 때문이다. 사실 마지막으로 추가한 위치에서 시작해도 된다.

이제 시간 복잡도를 줄여보자. 단일 패스를 통해 피벗보다 작은 원소를 모두 앞으로 옮길 것이다. 그 다음에는 피벗보다 큰 원소를 모두 뒤로 옮길 것이다. 잘못된 위치에 있는 원소를 발견할 때마다 올바른 위치로 옮기는 작업은 쉽게 수행 가능하다.

```java
public static enum Color {RED, WHITE, BLUE}

public static void dutchFlagPartition(int pivotIndex, List<Color> A) {
    Color pivot = A.get(pivotIndex);
    // 첫 번째 단계: 피벗보다 작은 원소의 그룹을 구한다.
    int smaller = 0;
    for (int i = 0; i < A.size(); ++i) {
        if (A.get(i).ordinal() < pivot.ordinal()) {
            Collections.swap(A, smaller++, i);
        }
    }
    // 두 번째 단계: 피벗보다 큰 원소의 그룹을 구한다.
    int larger = A.size() - 1;
    for (int i = A.size() - 1; i >= 0 && A.get(i).ordinal() >= pivot.ordianl(); --i) {
        if (A.get(i).ordinal() > pivot.ordinal()) {
            Collections.swap(A, larger--, i);
        }
    }
}
```

시간 복잡도는 O(n)이고 공간 복잡도는 O(1)이다.

이번에 소개할 방법은 앞에서 언급한 알고리즘과 유사하다. 가장 큰 차이점은 단일 패스를 통해 피벗보다 작거나, 같거나, 큰 원소들을 분류할 수 있다는 것이다. 구현 방법이 살짝 까다롭지만 수행시간을 좀 더 줄일 수 있다. 부분 배열이 피벗보다 작은 원소(bottom), 피벗과 같은 원소(middle), 미분류 원소(unclassified), 피벗보다 큰 원소(top), 이렇게 네 개 필요하다. 미분류 원소에 있는 원소를 차례대로 피벗과 비교한 뒤에 피벗보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소 중의 하나로 옮긴다.

```java
public static enum Color {RED, WHITE, BLUE}

public static void dutchFlagPartition(int pivotIndex, List<Color> A) {
    Color pivot = A.get(pivotIndex);
    /**
     * 분류할 때마다 다음 불변식을 만족해야 한다.
     * 피벗보다 작은 원소 그룹: A.subList(0, smaller)
     * 피벗과 같은 그룹: A.subList(smaller, equal)
     * 미분류 원소 그룹: A.subList(equal, larger)
     * 피벗보다 큰 원소 그룹: A.subList(larger, A.size())
     */
    int smaller = 0, equal = 0, larger = A.size();
    // 분류되지 않은 원소가 있는 동안 계속 순회한다.
    while (equal < larger) {
        // A.get(equal)는 분류되지 않은 원소를 가리킨다.
        if (A.get(equal).ordinal() < pivot.ordinal()) {
            Collections.swap(A, smaller++, equal++);
        } else if (A.get(equal).ordinal() == pivot.ordinal()) {
            ++equal;
        } else { // A.get(equal) > pivot
            Collections.swap(A, equal, --larger);
        }
    }
}
```

매번 분류되지 않은 원소 그룹의 크기는 1씩 감소할 것이고, 원소를 분류하는 데 걸리는 시간은 O(1)이므로 총 시간 복잡도는 O(n)이 된다. 공간 복잡도는 O(1)이다.

## 문제 5.2 임의의 정수값 증가시키기
십진수 D를 나타낸 배열 A가 주어졌을 때, D+1의 결과를 다시 배열 A에 갱신하는 코드를 작성하라. 예를 들어, 입력으로 <1,2,9>가 주어졌다면, D+1의 결과는 <1,3,0>이 된다. 작성한 알고리즘은 유한 정밀도 산술(finite-precision arithmetic)로 이루어진 프로그램 언어로도 동작해야 한다.

> 힌트: 실제 예제 입력을 사용해서 접근해보자.

무식한 방법을 사용하면, 배열의 숫자를 정수로 바꾼 뒤 값을 1만큼 증가시키고, 그 결과를 다시 배열에 쓰면 된다. 예를 들어 <1,2,9>가 입력으로 주어졌다면 이를 정수 129로 바꾼 뒤 1을 더해서 130으로 만든다. 그 다음 정수 130을 다시 배열에 써서 <1,3,0>을 만들면 된다. 하지만 이 방법은 프로그램 언어에서 정한 정수의 범위에 한해서만 작동하고, 그 범위를 벗어나는 값에 대해선 동작하지 않는다.

배열에 연산을 직접 적용하면 오버플로 문제를 피할 수 있다. 즉, 최하위 숫자부터 덧셈을 한 후 올림수를 넘겨주는 방식을 사용하면 된다. 만약 99 + 1 = 100과 같이 덧셈 결과의 자릿수가 다르다면, 100을 나타내기 위해 세 자리가 필요하지만 입력은 두 자리만 있기 때문에 결과를 저장할 공간이 충분하지 않다.

```java
public static List<Integer> plusOne(List<Integer> A) {
    int n = A.size() - 1;
    A.set(n, A.get(n) + 1);
    for (int i = n; i > 0 && A.get(i) == 10; --i) {
        A.set(i, 0);
        A.set(i - 1, A.get(i - 1) + 1);
    }
    if (A.get(0) == 10) {
        // 최상위 숫자에 올림수가 존재하므로, 결과 저장을 위해 한 자리가 더 필요하다.
        // 깔끔한 방법은 첫 번째 항목을 1로 업데이트하고 배열 끝에는 0을 추가해 주는 것이다.
        A.set(0, 1);
        A.add(0);
    }
    return A;
}
// 마지막에 0을 추가하는 방법은 재미있다!!
// 맨 앞의 요소를 추가하는 것보다 마지막 요소를 추가하는 것이 쉽다는 말이 이 내용이었다.
```

배열의 길이가 n이라고 했을 때 시간 복잡도는 O(n)이 된다.