# 5. 배열
- 배열에서는 A[i]의 객체를 읽거나 갱신하는데 O(1)의 시간이 걸린다.
- 배열에서의 삽입 연산은 배열 크기를 늘리는 작업이 필요하다. 즉, 배열의 크기만큼 추가 메모리 공간을 할당하고, 기존의 객체를 새로운 공간에 모두 복사해서 넣어야 한다. 이 때문에 삽입 연산은 최악의 경우의 시간 복잡도가 증가한다. 하지만 배열의 크기를 늘릴 떄 기존보다 상수 배 크게 늘린다면, 배열 복사 작업이 자주 일어나지 않으므로 삽입 연산의 평균 시간 복잡도는 상수 시간이 된다.
- 배열에서 원소를 삭제하면, 그 뒤에 있는 객체를 왼쪽으로 한 칸씩 옮겨야 한다. i번째 인덱스의 원소를 삭제할 떄 소요되는 시간 복잡도는, 배열의 길이가 n일 떄, O(n-1)이 된다.

## 배열 부트캠프
정수 배열이 주어졌을 때 짝수가 먼저 나오도록 재배열해 보라. 이 문제는 배열의 길이가 n이라고 했을 때, 추가 공간을 O(n)만큼 사용하면 쉽게 풀 수 있다. 그런데 추가 공간을 사용하지 않고도 풀 수 있다.

배열에서 양쪽 끝을 손쉽게 접근할 수 있는 이점을 떠올려 보자. 이 문제에서는 배열을 짝수, 정해지지 않은 숫자, 홀수의 세 가지 부분 배열로 나눌 것이다. 초기에는 짝수와 홀수 부분 배열은 비어 있고, 정해지지 않은 숫자는 전체 배열이 될 것이다. 정해지지 않은 숫자를 하나씩 순회하면서 원소를 홀수 혹은 짝수 부분 배열로 옮긴다. 짝수와 홀수 부분 배열의 크기는 증가하고 정해지지 않은 숫자 부분 배열의 크기는 감소한다.

```java
// 달리 말하면 짝수, 홀수 순으로 정렬한다고 할 수 있겠다.
public static void evenOdd(List<Integer> A) {
    int nextEven = 0, nextOdd = A.size() - 1; 
    while (nextEven < nextOdd) {
        if (A.get(nextEven) % 2 == 0) {
            nextEven++;
        } else {
            Collections.swap(A, nextEven, nextOdd--);
        }
    }
}
```

추가 공간 복잡도는 O(1)이다. 인덱스 저장과 스왑을 위해 몇 개의 변수를 사용했을 뿐이다. 각 단계마다 수행한 연산 횟수가 상수이므로 시간 복잡도는 O(n)이 된다.

## 배열 문제를 풀기 전 꼭 알고 있어야 할 내용
- 배열과 관련된 문제는 무식하게 접근하면 O(n) 공간을 사용해서 풀 수도 있다. 그런데 공간 복잡도를 O(1)로 **줄이려면** 풀기 상당히 어려워질 수 있다. [문제 5.1]
- 배열을 앞에서부터 채워 나가면 오래 걸리지만, **뒤에서부터 채워 나가면** 빠를 수도 있다. [문제 5.2]
- 원소를 삭제해서 다른 원소들을 왼쪽으로 옮기기보다는 삭제할 원소에 덮어쓰는 방법이 나을 수도 있다. [문제 5.5]
- 배열로 표현된 정수를 다룰 때에는, **배열의 끝에서부터 숫자를 처리**해 나가는 방법을 고려해 보라. 혹은 배열을 뒤집어서 **최하위 숫자를 배열의 첫 번째 위치에 오도록** 만들 수도 있다. [문제 5.3]
- **부분 배열**을 사용하는 코드를 작성하는 데 익숙해지라. [문제 5.11]
- 배열을 사용할 때 **인덱스를 잘못 사용하는 실수**를 하기가 굉장히 쉽다. [문제 5.4, 문제 5.18]
- 실제 반환할 때까지 배열의 초기 상태를 **유지**(정렬, 균등한 원소 유지 등)하지 않아도 된다. [문제 5.5]
- 원소의 분포를 미리 알고 있을 때 배열은 좋은 자료구조가 될 수 있다. 예를 들어 길이가 W인 불 배열을 사용하면 숫자 집합{0,1,...W-1}의 **부분 집합**을 쉽게 표현할 수 있다. ({1,2,3,...,n}의 부분 집합을 불 배열로 표현할 때 인덱스를 간단히 하기 위해 크기가 n + 1인 배열을 사용해도 된다.) [문제 5.9]
- 2차원 배열을 사용할 때는 **열과 행을 동시에 처리하는 로직**을 사용하라. [문제 5.18]
- 가끔은 문제의 **세부 사항을 따라 해 보는 것**이 문제를 분석적으로 푸는 것보다 쉬울 수 있다. 예를 들어 나선형으로 채워진 n*n 배열의 i번째 원소를 찾는 수식을 작성하는 것보다 첫 번째 원소부터 나선형으로 하나씩 따라가면서 i번째 원소를 찾는 게 더 쉬울 수 있다. [문제 5.18, 문제 5.20]

## 배열 라이브러리 이해하기
Java의 기본 배열은 크기가 정해져 있다. 따라서 Java의 Arrays 유틸리티에 친숙해져야 기본 배열형을 사용한 작업을 단순화할 수 있다. ArrayList를 사용하면 배열의 크기를 동적으로 바꿀 수 있으므로 기본 배열을 대신해 쓰기 좋다. ArrayList는 유연하며, API를 많이 가지고 있다. 그 외에도 기본 배열형에 대해 더 알고 싶다면 7장에서 설명하는 List, ArrayList, Collections를 읽어 보길 바란다.

- 배열을 할당하고 초기화하는 문법을 알고 있어야 한다(예를 들어 `new int[]{1,2,3}`).
- 2차원 배열을 어떻게 초기화하는지 알고 있어야 한다. new Integer[3][]은 행의 개수가 3개인 배열을 만들고 각 행은 반드시 명시적으로 할당되어야 한다.
- length를 통해 배열의 길이를 알 수 있다. Collections에는 size() 메서드가 있고, String에는 length() 메서드가 있다.
- Array 클래스는 몇 가지 정적 유틸리티 메서드를 가지고 있다. asList(), binarySearch(A, 641), copyOf(A), copyOfRange(A, 1, 5), equals(A, B), fill(A, 42), find(A, 28), sort(A), sort(A, cmp), toString() 메서드 모두 중요하다.
  - 이 메서드들의 변종에 대해서도 이해하고 있어야 한다. 예를 들어 어떻게 부분 배열을 복사할 수 있는지 알고 있어야 한다.
  - 배열의 동등성을 확인하거나 해싱을 할 때, '깊은(deep)'의 의미를 알고 있어야 한다. 예를 들어 깊은(deep) 동등성은 '객체'에 대한 동등성을 나타내고, 얕은(shallow) 동등성은 '참조값'에 대한 동등성을 나타낸다.

  Arrays와 Collections 모두 binarySearch()와 sort() 메서드를 가지고 있다. 각 메서드들에는 미묘한 차이가 있는데, 자세한 사항은 11장과 13장에서 다룬다.

## 문제 5.1 네덜란드 국기 문제
퀵정렬 알고리즘은 다음 과정을 재귀적으로 반복한다. 원소(피벗)를 선택한 후 이보다 작거나 같은 그룹은 왼쪽, 이보다 큰 그룹은 오른쪽에 나오도록 재배치한다. 이를 재귀적으로 반복하면 두 부분 배열은 정렬된다.

피벗의 위치에 따라 부분 배열의 크기가 달라지기 때문에 단순하게 구현한다면, 퀵정렬의 수행시간은 커지고, 함수 호출 스택에는 깊은 복사에 의한 중복된 부분 배열이 많을 것이다. 이를 해결할 한 가지 해법은 같은 배열에서 피벗보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소 순으로 재배열하는 것이다. 이를 네덜란드 국기 나누기라고 부른다.

배열 A와 인덱스 i가 주어졌을 때, A[i](피벗)보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소 순으로 원소를 재배열하는 프로그램을 작성하라.

> 힌트: 퀵정렬에서 피벗을 기준으로 원소를 나누는 방법을 다시 생각해보자.

배열 A의 길이를 n이라고 했을 때, O(n)의 공간을 추가로 사용한다면 이 문제는 굉장히 간단하다. 피벗보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소, 이렇게 세 가지 리스트를 만든 뒤에 이들을 차례대로 A에 넣어 주면 된다. 시간 복잡도는 O(n)이다.

```java
public static enum Color { RED, WHITE, BLUE }

public static void dutchFlagPartition(int pivotIndex, List<Color> A) {
    Color pivot = A.get(pivotIndex);
    // 첫 번째 단계: 피벗보다 작은 원소의 그룹을 구한다.
    for (int i = 0; i < A.size(); ++i) {
        // 작은 원소를 찾는다.
        for (int j = 0; j < A.size(); ++i) {
            if (A.get(j).ordinal() < pivot.ordinal()) {
                Collections.swap(A, i, j);
                break;
            }
        }
    }
    // 두 번째 단계: 피벗보다 큰 원소의 그룹을 구한다.
    for (int i = A.size() - 1; i >= 0 && A.get(i).ordinal() >= pivot.ordinal(); --i) {
        // 큰 원소를 찾는다. 피벗보다 작은 원소에 맞딱뜨리게 되면 즉시 멈춘다.
        // 왜냐하면 윗 단계에서 피벗보다 작은 원소들은 이미 A의 앞쪽으로 옮겨졌기 때문이다.
        for (int j = i; j >= 0 && A.get(j).ordinal() >= pivot.ordinal(); ==j) {
            if (A.get(j).ordinal() > pivot.ordinal()) {
                Collections.swap(A, i, j);
                break;
            }
        }
    }
}
```

공간 복잡도는 O(1)이고, 시간 복잡도는 O(n^2)이다.
이 방법의 시간 복잡도는 효율적이지 못하다. 왜냐하면 첫 번째 단계에서 피벗보다 작은 원소를 추가적으로 탐색할 때 항상 앞에서부터 하기 때문이다. 사실 마지막으로 추가한 위치에서 시작해도 된다.

이제 시간 복잡도를 줄여보자. 단일 패스를 통해 피벗보다 작은 원소를 모두 앞으로 옮길 것이다. 그 다음에는 피벗보다 큰 원소를 모두 뒤로 옮길 것이다. 잘못된 위치에 있는 원소를 발견할 때마다 올바른 위치로 옮기는 작업은 쉽게 수행 가능하다.

```java
public static enum Color {RED, WHITE, BLUE}

public static void dutchFlagPartition(int pivotIndex, List<Color> A) {
    Color pivot = A.get(pivotIndex);
    // 첫 번째 단계: 피벗보다 작은 원소의 그룹을 구한다.
    int smaller = 0;
    for (int i = 0; i < A.size(); ++i) {
        if (A.get(i).ordinal() < pivot.ordinal()) {
            Collections.swap(A, smaller++, i);
        }
    }
    // 두 번째 단계: 피벗보다 큰 원소의 그룹을 구한다.
    int larger = A.size() - 1;
    for (int i = A.size() - 1; i >= 0 && A.get(i).ordinal() >= pivot.ordianl(); --i) {
        if (A.get(i).ordinal() > pivot.ordinal()) {
            Collections.swap(A, larger--, i);
        }
    }
}
```

시간 복잡도는 O(n)이고 공간 복잡도는 O(1)이다.

이번에 소개할 방법은 앞에서 언급한 알고리즘과 유사하다. 가장 큰 차이점은 단일 패스를 통해 피벗보다 작거나, 같거나, 큰 원소들을 분류할 수 있다는 것이다. 구현 방법이 살짝 까다롭지만 수행시간을 좀 더 줄일 수 있다. 부분 배열이 피벗보다 작은 원소(bottom), 피벗과 같은 원소(middle), 미분류 원소(unclassified), 피벗보다 큰 원소(top), 이렇게 네 개 필요하다. 미분류 원소에 있는 원소를 차례대로 피벗과 비교한 뒤에 피벗보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소 중의 하나로 옮긴다.

```java
public static enum Color {RED, WHITE, BLUE}

public static void dutchFlagPartition(int pivotIndex, List<Color> A) {
    Color pivot = A.get(pivotIndex);
    /**
     * 분류할 때마다 다음 불변식을 만족해야 한다.
     * 피벗보다 작은 원소 그룹: A.subList(0, smaller)
     * 피벗과 같은 그룹: A.subList(smaller, equal)
     * 미분류 원소 그룹: A.subList(equal, larger)
     * 피벗보다 큰 원소 그룹: A.subList(larger, A.size())
     */
    int smaller = 0, equal = 0, larger = A.size();
    // 분류되지 않은 원소가 있는 동안 계속 순회한다.
    while (equal < larger) {
        // A.get(equal)는 분류되지 않은 원소를 가리킨다.
        if (A.get(equal).ordinal() < pivot.ordinal()) {
            Collections.swap(A, smaller++, equal++);
        } else if (A.get(equal).ordinal() == pivot.ordinal()) {
            ++equal;
        } else { // A.get(equal) > pivot
            Collections.swap(A, equal, --larger);
        }
    }
}
```

매번 분류되지 않은 원소 그룹의 크기는 1씩 감소할 것이고, 원소를 분류하는 데 걸리는 시간은 O(1)이므로 총 시간 복잡도는 O(n)이 된다. 공간 복잡도는 O(1)이다.

## 문제 5.2 임의의 정수값 증가시키기
십진수 D를 나타낸 배열 A가 주어졌을 때, D+1의 결과를 다시 배열 A에 갱신하는 코드를 작성하라. 예를 들어, 입력으로 <1,2,9>가 주어졌다면, D+1의 결과는 <1,3,0>이 된다. 작성한 알고리즘은 유한 정밀도 산술(finite-precision arithmetic)로 이루어진 프로그램 언어로도 동작해야 한다.

> 힌트: 실제 예제 입력을 사용해서 접근해보자.

무식한 방법을 사용하면, 배열의 숫자를 정수로 바꾼 뒤 값을 1만큼 증가시키고, 그 결과를 다시 배열에 쓰면 된다. 예를 들어 <1,2,9>가 입력으로 주어졌다면 이를 정수 129로 바꾼 뒤 1을 더해서 130으로 만든다. 그 다음 정수 130을 다시 배열에 써서 <1,3,0>을 만들면 된다. 하지만 이 방법은 프로그램 언어에서 정한 정수의 범위에 한해서만 작동하고, 그 범위를 벗어나는 값에 대해선 동작하지 않는다.

배열에 연산을 직접 적용하면 오버플로 문제를 피할 수 있다. 즉, 최하위 숫자부터 덧셈을 한 후 올림수를 넘겨주는 방식을 사용하면 된다. 만약 99 + 1 = 100과 같이 덧셈 결과의 자릿수가 다르다면, 100을 나타내기 위해 세 자리가 필요하지만 입력은 두 자리만 있기 때문에 결과를 저장할 공간이 충분하지 않다.

```java
public static List<Integer> plusOne(List<Integer> A) {
    int n = A.size() - 1;
    A.set(n, A.get(n) + 1);
    for (int i = n; i > 0 && A.get(i) == 10; --i) {
        A.set(i, 0);
        A.set(i - 1, A.get(i - 1) + 1);
    }
    if (A.get(0) == 10) {
        // 최상위 숫자에 올림수가 존재하므로, 결과 저장을 위해 한 자리가 더 필요하다.
        // 깔끔한 방법은 첫 번째 항목을 1로 업데이트하고 배열 끝에는 0을 추가해 주는 것이다.
        A.set(0, 1);
        A.add(0);
    }
    return A;
}
// 마지막에 0을 추가하는 방법은 재미있다!!
// 맨 앞의 요소를 추가하는 것보다 마지막 요소를 추가하는 것이 쉽다는 말이 이 내용이었다.
```

배열의 길이가 n이라고 했을 때 시간 복잡도는 O(n)이 된다.

## 5.3 임의의 두 정수값 곱하기
어떤 애플리케이션에는 임의의 정밀도 산술 연산(arbitrary precision arithmetic)이 필요하기도 하다. 이를 구현하는 한 가지 방법은 배열을 사용하는 것이다. 최상위 숫자를 배열의 가장 앞에 오도록 한다. 음수를 저장하는 배열은 가장 앞자리 숫자가 음수다. 예를 들어 배열 <1,9,3,7,0,7,7,2,1>은 숫자 193707721을 뜻하고, 배열 <-7,6,1,8,3,8,2,5,7,2,8,7>은 숫자 -761838257287을 뜻한다.

정수를 나타내는 두 개의 문자열이 주어졌을 때, 이 둘의 곱셈 결과를 반환하는 함수를 작성하라.

> 힌트: 초등학생 때 배운 곱셈 연산을 그대로 적용해보자.

[Multiply.java](Multiply.java)

m개의 부분 곱셈이 존재하고, 각각 최대 n + 1개의 자릿수와 곱셈을 수행한다. 각 자릿수를 곱하는데 O(1) 시간이 걸리므로 총 시간 복잡도는 O(nm)이 된다.

## 5.4 배열에서 이동하기
주어진 위치 정보를 차례대로 걸어 나가야 하는 보드 게임이 있다. 각 위치에는 음이 아닌 정수값이 들어 있고, 해당 위치에서 최대 그 숫자만큼 앞으로 나아갈 수 있다. 이 게임의 목표는 첫 번째 위치에서 시작해서 마지막 위치에 도달하는 것이다. 예를 들어 배열 A=<3,3,1,0,2,0,1>의 i번째 위치에서는 최대 A[i]만큼 앞으로 나아갈 수 있다. 이 게임에서 승리하는 방법은 다음과 같다. A[0]에서 1만큼 움직여서 A[1]로 간다. 그 다음 3만큼 움직여서 A[4]로 가고, 그 다음 2만큼 움직여서 마지막 위치인 A[6]에 도달한다. A[0] = 3 >= 1, A[1] = 3 >= 3, A[4] = 2 >= 2이므로 모두 유효한 움직임이다. 만약 A가 <3,2,0,0,2,0,1>이라면 A[3]에서 더 이상 나아갈 수 없다.

길이가 n인 배열 A가 주어졌을 때, 배열의 시작점에서 마지막 지점까지 도달할 수 있는지 판단하는 프로그램을 작성하라. 단 A[i]는 i번째 위치에서 나아갈 수 있는 최대 거리를 뜻한다.

> 힌트: 시작점부터 시작해서 각 위치를 잘 분석해보자.

```java
public static boolean canReachEnd(List<Integer> maxAdvanceSteps) {
    int furthestReachSoFar = 0, lastIndex = maxAdvanceSteps.size() - 1;
    for (int i = 0; i <= furthestReachSoFar && furthestReachSoFar < lastIndex; ++i) {
        furthestReachSoFar = Math.max(furthestReachSoFar, i + maxAdvanceSteps.get(i));
    }
    return furthestReachSoFar >= lastIndex;
}
```

## 5.5 정렬된 배열에서 중복 제거하기
정렬된 배열이 입력으로 주어졌을 때 중복된 원소를 모두 제거한 뒤, 비어 있는 공간이 생기지 않도록 유효한 원소들은 모두 왼쪽으로 시프트하는 프로그램을 작성하라. 유효한 원소의 개수를 반환하면 된다. 많은 언어에서 삭제 연산이 라이브러리로 주어지지만 라이브러리를 사용하지 말고 구현하라.

> 힌트: O(n) 시간 복잡도와 O(1) 공간 복도 해법이 존재한다.

배열 A의 길이가 n이라고 하자. 공간을 O(n)만큼 추가로 사용할 수 있다면 해시 테이블을 사용해서 쉽게 구현할 수 있다. 즉, 배열 A를 순회하면서 해시 테이블에 원소를 넣고 확인하면 된다. 새로운 원소는 리스트에 넣은 뒤, 그 리스트를 다시 배열 A에 복사한다.

O(1)을 사용한 무식한 방법도 존재한다. 배열 A를 순회하면서 A[i]와 A[i+1]이 같을 때, i + 2 이후의 원소들을 모두 왼쪽으로 한 칸씩 옮긴다. 모든 원소가 같다면 시프트해야 하는 횟수는 (n - 1) + (n - 2) + ... + 2 + 1이 되고, 시간 복잡도는 O(n^2)이 된다.(n은 배열의 길이를 나타낸다.)

시프팅이 시간 복잡도의 주요 원인이므로 시간 복잡도를 개선하려면 시프팅의 횟수를 줄여야 한다. 배열이 이미 정렬되어 있으므로 반복된 원소들은 연달아 나타난다. 따라서 해당 원소가 이미 나왔었는지 확인하기 위해 자료구조를 보조적으로 사용할 필요는 없다. 모든 부분 배열을 옮기지 않아도 된다. 단순히 원소 하나를 한 번만 옮기면 되나.

앞의 예제 <2,3,5,5,7,11,11,11,13>에서 A[3]을 처리한다고 가정하자. A[3]과 A[2]를 비교해 보면 5가 존재한다는 사실을 알 수 있으므로 A[4]로 넘어간다. A[4]는 새로운 값이므로 삭제해야할 위치인 A[3]으로 옮긴다. 이제 배열은 <2,3,5,7,7,11,11,11,13>이 되고, 삭제해야할 위치는 A[4]가 된다. 그 다음에 A[5]부터 이 과정을 반복한다.

```java
// 삭제 후 유효한 원소의 개수를 반환한다.
public static int deleteDuplicates(List<Integer> A) {
    if (A.isEmpty()) {
        return 0;
    }

    int writeIndex = 1;
    for (int i = 1; i < A.size(); ++i) {
        if (!A.get(writeIndex - 1).equals(A.get(i))) {
            A.set(writeIndex++, A.get(i));
        }
    }
    return writeIndex;
}
```