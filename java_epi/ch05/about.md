# 5. 배열
- 배열에서는 A[i]의 객체를 읽거나 갱신하는데 O(1)의 시간이 걸린다.
- 배열에서의 삽입 연산은 배열 크기를 늘리는 작업이 필요하다. 즉, 배열의 크기만큼 추가 메모리 공간을 할당하고, 기존의 객체를 새로운 공간에 모두 복사해서 넣어야 한다. 이 때문에 삽입 연산은 최악의 경우의 시간 복잡도가 증가한다. 하지만 배열의 크기를 늘릴 떄 기존보다 상수 배 크게 늘린다면, 배열 복사 작업이 자주 일어나지 않으므로 삽입 연산의 평균 시간 복잡도는 상수 시간이 된다.
- 배열에서 원소를 삭제하면, 그 뒤에 있는 객체를 왼쪽으로 한 칸씩 옮겨야 한다. i번째 인덱스의 원소를 삭제할 떄 소요되는 시간 복잡도는, 배열의 길이가 n일 떄, O(n-1)이 된다.

## 배열 부트캠프
정수 배열이 주어졌을 때 짝수가 먼저 나오도록 재배열해 보라. 이 문제는 배열의 길이가 n이라고 했을 때, 추가 공간을 O(n)만큼 사용하면 쉽게 풀 수 있다. 그런데 추가 공간을 사용하지 않고도 풀 수 있다.

배열에서 양쪽 끝을 손쉽게 접근할 수 있는 이점을 떠올려 보자. 이 문제에서는 배열을 짝수, 정해지지 않은 숫자, 홀수의 세 가지 부분 배열로 나눌 것이다. 초기에는 짝수와 홀수 부분 배열은 비어 있고, 정해지지 않은 숫자는 전체 배열이 될 것이다. 정해지지 않은 숫자를 하나씩 순회하면서 원소를 홀수 혹은 짝수 부분 배열로 옮긴다. 짝수와 홀수 부분 배열의 크기는 증가하고 정해지지 않은 숫자 부분 배열의 크기는 감소한다.

```java
// 달리 말하면 짝수, 홀수 순으로 정렬한다고 할 수 있겠다.
public static void evenOdd(List<Integer> A) {
    int nextEven = 0, nextOdd = A.size() - 1; 
    while (nextEven < nextOdd) {
        if (A.get(nextEven) % 2 == 0) {
            nextEven++;
        } else {
            Collections.swap(A, nextEven, nextOdd--);
        }
    }
}
```

추가 공간 복잡도는 O(1)이다. 인덱스 저장과 스왑을 위해 몇 개의 변수를 사용했을 뿐이다. 각 단계마다 수행한 연산 횟수가 상수이므로 시간 복잡도는 O(n)이 된다.

## 배열 문제를 풀기 전 꼭 알고 있어야 할 내용
- 배열과 관련된 문제는 무식하게 접근하면 O(n) 공간을 사용해서 풀 수도 있다. 그런데 공간 복잡도를 O(1)로 **줄이려면** 풀기 상당히 어려워질 수 있다. [문제 5.1]
- 배열을 앞에서부터 채워 나가면 오래 걸리지만, **뒤에서부터 채워 나가면** 빠를 수도 있다. [문제 5.2]
- 원소를 삭제해서 다른 원소들을 왼쪽으로 옮기기보다는 삭제할 원소에 덮어쓰는 방법이 나을 수도 있다. [문제 5.5]
- 배열로 표현된 정수를 다룰 때에는, **배열의 끝에서부터 숫자를 처리**해 나가는 방법을 고려해 보라. 혹은 배열을 뒤집어서 **최하위 숫자를 배열의 첫 번째 위치에 오도록** 만들 수도 있다. [문제 5.3]
- **부분 배열**을 사용하는 코드를 작성하는 데 익숙해지라. [문제 5.11]
- 배열을 사용할 때 **인덱스를 잘못 사용하는 실수**를 하기가 굉장히 쉽다. [문제 5.4, 문제 5.18]
- 실제 반환할 때까지 배열의 초기 상태를 **유지**(정렬, 균등한 원소 유지 등)하지 않아도 된다. [문제 5.5]
- 원소의 분포를 미리 알고 있을 때 배열은 좋은 자료구조가 될 수 있다. 예를 들어 길이가 W인 불 배열을 사용하면 숫자 집합{0,1,...W-1}의 **부분 집합**을 쉽게 표현할 수 있다. ({1,2,3,...,n}의 부분 집합을 불 배열로 표현할 때 인덱스를 간단히 하기 위해 크기가 n + 1인 배열을 사용해도 된다.) [문제 5.9]
- 2차원 배열을 사용할 때는 **열과 행을 동시에 처리하는 로직**을 사용하라. [문제 5.18]
- 가끔은 문제의 **세부 사항을 따라 해 보는 것**이 문제를 분석적으로 푸는 것보다 쉬울 수 있다. 예를 들어 나선형으로 채워진 n*n 배열의 i번째 원소를 찾는 수식을 작성하는 것보다 첫 번째 원소부터 나선형으로 하나씩 따라가면서 i번째 원소를 찾는 게 더 쉬울 수 있다. [문제 5.18, 문제 5.20]

## 배열 라이브러리 이해하기
Java의 기본 배열은 크기가 정해져 있다. 따라서 Java의 Arrays 유틸리티에 친숙해져야 기본 배열형을 사용한 작업을 단순화할 수 있다. ArrayList를 사용하면 배열의 크기를 동적으로 바꿀 수 있으므로 기본 배열을 대신해 쓰기 좋다. ArrayList는 유연하며, API를 많이 가지고 있다. 그 외에도 기본 배열형에 대해 더 알고 싶다면 7장에서 설명하는 List, ArrayList, Collections를 읽어 보길 바란다.

- 배열을 할당하고 초기화하는 문법을 알고 있어야 한다(예를 들어 `new int[]{1,2,3}`).
- 2차원 배열을 어떻게 초기화하는지 알고 있어야 한다. new Integer[3][]은 행의 개수가 3개인 배열을 만들고 각 행은 반드시 명시적으로 할당되어야 한다.
- length를 통해 배열의 길이를 알 수 있다. Collections에는 size() 메서드가 있고, String에는 length() 메서드가 있다.
- Array 클래스는 몇 가지 정적 유틸리티 메서드를 가지고 있다. asList(), binarySearch(A, 641), copyOf(A), copyOfRange(A, 1, 5), equals(A, B), fill(A, 42), find(A, 28), sort(A), sort(A, cmp), toString() 메서드 모두 중요하다.
  - 이 메서드들의 변종에 대해서도 이해하고 있어야 한다. 예를 들어 어떻게 부분 배열을 복사할 수 있는지 알고 있어야 한다.
  - 배열의 동등성을 확인하거나 해싱을 할 때, '깊은(deep)'의 의미를 알고 있어야 한다. 예를 들어 깊은(deep) 동등성은 '객체'에 대한 동등성을 나타내고, 얕은(shallow) 동등성은 '참조값'에 대한 동등성을 나타낸다.

  Arrays와 Collections 모두 binarySearch()와 sort() 메서드를 가지고 있다. 각 메서드들에는 미묘한 차이가 있는데, 자세한 사항은 11장과 13장에서 다룬다.

## 문제 5.1 네덜란드 국기 문제
퀵정렬 알고리즘은 다음 과정을 재귀적으로 반복한다. 원소(피벗)를 선택한 후 이보다 작거나 같은 그룹은 왼쪽, 이보다 큰 그룹은 오른쪽에 나오도록 재배치한다. 이를 재귀적으로 반복하면 두 부분 배열은 정렬된다.

피벗의 위치에 따라 부분 배열의 크기가 달라지기 때문에 단순하게 구현한다면, 퀵정렬의 수행시간은 커지고, 함수 호출 스택에는 깊은 복사에 의한 중복된 부분 배열이 많을 것이다. 이를 해결할 한 가지 해법은 같은 배열에서 피벗보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소 순으로 재배열하는 것이다. 이를 네덜란드 국기 나누기라고 부른다.

배열 A와 인덱스 i가 주어졌을 때, A[i](피벗)보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소 순으로 원소를 재배열하는 프로그램을 작성하라.

> 힌트: 퀵정렬에서 피벗을 기준으로 원소를 나누는 방법을 다시 생각해보자.

배열 A의 길이를 n이라고 했을 때, O(n)의 공간을 추가로 사용한다면 이 문제는 굉장히 간단하다. 피벗보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소, 이렇게 세 가지 리스트를 만든 뒤에 이들을 차례대로 A에 넣어 주면 된다. 시간 복잡도는 O(n)이다.

```java
public static enum Color { RED, WHITE, BLUE }

public static void dutchFlagPartition(int pivotIndex, List<Color> A) {
    Color pivot = A.get(pivotIndex);
    // 첫 번째 단계: 피벗보다 작은 원소의 그룹을 구한다.
    for (int i = 0; i < A.size(); ++i) {
        // 작은 원소를 찾는다.
        for (int j = 0; j < A.size(); ++i) {
            if (A.get(j).ordinal() < pivot.ordinal()) {
                Collections.swap(A, i, j);
                break;
            }
        }
    }
    // 두 번째 단계: 피벗보다 큰 원소의 그룹을 구한다.
    for (int i = A.size() - 1; i >= 0 && A.get(i).ordinal() >= pivot.ordinal(); --i) {
        // 큰 원소를 찾는다. 피벗보다 작은 원소에 맞딱뜨리게 되면 즉시 멈춘다.
        // 왜냐하면 윗 단계에서 피벗보다 작은 원소들은 이미 A의 앞쪽으로 옮겨졌기 때문이다.
        for (int j = i; j >= 0 && A.get(j).ordinal() >= pivot.ordinal(); ==j) {
            if (A.get(j).ordinal() > pivot.ordinal()) {
                Collections.swap(A, i, j);
                break;
            }
        }
    }
}
```

공간 복잡도는 O(1)이고, 시간 복잡도는 O(n^2)이다.
이 방법의 시간 복잡도는 효율적이지 못하다. 왜냐하면 첫 번째 단계에서 피벗보다 작은 원소를 추가적으로 탐색할 때 항상 앞에서부터 하기 때문이다. 사실 마지막으로 추가한 위치에서 시작해도 된다.

이제 시간 복잡도를 줄여보자. 단일 패스를 통해 피벗보다 작은 원소를 모두 앞으로 옮길 것이다. 그 다음에는 피벗보다 큰 원소를 모두 뒤로 옮길 것이다. 잘못된 위치에 있는 원소를 발견할 때마다 올바른 위치로 옮기는 작업은 쉽게 수행 가능하다.

```java
public static enum Color {RED, WHITE, BLUE}

public static void dutchFlagPartition(int pivotIndex, List<Color> A) {
    Color pivot = A.get(pivotIndex);
    // 첫 번째 단계: 피벗보다 작은 원소의 그룹을 구한다.
    int smaller = 0;
    for (int i = 0; i < A.size(); ++i) {
        if (A.get(i).ordinal() < pivot.ordinal()) {
            Collections.swap(A, smaller++, i);
        }
    }
    // 두 번째 단계: 피벗보다 큰 원소의 그룹을 구한다.
    int larger = A.size() - 1;
    for (int i = A.size() - 1; i >= 0 && A.get(i).ordinal() >= pivot.ordianl(); --i) {
        if (A.get(i).ordinal() > pivot.ordinal()) {
            Collections.swap(A, larger--, i);
        }
    }
}
```

시간 복잡도는 O(n)이고 공간 복잡도는 O(1)이다.

이번에 소개할 방법은 앞에서 언급한 알고리즘과 유사하다. 가장 큰 차이점은 단일 패스를 통해 피벗보다 작거나, 같거나, 큰 원소들을 분류할 수 있다는 것이다. 구현 방법이 살짝 까다롭지만 수행시간을 좀 더 줄일 수 있다. 부분 배열이 피벗보다 작은 원소(bottom), 피벗과 같은 원소(middle), 미분류 원소(unclassified), 피벗보다 큰 원소(top), 이렇게 네 개 필요하다. 미분류 원소에 있는 원소를 차례대로 피벗과 비교한 뒤에 피벗보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소 중의 하나로 옮긴다.

```java
public static enum Color {RED, WHITE, BLUE}

public static void dutchFlagPartition(int pivotIndex, List<Color> A) {
    Color pivot = A.get(pivotIndex);
    /**
     * 분류할 때마다 다음 불변식을 만족해야 한다.
     * 피벗보다 작은 원소 그룹: A.subList(0, smaller)
     * 피벗과 같은 그룹: A.subList(smaller, equal)
     * 미분류 원소 그룹: A.subList(equal, larger)
     * 피벗보다 큰 원소 그룹: A.subList(larger, A.size())
     */
    int smaller = 0, equal = 0, larger = A.size();
    // 분류되지 않은 원소가 있는 동안 계속 순회한다.
    while (equal < larger) {
        // A.get(equal)는 분류되지 않은 원소를 가리킨다.
        if (A.get(equal).ordinal() < pivot.ordinal()) {
            Collections.swap(A, smaller++, equal++);
        } else if (A.get(equal).ordinal() == pivot.ordinal()) {
            ++equal;
        } else { // A.get(equal) > pivot
            Collections.swap(A, equal, --larger);
        }
    }
}
```

매번 분류되지 않은 원소 그룹의 크기는 1씩 감소할 것이고, 원소를 분류하는 데 걸리는 시간은 O(1)이므로 총 시간 복잡도는 O(n)이 된다. 공간 복잡도는 O(1)이다.

## 문제 5.2 임의의 정수값 증가시키기
십진수 D를 나타낸 배열 A가 주어졌을 때, D+1의 결과를 다시 배열 A에 갱신하는 코드를 작성하라. 예를 들어, 입력으로 <1,2,9>가 주어졌다면, D+1의 결과는 <1,3,0>이 된다. 작성한 알고리즘은 유한 정밀도 산술(finite-precision arithmetic)로 이루어진 프로그램 언어로도 동작해야 한다.

> 힌트: 실제 예제 입력을 사용해서 접근해보자.

무식한 방법을 사용하면, 배열의 숫자를 정수로 바꾼 뒤 값을 1만큼 증가시키고, 그 결과를 다시 배열에 쓰면 된다. 예를 들어 <1,2,9>가 입력으로 주어졌다면 이를 정수 129로 바꾼 뒤 1을 더해서 130으로 만든다. 그 다음 정수 130을 다시 배열에 써서 <1,3,0>을 만들면 된다. 하지만 이 방법은 프로그램 언어에서 정한 정수의 범위에 한해서만 작동하고, 그 범위를 벗어나는 값에 대해선 동작하지 않는다.

배열에 연산을 직접 적용하면 오버플로 문제를 피할 수 있다. 즉, 최하위 숫자부터 덧셈을 한 후 올림수를 넘겨주는 방식을 사용하면 된다. 만약 99 + 1 = 100과 같이 덧셈 결과의 자릿수가 다르다면, 100을 나타내기 위해 세 자리가 필요하지만 입력은 두 자리만 있기 때문에 결과를 저장할 공간이 충분하지 않다.

```java
public static List<Integer> plusOne(List<Integer> A) {
    int n = A.size() - 1;
    A.set(n, A.get(n) + 1);
    for (int i = n; i > 0 && A.get(i) == 10; --i) {
        A.set(i, 0);
        A.set(i - 1, A.get(i - 1) + 1);
    }
    if (A.get(0) == 10) {
        // 최상위 숫자에 올림수가 존재하므로, 결과 저장을 위해 한 자리가 더 필요하다.
        // 깔끔한 방법은 첫 번째 항목을 1로 업데이트하고 배열 끝에는 0을 추가해 주는 것이다.
        A.set(0, 1);
        A.add(0);
    }
    return A;
}
// 마지막에 0을 추가하는 방법은 재미있다!!
// 맨 앞의 요소를 추가하는 것보다 마지막 요소를 추가하는 것이 쉽다는 말이 이 내용이었다.
```

배열의 길이가 n이라고 했을 때 시간 복잡도는 O(n)이 된다.

## 5.3 임의의 두 정수값 곱하기
어떤 애플리케이션에는 임의의 정밀도 산술 연산(arbitrary precision arithmetic)이 필요하기도 하다. 이를 구현하는 한 가지 방법은 배열을 사용하는 것이다. 최상위 숫자를 배열의 가장 앞에 오도록 한다. 음수를 저장하는 배열은 가장 앞자리 숫자가 음수다. 예를 들어 배열 <1,9,3,7,0,7,7,2,1>은 숫자 193707721을 뜻하고, 배열 <-7,6,1,8,3,8,2,5,7,2,8,7>은 숫자 -761838257287을 뜻한다.

정수를 나타내는 두 개의 문자열이 주어졌을 때, 이 둘의 곱셈 결과를 반환하는 함수를 작성하라.

> 힌트: 초등학생 때 배운 곱셈 연산을 그대로 적용해보자.

[Multiply.java](Multiply.java)

m개의 부분 곱셈이 존재하고, 각각 최대 n + 1개의 자릿수와 곱셈을 수행한다. 각 자릿수를 곱하는데 O(1) 시간이 걸리므로 총 시간 복잡도는 O(nm)이 된다.

## 5.4 배열에서 이동하기
주어진 위치 정보를 차례대로 걸어 나가야 하는 보드 게임이 있다. 각 위치에는 음이 아닌 정수값이 들어 있고, 해당 위치에서 최대 그 숫자만큼 앞으로 나아갈 수 있다. 이 게임의 목표는 첫 번째 위치에서 시작해서 마지막 위치에 도달하는 것이다. 예를 들어 배열 A=<3,3,1,0,2,0,1>의 i번째 위치에서는 최대 A[i]만큼 앞으로 나아갈 수 있다. 이 게임에서 승리하는 방법은 다음과 같다. A[0]에서 1만큼 움직여서 A[1]로 간다. 그 다음 3만큼 움직여서 A[4]로 가고, 그 다음 2만큼 움직여서 마지막 위치인 A[6]에 도달한다. A[0] = 3 >= 1, A[1] = 3 >= 3, A[4] = 2 >= 2이므로 모두 유효한 움직임이다. 만약 A가 <3,2,0,0,2,0,1>이라면 A[3]에서 더 이상 나아갈 수 없다.

길이가 n인 배열 A가 주어졌을 때, 배열의 시작점에서 마지막 지점까지 도달할 수 있는지 판단하는 프로그램을 작성하라. 단 A[i]는 i번째 위치에서 나아갈 수 있는 최대 거리를 뜻한다.

> 힌트: 시작점부터 시작해서 각 위치를 잘 분석해보자.

```java
public static boolean canReachEnd(List<Integer> maxAdvanceSteps) {
    int furthestReachSoFar = 0, lastIndex = maxAdvanceSteps.size() - 1;
    for (int i = 0; i <= furthestReachSoFar && furthestReachSoFar < lastIndex; ++i) {
        furthestReachSoFar = Math.max(furthestReachSoFar, i + maxAdvanceSteps.get(i));
    }
    return furthestReachSoFar >= lastIndex;
}
```

## 5.5 정렬된 배열에서 중복 제거하기
정렬된 배열이 입력으로 주어졌을 때 중복된 원소를 모두 제거한 뒤, 비어 있는 공간이 생기지 않도록 유효한 원소들은 모두 왼쪽으로 시프트하는 프로그램을 작성하라. 유효한 원소의 개수를 반환하면 된다. 많은 언어에서 삭제 연산이 라이브러리로 주어지지만 라이브러리를 사용하지 말고 구현하라.

> 힌트: O(n) 시간 복잡도와 O(1) 공간 복도 해법이 존재한다.

배열 A의 길이가 n이라고 하자. 공간을 O(n)만큼 추가로 사용할 수 있다면 해시 테이블을 사용해서 쉽게 구현할 수 있다. 즉, 배열 A를 순회하면서 해시 테이블에 원소를 넣고 확인하면 된다. 새로운 원소는 리스트에 넣은 뒤, 그 리스트를 다시 배열 A에 복사한다.

O(1)을 사용한 무식한 방법도 존재한다. 배열 A를 순회하면서 A[i]와 A[i+1]이 같을 때, i + 2 이후의 원소들을 모두 왼쪽으로 한 칸씩 옮긴다. 모든 원소가 같다면 시프트해야 하는 횟수는 (n - 1) + (n - 2) + ... + 2 + 1이 되고, 시간 복잡도는 O(n^2)이 된다.(n은 배열의 길이를 나타낸다.)

시프팅이 시간 복잡도의 주요 원인이므로 시간 복잡도를 개선하려면 시프팅의 횟수를 줄여야 한다. 배열이 이미 정렬되어 있으므로 반복된 원소들은 연달아 나타난다. 따라서 해당 원소가 이미 나왔었는지 확인하기 위해 자료구조를 보조적으로 사용할 필요는 없다. 모든 부분 배열을 옮기지 않아도 된다. 단순히 원소 하나를 한 번만 옮기면 되나.

앞의 예제 <2,3,5,5,7,11,11,11,13>에서 A[3]을 처리한다고 가정하자. A[3]과 A[2]를 비교해 보면 5가 존재한다는 사실을 알 수 있으므로 A[4]로 넘어간다. A[4]는 새로운 값이므로 삭제해야할 위치인 A[3]으로 옮긴다. 이제 배열은 <2,3,5,7,7,11,11,11,13>이 되고, 삭제해야할 위치는 A[4]가 된다. 그 다음에 A[5]부터 이 과정을 반복한다.

```java
// 삭제 후 유효한 원소의 개수를 반환한다.
public static int deleteDuplicates(List<Integer> A) {
    if (A.isEmpty()) {
        return 0;
    }

    int writeIndex = 1;
    for (int i = 1; i < A.size(); ++i) {
        if (!A.get(writeIndex - 1).equals(A.get(i))) {
            A.set(writeIndex++, A.get(i));
        }
    }
    return writeIndex;
}
```

## 5.6 주식 한 번 사고팔기
특정 기간, 주식 한 주를 사서 되팔았을 때 최대 이익을 얻을 수 있는 알고리즘을 설계하라. 모든 매매는 시작가를 기준으로 하며, 매도는 매입 후에 발생한다.

```java
public static double computeMaxProfit(List<Double> prices) {
    double minPrice = Double.MAX_VALUE, maxProfit = 0.0;
    for (Double price : prices) {
        maxProfit = Math.max(maxProfit, price - minPrice);
        minPrice = Math.min(minPrice, price);
    }
    return maxProfit;
}
```

시간 복잡도는 O(n)이고, 공간 복잡도는 O(1)이다. 여기서 n은 배열의 길이를 말한다.

## 5.7 주식 두 번 사고팔기
이번에는 주식 한 주를 최대 두 번까지 매매할 수 있을 때, 최대 이윤을 구하는 프로그램을 작성하라. 단 두 번쨰 주식은 첫 번째 주식을 판 뒤에 구입할 수 있다.

> 힌트: (i+1)번째 원소를 다루고 있을 때, i개의 원소에서 어떤 정보를 얻어야 하는지 생각해보자.

무식한 방법은 모든 가능한 매수-매도-매수-매도의 조합을 구하는 방식으로 시간 복잡도는 O(n^4)이다. 두 번째 주식은 첫 번째 주식을 매도한 뒤에 구입해야 하므로 배열 A를 두 부분 배열로 나누어 생각해 볼 수 있다. 앞의 O(n) 알고리즘을 두 배열에 적용하면 시간 복잡도를 O(n^2)으로 줄일 수 있다.

이 방법은 비효율적인데, 그 이유는 이전에 계산해 놓은 값을 제대로 이용하지 못하기 때문이다. 이를 개선하는 방법을 생각해보자. A[0,j](j는 1과 n-1 사이의 값)의 최대 이익값을 기록해 놓자. 이제 반대로 순회하면서 A[j, n-1](j는 1과 n-1 사이의 값)의 최대 이익값을 구하면서 동시에 앞에서 저장해 놓은 최대 이익값을 합치면, 현재 이익값을 구하면서 동시에 앞에서 저장해 놓은 최대 이익값을 합치면, 현재 이전에 얻은 최대 이익과 현재 이후에 얻은 최대 이익의 합을 구할 수 있다.

```java
public static double buyAndSellStockTwice(List<Double> prices) {
    double maxTotalProfit = 0.0;
    double minPriceSoFar = Double.MAX_VALUE;
    List<Double> firstBuySellProfits = new ArrayList<>();
    
    // 앞으로 읽는 부분
    // 각 날짜마다, 해당 날짜에 주식을 팔았을 때의 최대 이익 값을 구해 놓는다.
    for (int i = 0; i < prices.size(); ++i) {
        minPriceSoFar = Math.min(minPriceSoFar, prices.get(i));
        maxTotalprofit = Math.max(maxTotalProfit, prices.get(i) - minPriceSoFar);
        firstBuySellProfits.add(maxTotalProfit);
    }

    // 뒤로 읽는 부분
    // 각 날짜마다, 두 번째 주식을 해당 날짜에 샀을 때에 최대 이익 값을 구해 놓는다.
    double maxPriceSoFar = Double.MIN_VALUE;
    for (int i = prices.size() - 1; i > 0; --i) {
        maxPriceSoFar = Math.max(maxPriceSoFar, prices.get(i));
        maxTotalProfit = Math.max(maxTotalProfit, maxPriceSoFar - prices.get(i) + firstBuySellProfits.get(i - 1));
    }
    return maxTotalProfit;
}
```

이 알고리즘의 시간 복잡도는 O(n)이고, 부분 배열의 최대 이윤을 저장하기 위한 배열이 추가적으로 필요하므로 공간 복잡도 또한 O(n)이 된다.

## 5.8 대체 연산
n개의 숫자를 원소로 가지는 배열 A를, B[0] <= B[1] >= B[2] <= B[3] >= B[4] <= B[5] >= ...의 특징을 가지도록, 새로운 배열 B에 재배치하라.

> 힌트: 배열 A를 국지적으로 변경하여 문제를 풀 수 있는가?

간단한 해결책 중 하나는, 배열 A를 정렬한 뒤 아래쪽과 위쪽 절반을 교차로 배치하는 것이다. 또는 배열 A를 정렬한 다음 (A[1], A[2])와 (A[3], A[4])를 서로 교환한다. 나머지 원소들을 대상으로도 이런 작업을 이어간다. 두 개의 접근 방식은 정렬과 동일한 O(n log n)의 시간 복잡도를 가진다.

문제를 조금 더 생각해 보면, 굳이 배열 A를 정렬할 필요 없이, 중간 값 주위의 원소를 재배열한다음, 교차 배치를 하면 된다는 걸 알 수 있다. 중간값 찾기는 문제 11.8의 해법에서 볼 수 있는 것처럼 O(n) 시간에 수행할 수 있다.

최종적으로는, 문제에서 요구하는 순서가 매우 국지적이라는 것을 알아챌 수 있을 것이다. 따라서 중간값을 찾을 필요도 없다. 배열을 순회하면서 i가 짝수고 A[i] > A[i+1]이거나, i가 홀수이면서 A[i] < A[i+1]일 때, A[i]와 A[i+1]을 교환하면 된다.

```java
public static void rearrange(List<Integer> A) {
    for (int i = 0; i < A.size() - 1; ++i) {
        if (
            ( (i % 2) == 0 && A.get(i - 1) < A.get(i) )
         || ( (i % 2) != 0 && A.get(i - 1) > A.get(i) )
        ) {
            Collections.swap(A, i-1, i);
        }
    }
}
```

이 접근 방법은 중간값 찾기에 기반한 해법과 동일하게 O(n)의 시간 복잡도를 가진다. 하지만 메모리에 두 개 이상의 원소를 저장하거나 이전 원소를 읽을 필요가 없는 국지적 변경을 구현하는 것이 훨씬 더 쉽다. 즉, 배열의 원소 전체를 정렬할 필요 없이 하나씩 순회하면서 문제에서 요구하는 순서를 맞춰 주면 된다. 이 해법은 무식하게 풀기를 반복적으로 개선해 나가는 알고리즘 설계의 멋진 예시다.

## 5.9 n보다 작은 모든 소수 나열하기
1보다 큰 자연수 중에서 1과 자기 자신 이외의 수로 나누어 떨어지지 않는 수를 소수라 한다.

양의 정수 n이 주어졌을 때, 1과 n 사이에 있는 모든 소수를 반환하는 프로그램을 작성해 보자. 예를 들어 입력이 18이라면, <2,3,5,7,11,13,17>을 반환해야 한다.

> 힌트: 합성수는 제외한다.

우리는 불 배열을 사용해서 전체 소수를 구할 것이다. 만약 배열의 i번째 값이 참이라면 i는 소수일 것이다. 초기에 2보다 크거나 같은 모든 값은 후보가 된다. 해당 숫자가 소수라고 판명되면 그 숫자를 결과에 추가한다. 첫 번째 소수는 2이다. 이를 결과에 추가한다. 2의 배수는 소수가 될 수 없으므로 해당 후보들은 거짓으로 체크해 놓는다. 다음에 참으로 세팅된 값은 3이다. 1보다 크고 3보다 작은 숫자 중에 이 숫자를 나눌 수 있는 숫자는 없으므로 3도 소수가 된다. 마찬가지로 3을 결과에 추가하고 3의 배수는 후보자 배열에서 제거한다. 후보자 배열의 마지막에 도달할 때까지 이 과정을 반복한다.

예를 들어 n = 10일 때 후보자 배열을 <F,F,T,T,T,T,T,T,T,T,T>로 초기화한다. 여기서 T는 참을 의미하고 F는 거짓을 의미한다.(0과 1은 소수가 아니므로 거짓으로 초기화한다.) 2번 인덱스부터 시작한다. 해당 값이 참이므로 2를 소수 리스트에 추가하고 2의 배수를 걸러 낸다. 이제 배열은 <F,F,T,T,F,F,F,T,F,T,F>가 된다. 그 다음 참인 숫자는 3이므로 소수 리스트에 추가하고 3의 배수들은 걸러 낸다. 이제 배열은 <F,F,T,T,F,T,F,T,F,F,F>가 된다. 그 다음 참인 숫자는 5와 7이고, 이들의 배수는 10보다 크므로 더 이상 걸러 낼 숫자가 없다.

```java
// n이 주어졌을 때 n보다 작거나 같은 모든 소수를 반환하라.
public static List<Integer> generatePrimes(int n) {
    List<Integer> primes = new ArrayList<>();
    // isPrime.get(p)는 p가 소수인지 아닌지를 나타낸다. 초기에는 0과 1을 제외한
    // 나머지를 모두 참으로 세팅한다. 그 다음에 소수가 아닌 숫자를 걸러 낸다.
    List<Boolean> isPrime = new ArrayList<>(Collections.nCopies(n + 1, true));
    isPrime.set(0, false);
    isPrime.set(1, false);
    for (int p = 2; p <= n; ++p) {
        if (isPrime.get(p)) {
            primes.add(p);
            // p의 배수를 걸러 낸다.
            for (int j = p; j <= n; j += p) {
                isPrime.set(j, false);
            }
        }
    }
    return primes;
}
```

휴리스틱을 바탕으로 모든 숫자로 나누어 보는 방식보다 체로 걸러 내는 방식이 더 효율적이다. p의 배수를 걸러 내는 이 방법의 시간 복잡도는 n/p에 비례한다. 따라서 전체 시간 복잡도는 O(n/2 + n/3 + n/5 + n/7 + n/11 + ...)가 된다. 명백하진 않지만, 이 합은 점근적으로 n log n으로 수렴하고, 따라서 시간 복잡도의 상한은 O(n log n)이 된다. 공간 복잡도는 배열 P의 크기인 O(n)이 된다.

소수 판정을 할 때마다 O(sqrt(n))의 시간이 필요하기 때문에 모든 숫자로 나누어 보는 방법의 시간 복잡도는 O(n^(3/2))가 된다. 대부분의 숫자는 소수가 아니고 보통 소수 판정을 하는 데 오래 걸리지 않기 때문에 실제 시간 복잡도는 평균적으로 이보다 적다. 모든 숫자로 나누어 보는 첫 번째 방법의 시간 복잡도는 O(n^(3/2)/(log n)^2))이라고 알려져 있다. 여전히 두 번째 방법이 더 빠르다.

수행시간을 개선하기 위해 p가 아닌 p^2의 배수부터 제거해 나가도 된다. 모든 kp(k < p)의 합성수에 대해서는 이전에 이미 체크했기 때문이다. 짝수는 미리 제거함으로써 공간을 줄일 수 있다.

```java
// 와 무슨 말인지 모르겠다.
public static List<Integer> generatePrimes(int n) {
    final int size = (int)Math.floor(0.5 * (n - 3)) + 1;
    List<Integer> primes = new ArrayList<>();
    primes.add(2);
    // isPrimes.get(i)는 (2i + 3)이 소수인지 아닌지 알려준다.
    // 초기에는 전부 참으로 세팅한다. 그 다음에 소수가 아닌 숫자들을 지워 나간다.
    List<Boolean> isPrime = new ArrayList<>(Collections.nCopies(size, true));
    for (int i = 0; i < size; ++i) {
        if (isPrime.get(i)) {
            int p =((i * 2) + 3);
            primes.add(p);

            // p^2부터 배수를 제거해 나간다. 그 값은 (4i^2 + 12i + 9)이 된다.
            // 이 값의 isPrime에서의 인덱스는 (2i^2 + 6i + 3)이다.
            // 왜냐하면 isPrime.get(i)이 2i + 3을 의미하기 때문이다.
            //
            // p^2가 오버플로될 수 있기 때문에 j는 long 자료형을 사용해야 한다.
            for (long j = ((i * i) * 2) + 6 * i + 3; j < size; j += p) {
                isPrime.set((int)j, false);
            }
        }
    }
    return primes;
}
```

## 5.10 배열 안의 원소로 순열 구하기
순열이란 일련의 순서로 나열된 원소들을 새로운 순서로 재배열하는 것을 말한다. 예를 들어, <a,b,c,d>는 <b,a,d,c>,<d,a,b,c>와 같이 24개의 서로 다른 순열이 존재한다.

배열 P를 이용해 순열을 나타낼 수 있는데, 예를 들면 P[i]는 i 원소의 새로운 위치가 된다. 즉, 배열 <2,0,1,3>은 0번 원소는 2번으로, 1번 원소는 0번으로, 그리고 3번 원소는 제자리에 놓는다는 뜻이다. 이 배열을 실제 배열의 객체를 재배치하는 데 적용할 수도 있다. 예를 들어 순열 <2,0,1,3>을 배열 A = <a,b,c,d>에 적용하면 <b,c,a,d>가 된다.

길이가 n인 배열 A와 순열 P가 주어졌을 때, P를 A에 적용해 보라.

> 힌트: 모든 순열은 순환 순열의 집합 안에 있다고 말할 수 있다. 이미 순환된 원소를 어떻게 나타낼 수 있을까?

만약 추가 공간을 사용할 수 있다면 순열 배열을 주어진 배열에 적용하는 것은 간단하다. 주어진 배열과 길이가 같은 새로운 배열 B를 사용해서 모든 i에 대해 B[P[i]] = A[i]로 값을 할당한 뒤 B의 결과를 A로 복사하면 된다. 시간 복잡도는 O(n)이고 공간 복잡도는 O(n)이다.

공간 복잡도는 개선할 수 있는 핵심은 순열을 보다 간략한 구조로 분해한 뒤 하나씩 순서대로 처리하는 것이다. 예를 들어, 순열 <3,2,1,0>를 A = <a,b,c,d>에 적용하면, 0(a)은 3번 인덱스로, 3(d)는 0번 인덱스로 옮긴다. 계속해서 1(b)은 2번 인덱스로, 2(c)는 1번 인덱스로 옮겨진다. 순열 배열에 따라 모든 원소를 다 옮긴 결과는 <d,c,b,a>가 된다.

이 예제를 일반화 하면 다음과 같다. 모든 순열은 독립적인 순환 순열의 컬렉션과 같고, 이를 통해 모든 원소가 순환 순열 내에서 재배치가 이루어진다.

이 사실은 굉장히 중요하다. 왜냐하면 순환 순열 내에서는 상수 크기의 공간으로 원소를 하나씩 차례대로 재배치할 수 있고, 결국 순환 순열의 컬렉션으로 이루어진 순열 또한 상수만큼의 공간을 이용해서 모든 원소를 재배치할 수 있기 때문이다. 따라서 이 문제를 풀기 위해서는 순열을 구성하는 분리된 사이클을 찾아야 한다. 원소 배열에 불값을 저장하면 쉽게 사이클을 찾을 수 있다.

O(n) 공간을 추가로 사용하지 않을 수 있는 한 가지 방법은 순환 배열에 음수를 사용하는 것이다. 즉 P[i]를 사이클에 추가한 뒤에는 n을 빼서 음수로 만들어 준다. 그 뒤 P[i]가 음수라면 해당 숫자는 사이클에 속해 있다고 해석하면 된다.

예를 들어 <3,1,2,0>을 생각해 보자. 먼저 첫 번째 숫자인 3부터 시작한다. A[0]을 A[3]으로 옮기고 기존 A[3]을 다른 곳에 저장해 둔다. 이제 순환 배열은 <-1,1,2,0>이 된다. A[3]을 A[0]에 옮긴다. P[0]은 음수이므로 0번에서 시작한 사이클이 끝났음을 알 수 있다. 이제 순환 배열은 <-1,1,2,-4>가 된다. P[1]은 음수가 아니므로 해당 숫자는 아직 사이클에 속해 있지 않다는 것을 알 수 있다. 이와 같은 과정을 계속해 나가면 된다.

```java
public static void applyPermutation(List<Integer> perm, List<Integer> A) {
    for (int i = 0; i < A.size(); ++i) {
        // perm.get(i)가 음수인지 확인하면 i번째 인덱스가 이미 사이클 내에 속해 있는지 알 수 있다.
        int next = i;
        while (perm.get(next) >= 0) {
            Collections.swap(A, i, perm.get(next));
            int temp = perm.get(next);
            // perm에 있는 값에서 perm.size()을 빼서 해당 값을 음수로 만든다.
            // 이렇게 하면 해당 값은 이미 사이클에 속해 있다는 말이 된다.
            perm.set(next, perm.get(next) - perm.size());
            next = temp;
        }

        // perm을 다시 갱신한다.
        for (int i = 0; i < perm.size(); ++i) {
            perm.set(i, perm.get(i) + perm.size());
        }
    }
}
```

이 프로그램의 시간 복잡도는 O(n)이 된다. 순열 배열을 임시적으로 수정할 수 있다면 공간 복잡도를 O(1)로 개선할 수 있다.

만약 부호 비트를 사용할 수 있다면 길이가 n인 불 배열을 사용해서 i번째 원소가 이미 처리됐는지 확인할 수 있다. 혹은 배열을 왼쪽에서 오른쪽으로 순회하면서 현재 위치가 사이클에서 가장 왼쪽에 있을 경우에만 사이클 찾는 알고리즘을 적용하면 된다.

```java
public static void applyPermutaion(List<Integer> perm, List<Integer> A) {
    for (int i = 0; i < A.size(); ++i) {
        // 사이클을 순회하면서 i가 최소 원소인지 확인한다.
        boolean isMin = true;
        int j = perm = perm.get(i);
        while (j != i) {
            if (j < i) {
                isMin = false;
                break;
            }
            j = perm.get(j);
        }

        if (isMin) {
            cyclicPermutation(i, perm, A);
        }
    }
}

private static void cyclicPermutation(int start, List<Integer> perm, List<Integer> A) {
    int i = start;
    int temp = A.get(start);
    do {
        int nextI = perm.get(i);
        int nextTemp = A.get(nextI);
        A.set(nextI, temp);
        i = nextI;
        temp = nextTemp;
    } while (i != start);
}
```

현재 위치가 가장 왼쪽에 위치한 원소인지 확인하려면 사이클을 한 번 더 돌아야 하므로 시간 복잡도는 O(n^2)으로 증가한다.

## 5.11 다음 순열 구하기
n개의 원소로 만들 수 있는 순열의 개수는 n!이다. 이들은 사전 순으로 정렬(dictionary ordering)이 가능하다. 순열 p와 q의 순서는 다음과 같이 결정한다. 0번째 인덱스부터 시작해서 처음으로 다른 값이 q보다 p가 더 작다면 p가 q의 앞에 온다. 예를 들어 <2,0,1>은 <2,1,0>보다 앞에 온다. 순열 <0,1,2>가 사전 순으로 배열했을 때 가장 앞에 놓이게 되고 <2,1,0>이 가장 마지막에 놓이게 된다.

어떤 순열이 주어졌을 때 다음 순열을 구하는 함수를 작성하라. 단, 순열의 순서는 사전 순으로 정렬되어 있다. 주어진 순열이 가장 마지막 순열이라면 빈 순열을 반환하면 된다. 예를 들어 p = <1,0,3,2>의 다음 순열은 <1,2,0,3>이다. 입력이 <3,2,1,0>이라면 <>을 반환한다.

> 힌트: 실제 예제를 사용해서 생각해보자.

무식한 방법은 입력과 갈이가 같은 모든 순열을 사전 순으로 나열한 뒤 입력 순열 바로 다음에 등장하는 순열을 찾는 것이다. 엄청난 크기의 시간 및 공간 복잡도를 고려하지 않는다고 하더라도 길이가 n인 모든 순열을 계산하는 건 단순한 문제가 아니다.

순열이 사전 순으로 정렬되어 있으므로, 이 문제를 해결하는 핵심은 순열의 크기를 가능한 조금씩 증가시키는 것이다. 자동차에서 주행 기록계를 증가시키는 것도 이와 비슷한 유형이라고 볼 수 있는데, 가장 큰 차이점은 이 문제에서는 순열의 값이 아닌 순서를 재배치한다는 데 있다. 순열 <6,2,1,5,4,3,0>을 생각해보자.

일단 순열의 접미사(suffix) 중에서 가장 긴 감소 순열(앞의 예제에서는 <5,4,3,0>)을 찾는다. 이 순열은 이미 사전 순으로 가장 마지막에 있는 순열이므로 그 다음 순열이 존재하지 않는다.

그 후 이 순열 바로 앞에 위치한 원소 e(앞의 예제에서는 1)를 살펴보자(만약 이런 e가 존재하지 않는다면, 즉 가장 긴 감소 순열이 <n-1, n-2, ... 2,1,0>이라면, 이 순열이 사전 순으로 가장 마지막 순열이므로 다음 순열은 존재하지 않는다).

원소 e는 접미사 순열의 원소 중 적어도 하나보다는 작다(적어도 원소 e 바로 다음 원소는 e보다 크다). e보다 큰 접미사 순열의 원소 중에서 가장 작은 원소를 s라 하자. s와 e를 맞바꾼다면 전체 순열의 접두사(prefix)를 최소한으로 증가시킨 꼴이 된다.

이 예제에서는, e가 1이고 s는 3이므로, 이 둘을 맞바꾸면 <6,2,3,5,4,1,0>이 된다.

아직 끝나지 않았다. 순열의 접두사는 현재 순열보다 큰 순열 중에서 가장 작은 순열이라고 말할 수 있지만 접미사는 아직 가장 작은 순열이 아니다. 가장 작은 접미사 순열은 정렬을 통해 얻을 수 있다. 앞의 예제에서는 <0,1,4,5>가 된다.

최적화 측면에서 접미사 순열은 이미 감소 순열이고, s와 e를 맞바꾸더라도 여전히 감소 순열이므로, 접미사 순열에 복잡한 정렬 알고리즘을 대입할 필요가 없다. 감소 순열을 단순히 거꾸로 뒤집으면 가장 작은 접미사 순열을 만들 수 있다.

이 알고리즘을 일반화하면 다음과 같다.

1. p[k] < p[k+1]이면서 k 이후의 접미사가 감소 순열인 k를 찾는다.
2. p[l] > p[k] 중에서 가장 작은 p[l]을 찾는다.(p[k] < p[k+1]이므로 l은 항상 존재한다.)
3. p[l]과 p[k]를 맞바꾼다. (이 둘을 맞바꾸더라도 k 이후의 접미사 순열은 여전히 감소 순열이다.)
4. k 이후의 접미사 순열을 뒤집어 준다.

```java
public static List<Integer> nextPermutation(List<Integer> perm) {
    // 오른쪽에서 바로 다음 항목보다 작은 첫 번째 항목을 찾는다.
    int inversionPoint = perm.size() - 2;
    while (inversionPoint >= 0 && perm.get(inversionPoint) >= perm.get(inversionPoint + 1)) {
        --inversionPoint;
    }
    if (inversionPoint == -1) {
        return Collections.emptyList(); // perm이 마지막 순열이다.
    }

    // inversionPoint 이후의 엔트리 중에서 perm.get(inversionPoint)보다 크지만
    // 그중에서 가장 작은 엔트리를 맞바꾼다.
    // perm의 항목은 inversionPoint 이후 감소하므로 역순으로 검색하면
    // perm.get(inversionPoint)보다 큰 첫 번째 항목이 스왑할 항목이다.
    for (int i = perm.size() - 1; i > inversionPoint; --i) {
        if (perm.get(i) > perm.get(inversionPoint)) {
            Collections.swap(perm, inversionPoint, i);
            break;
        }
    }

    // perm의 항목은 inversionPoint 후에 감소 순서로 나타나야 하므로,
    // 단순히 이 순열을 뒤집음으로써 사전 순으로 가장 작은 순열을 만들 수 있다.
    Collections.reverse(perm.subList(inversionPoint + 1, perm.size()));
    return perm;
}
```

이 알고리즘은 상수 번 읽는다. 따라서 전체 시간 복잡도는 O(n)이 되고, 사용하는 지역 변수의 개수가 상수이므로 복잡도는 O(1)이 된다.

