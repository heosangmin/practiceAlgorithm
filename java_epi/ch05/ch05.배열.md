# 5. 배열

- 배열에서는 A[i]의 객체를 읽거나 갱신하는데 O(1)의 시간이 걸린다.
- 배열에서의 삽입 연산은 배열 크기를 늘리는 작업이 필요하다. 즉, 배열의 크기만큼 추가 메모리 공간을 할당하고, 기존의 객체를 새로운 공간에 모두 복사해서 넣어야 한다. 이 때문에 삽입 연산은 최악의 경우의 시간 복잡도가 증가한다. 하지만 배열의 크기를 늘릴 떄 기존보다 상수 배 크게 늘린다면, 배열 복사 작업이 자주 일어나지 않으므로 삽입 연산의 평균 시간 복잡도는 상수 시간이 된다.
- 배열에서 원소를 삭제하면, 그 뒤에 있는 객체를 왼쪽으로 한 칸씩 옮겨야 한다. i번째 인덱스의 원소를 삭제할 떄 소요되는 시간 복잡도는, 배열의 길이가 n일 떄, O(n-1)이 된다.

## 배열 부트캠프

정수 배열이 주어졌을 때 짝수가 먼저 나오도록 재배열해 보라. 이 문제는 배열의 길이가 n이라고 했을 때, 추가 공간을 O(n)만큼 사용하면 쉽게 풀 수 있다. 그런데 추가 공간을 사용하지 않고도 풀 수 있다.

배열에서 양쪽 끝을 손쉽게 접근할 수 있는 이점을 떠올려 보자. 이 문제에서는 배열을 짝수, 정해지지 않은 숫자, 홀수의 세 가지 부분 배열로 나눌 것이다. 초기에는 짝수와 홀수 부분 배열은 비어 있고, 정해지지 않은 숫자는 전체 배열이 될 것이다. 정해지지 않은 숫자를 하나씩 순회하면서 원소를 홀수 혹은 짝수 부분 배열로 옮긴다. 짝수와 홀수 부분 배열의 크기는 증가하고 정해지지 않은 숫자 부분 배열의 크기는 감소한다.

```java
// 달리 말하면 짝수, 홀수 순으로 정렬한다고 할 수 있겠다.
public static void evenOdd(List<Integer> A) {
    int nextEven = 0, nextOdd = A.size() - 1; 
    while (nextEven < nextOdd) {
        if (A.get(nextEven) % 2 == 0) {
            nextEven++;
        } else {
            Collections.swap(A, nextEven, nextOdd--);
        }
    }
}
```

추가 공간 복잡도는 O(1)이다. 인덱스 저장과 스왑을 위해 몇 개의 변수를 사용했을 뿐이다. 각 단계마다 수행한 연산 횟수가 상수이므로 시간 복잡도는 O(n)이 된다.

## 배열 문제를 풀기 전 꼭 알고 있어야 할 내용

- 배열과 관련된 문제는 무식하게 접근하면 O(n) 공간을 사용해서 풀 수도 있다. 그런데 공간 복잡도를 O(1)로 **줄이려면** 풀기 상당히 어려워질 수 있다. [문제 5.1]
- 배열을 앞에서부터 채워 나가면 오래 걸리지만, **뒤에서부터 채워 나가면** 빠를 수도 있다. [문제 5.2]
- 원소를 삭제해서 다른 원소들을 왼쪽으로 옮기기보다는 삭제할 원소에 덮어쓰는 방법이 나을 수도 있다. [문제 5.5]
- 배열로 표현된 정수를 다룰 때에는, **배열의 끝에서부터 숫자를 처리**해 나가는 방법을 고려해 보라. 혹은 배열을 뒤집어서 **최하위 숫자를 배열의 첫 번째 위치에 오도록** 만들 수도 있다. [문제 5.3]
- **부분 배열**을 사용하는 코드를 작성하는 데 익숙해지라. [문제 5.11]
- 배열을 사용할 때 **인덱스를 잘못 사용하는 실수**를 하기가 굉장히 쉽다. [문제 5.4, 문제 5.18]
- 실제 반환할 때까지 배열의 초기 상태를 **유지**(정렬, 균등한 원소 유지 등)하지 않아도 된다. [문제 5.5]
- 원소의 분포를 미리 알고 있을 때 배열은 좋은 자료구조가 될 수 있다. 예를 들어 길이가 W인 불 배열을 사용하면 숫자 집합{0,1,...W-1}의 **부분 집합**을 쉽게 표현할 수 있다. ({1,2,3,...,n}의 부분 집합을 불 배열로 표현할 때 인덱스를 간단히 하기 위해 크기가 n + 1인 배열을 사용해도 된다.) [문제 5.9]
- 2차원 배열을 사용할 때는 **열과 행을 동시에 처리하는 로직**을 사용하라. [문제 5.18]
- 가끔은 문제의 **세부 사항을 따라 해 보는 것**이 문제를 분석적으로 푸는 것보다 쉬울 수 있다. 예를 들어 나선형으로 채워진 n*n 배열의 i번째 원소를 찾는 수식을 작성하는 것보다 첫 번째 원소부터 나선형으로 하나씩 따라가면서 i번째 원소를 찾는 게 더 쉬울 수 있다. [문제 5.18, 문제 5.20]

## 배열 라이브러리 이해하기

Java의 기본 배열은 크기가 정해져 있다. 따라서 Java의 Arrays 유틸리티에 친숙해져야 기본 배열형을 사용한 작업을 단순화할 수 있다. ArrayList를 사용하면 배열의 크기를 동적으로 바꿀 수 있으므로 기본 배열을 대신해 쓰기 좋다. ArrayList는 유연하며, API를 많이 가지고 있다. 그 외에도 기본 배열형에 대해 더 알고 싶다면 7장에서 설명하는 List, ArrayList, Collections를 읽어 보길 바란다.

- 배열을 할당하고 초기화하는 문법을 알고 있어야 한다(예를 들어 `new int[]{1,2,3}`).
- 2차원 배열을 어떻게 초기화하는지 알고 있어야 한다. `new Integer[3][]`은 행의 개수가 3개인 배열을 만들고 각 행은 반드시 명시적으로 할당되어야 한다.
- length를 통해 배열의 길이를 알 수 있다. Collections에는 size() 메서드가 있고, String에는 length() 메서드가 있다.
- Array 클래스는 몇 가지 정적 유틸리티 메서드를 가지고 있다. asList(), binarySearch(A, 641), copyOf(A), copyOfRange(A, 1, 5), equals(A, B), fill(A, 42), find(A, 28), sort(A), sort(A, cmp), toString() 메서드 모두 중요하다.
  - 이 메서드들의 변종에 대해서도 이해하고 있어야 한다. 예를 들어 어떻게 부분 배열을 복사할 수 있는지 알고 있어야 한다.
  - 배열의 동등성을 확인하거나 해싱을 할 때, '깊은(deep)'의 의미를 알고 있어야 한다. 예를 들어 깊은(deep) 동등성은 '객체'에 대한 동등성을 나타내고, 얕은(shallow) 동등성은 '참조값'에 대한 동등성을 나타낸다.

  Arrays와 Collections 모두 binarySearch()와 sort() 메서드를 가지고 있다. 각 메서드들에는 미묘한 차이가 있는데, 자세한 사항은 11장과 13장에서 다룬다.

## 문제 5.1 네덜란드 국기 문제

퀵정렬 알고리즘은 다음 과정을 재귀적으로 반복한다. 원소(피벗)를 선택한 후 이보다 작거나 같은 그룹은 왼쪽, 이보다 큰 그룹은 오른쪽에 나오도록 재배치한다. 이를 재귀적으로 반복하면 두 부분 배열은 정렬된다.

피벗의 위치에 따라 부분 배열의 크기가 달라지기 때문에 단순하게 구현한다면, 퀵정렬의 수행시간은 커지고, 함수 호출 스택에는 깊은 복사에 의한 중복된 부분 배열이 많을 것이다. 이를 해결할 한 가지 해법은 같은 배열에서 피벗보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소 순으로 재배열하는 것이다. 이를 네덜란드 국기 나누기라고 부른다.

배열 A와 인덱스 i가 주어졌을 때, A[i](피벗)보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소 순으로 원소를 재배열하는 프로그램을 작성하라.

> 힌트: 퀵정렬에서 피벗을 기준으로 원소를 나누는 방법을 다시 생각해보자.

배열 A의 길이를 n이라고 했을 때, O(n)의 공간을 추가로 사용한다면 이 문제는 굉장히 간단하다. 피벗보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소, 이렇게 세 가지 리스트를 만든 뒤에 이들을 차례대로 A에 넣어 주면 된다. 시간 복잡도는 O(n)이다.

```java
public static enum Color { RED, WHITE, BLUE }

public static void dutchFlagPartition(int pivotIndex, List<Color> A) {
    Color pivot = A.get(pivotIndex);
    // 첫 번째 단계: 피벗보다 작은 원소의 그룹을 구한다.
    for (int i = 0; i < A.size(); ++i) {
        // 작은 원소를 찾는다.
        for (int j = 0; j < A.size(); ++i) {
            if (A.get(j).ordinal() < pivot.ordinal()) {
                Collections.swap(A, i, j);
                break;
            }
        }
    }
    // 두 번째 단계: 피벗보다 큰 원소의 그룹을 구한다.
    for (int i = A.size() - 1; i >= 0 && A.get(i).ordinal() >= pivot.ordinal(); --i) {
        // 큰 원소를 찾는다. 피벗보다 작은 원소에 맞딱뜨리게 되면 즉시 멈춘다.
        // 왜냐하면 윗 단계에서 피벗보다 작은 원소들은 이미 A의 앞쪽으로 옮겨졌기 때문이다.
        for (int j = i; j >= 0 && A.get(j).ordinal() >= pivot.ordinal(); ==j) {
            if (A.get(j).ordinal() > pivot.ordinal()) {
                Collections.swap(A, i, j);
                break;
            }
        }
    }
}
```

공간 복잡도는 O(1)이고, 시간 복잡도는 O(n^2)이다.
이 방법의 시간 복잡도는 효율적이지 못하다. 왜냐하면 첫 번째 단계에서 피벗보다 작은 원소를 추가적으로 탐색할 때 항상 앞에서부터 하기 때문이다. 사실 마지막으로 추가한 위치에서 시작해도 된다.

이제 시간 복잡도를 줄여보자. 단일 패스를 통해 피벗보다 작은 원소를 모두 앞으로 옮길 것이다. 그 다음에는 피벗보다 큰 원소를 모두 뒤로 옮길 것이다. 잘못된 위치에 있는 원소를 발견할 때마다 올바른 위치로 옮기는 작업은 쉽게 수행 가능하다.

```java
public static enum Color {RED, WHITE, BLUE}

public static void dutchFlagPartition(int pivotIndex, List<Color> A) {
    Color pivot = A.get(pivotIndex);
    // 첫 번째 단계: 피벗보다 작은 원소의 그룹을 구한다.
    int smaller = 0;
    for (int i = 0; i < A.size(); ++i) {
        if (A.get(i).ordinal() < pivot.ordinal()) {
            Collections.swap(A, smaller++, i);
        }
    }
    // 두 번째 단계: 피벗보다 큰 원소의 그룹을 구한다.
    int larger = A.size() - 1;
    for (int i = A.size() - 1; i >= 0 && A.get(i).ordinal() >= pivot.ordianl(); --i) {
        if (A.get(i).ordinal() > pivot.ordinal()) {
            Collections.swap(A, larger--, i);
        }
    }
}
```

시간 복잡도는 O(n)이고 공간 복잡도는 O(1)이다.

이번에 소개할 방법은 앞에서 언급한 알고리즘과 유사하다. 가장 큰 차이점은 단일 패스를 통해 피벗보다 작거나, 같거나, 큰 원소들을 분류할 수 있다는 것이다. 구현 방법이 살짝 까다롭지만 수행시간을 좀 더 줄일 수 있다. 부분 배열이 피벗보다 작은 원소(bottom), 피벗과 같은 원소(middle), 미분류 원소(unclassified), 피벗보다 큰 원소(top), 이렇게 네 개 필요하다. 미분류 원소에 있는 원소를 차례대로 피벗과 비교한 뒤에 피벗보다 작은 원소, 피벗과 같은 원소, 피벗보다 큰 원소 중의 하나로 옮긴다.

```java
public static enum Color {RED, WHITE, BLUE}

public static void dutchFlagPartition(int pivotIndex, List<Color> A) {
    Color pivot = A.get(pivotIndex);
    /**
     * 분류할 때마다 다음 불변식을 만족해야 한다.
     * 피벗보다 작은 원소 그룹: A.subList(0, smaller)
     * 피벗과 같은 그룹: A.subList(smaller, equal)
     * 미분류 원소 그룹: A.subList(equal, larger)
     * 피벗보다 큰 원소 그룹: A.subList(larger, A.size())
     */
    int smaller = 0, equal = 0, larger = A.size();
    // 분류되지 않은 원소가 있는 동안 계속 순회한다.
    while (equal < larger) {
        // A.get(equal)는 분류되지 않은 원소를 가리킨다.
        if (A.get(equal).ordinal() < pivot.ordinal()) {
            Collections.swap(A, smaller++, equal++);
        } else if (A.get(equal).ordinal() == pivot.ordinal()) {
            ++equal;
        } else { // A.get(equal) > pivot
            Collections.swap(A, equal, --larger);
        }
    }
}
```

매번 분류되지 않은 원소 그룹의 크기는 1씩 감소할 것이고, 원소를 분류하는 데 걸리는 시간은 O(1)이므로 총 시간 복잡도는 O(n)이 된다. 공간 복잡도는 O(1)이다.

## 문제 5.2 임의의 정수값 증가시키기

십진수 D를 나타낸 배열 A가 주어졌을 때, D+1의 결과를 다시 배열 A에 갱신하는 코드를 작성하라. 예를 들어, 입력으로 <1,2,9>가 주어졌다면, D+1의 결과는 <1,3,0>이 된다. 작성한 알고리즘은 유한 정밀도 산술(finite-precision arithmetic)로 이루어진 프로그램 언어로도 동작해야 한다.

> 힌트: 실제 예제 입력을 사용해서 접근해보자.

무식한 방법을 사용하면, 배열의 숫자를 정수로 바꾼 뒤 값을 1만큼 증가시키고, 그 결과를 다시 배열에 쓰면 된다. 예를 들어 <1,2,9>가 입력으로 주어졌다면 이를 정수 129로 바꾼 뒤 1을 더해서 130으로 만든다. 그 다음 정수 130을 다시 배열에 써서 <1,3,0>을 만들면 된다. 하지만 이 방법은 프로그램 언어에서 정한 정수의 범위에 한해서만 작동하고, 그 범위를 벗어나는 값에 대해선 동작하지 않는다.

배열에 연산을 직접 적용하면 오버플로 문제를 피할 수 있다. 즉, 최하위 숫자부터 덧셈을 한 후 올림수를 넘겨주는 방식을 사용하면 된다. 만약 99 + 1 = 100과 같이 덧셈 결과의 자릿수가 다르다면, 100을 나타내기 위해 세 자리가 필요하지만 입력은 두 자리만 있기 때문에 결과를 저장할 공간이 충분하지 않다.

```java
public static List<Integer> plusOne(List<Integer> A) {
    int n = A.size() - 1;
    A.set(n, A.get(n) + 1);
    for (int i = n; i > 0 && A.get(i) == 10; --i) {
        A.set(i, 0);
        A.set(i - 1, A.get(i - 1) + 1);
    }
    if (A.get(0) == 10) {
        // 최상위 숫자에 올림수가 존재하므로, 결과 저장을 위해 한 자리가 더 필요하다.
        // 깔끔한 방법은 첫 번째 항목을 1로 업데이트하고 배열 끝에는 0을 추가해 주는 것이다.
        A.set(0, 1);
        A.add(0);
    }
    return A;
}
// 마지막에 0을 추가하는 방법은 재미있다!!
// 맨 앞의 요소를 추가하는 것보다 마지막 요소를 추가하는 것이 쉽다는 말이 이 내용이었다.
```

배열의 길이가 n이라고 했을 때 시간 복잡도는 O(n)이 된다.

## 5.3 임의의 두 정수값 곱하기

어떤 애플리케이션에는 임의의 정밀도 산술 연산(arbitrary precision arithmetic)이 필요하기도 하다. 이를 구현하는 한 가지 방법은 배열을 사용하는 것이다. 최상위 숫자를 배열의 가장 앞에 오도록 한다. 음수를 저장하는 배열은 가장 앞자리 숫자가 음수다. 예를 들어 배열 <1,9,3,7,0,7,7,2,1>은 숫자 193707721을 뜻하고, 배열 <-7,6,1,8,3,8,2,5,7,2,8,7>은 숫자 -761838257287을 뜻한다.

정수를 나타내는 두 개의 문자열이 주어졌을 때, 이 둘의 곱셈 결과를 반환하는 함수를 작성하라.

> 힌트: 초등학생 때 배운 곱셈 연산을 그대로 적용해보자.

[Multiply.java](Multiply.java)

m개의 부분 곱셈이 존재하고, 각각 최대 n + 1개의 자릿수와 곱셈을 수행한다. 각 자릿수를 곱하는데 O(1) 시간이 걸리므로 총 시간 복잡도는 O(nm)이 된다.

## 5.4 배열에서 이동하기

주어진 위치 정보를 차례대로 걸어 나가야 하는 보드 게임이 있다. 각 위치에는 음이 아닌 정수값이 들어 있고, 해당 위치에서 최대 그 숫자만큼 앞으로 나아갈 수 있다. 이 게임의 목표는 첫 번째 위치에서 시작해서 마지막 위치에 도달하는 것이다. 예를 들어 배열 A=<3,3,1,0,2,0,1>의 i번째 위치에서는 최대 A[i]만큼 앞으로 나아갈 수 있다. 이 게임에서 승리하는 방법은 다음과 같다. A[0]에서 1만큼 움직여서 A[1]로 간다. 그 다음 3만큼 움직여서 A[4]로 가고, 그 다음 2만큼 움직여서 마지막 위치인 A[6]에 도달한다. A[0] = 3 >= 1, A[1] = 3 >= 3, A[4] = 2 >= 2이므로 모두 유효한 움직임이다. 만약 A가 <3,2,0,0,2,0,1>이라면 A[3]에서 더 이상 나아갈 수 없다.

길이가 n인 배열 A가 주어졌을 때, 배열의 시작점에서 마지막 지점까지 도달할 수 있는지 판단하는 프로그램을 작성하라. 단 A[i]는 i번째 위치에서 나아갈 수 있는 최대 거리를 뜻한다.

> 힌트: 시작점부터 시작해서 각 위치를 잘 분석해보자.

```java
public static boolean canReachEnd(List<Integer> maxAdvanceSteps) {
    int furthestReachSoFar = 0, lastIndex = maxAdvanceSteps.size() - 1;
    for (int i = 0; i <= furthestReachSoFar && furthestReachSoFar < lastIndex; ++i) {
        furthestReachSoFar = Math.max(furthestReachSoFar, i + maxAdvanceSteps.get(i));
    }
    return furthestReachSoFar >= lastIndex;
}
```

## 5.5 정렬된 배열에서 중복 제거하기

정렬된 배열이 입력으로 주어졌을 때 중복된 원소를 모두 제거한 뒤, 비어 있는 공간이 생기지 않도록 유효한 원소들은 모두 왼쪽으로 시프트하는 프로그램을 작성하라. 유효한 원소의 개수를 반환하면 된다. 많은 언어에서 삭제 연산이 라이브러리로 주어지지만 라이브러리를 사용하지 말고 구현하라.

> 힌트: O(n) 시간 복잡도와 O(1) 공간 복도 해법이 존재한다.

배열 A의 길이가 n이라고 하자. 공간을 O(n)만큼 추가로 사용할 수 있다면 해시 테이블을 사용해서 쉽게 구현할 수 있다. 즉, 배열 A를 순회하면서 해시 테이블에 원소를 넣고 확인하면 된다. 새로운 원소는 리스트에 넣은 뒤, 그 리스트를 다시 배열 A에 복사한다.

O(1)을 사용한 무식한 방법도 존재한다. 배열 A를 순회하면서 A[i]와 A[i+1]이 같을 때, i + 2 이후의 원소들을 모두 왼쪽으로 한 칸씩 옮긴다. 모든 원소가 같다면 시프트해야 하는 횟수는 (n - 1) + (n - 2) + ... + 2 + 1이 되고, 시간 복잡도는 O(n^2)이 된다.(n은 배열의 길이를 나타낸다.)

시프팅이 시간 복잡도의 주요 원인이므로 시간 복잡도를 개선하려면 시프팅의 횟수를 줄여야 한다. 배열이 이미 정렬되어 있으므로 반복된 원소들은 연달아 나타난다. 따라서 해당 원소가 이미 나왔었는지 확인하기 위해 자료구조를 보조적으로 사용할 필요는 없다. 모든 부분 배열을 옮기지 않아도 된다. 단순히 원소 하나를 한 번만 옮기면 되나.

앞의 예제 <2,3,5,5,7,11,11,11,13>에서 A[3]을 처리한다고 가정하자. A[3]과 A[2]를 비교해 보면 5가 존재한다는 사실을 알 수 있으므로 A[4]로 넘어간다. A[4]는 새로운 값이므로 삭제해야할 위치인 A[3]으로 옮긴다. 이제 배열은 <2,3,5,7,7,11,11,11,13>이 되고, 삭제해야할 위치는 A[4]가 된다. 그 다음에 A[5]부터 이 과정을 반복한다.

```java
// 삭제 후 유효한 원소의 개수를 반환한다.
public static int deleteDuplicates(List<Integer> A) {
    if (A.isEmpty()) {
        return 0;
    }

    int writeIndex = 1;
    for (int i = 1; i < A.size(); ++i) {
        if (!A.get(writeIndex - 1).equals(A.get(i))) {
            A.set(writeIndex++, A.get(i));
        }
    }
    return writeIndex;
}
```

## 5.6 주식 한 번 사고팔기

특정 기간, 주식 한 주를 사서 되팔았을 때 최대 이익을 얻을 수 있는 알고리즘을 설계하라. 모든 매매는 시작가를 기준으로 하며, 매도는 매입 후에 발생한다.

```java
public static double computeMaxProfit(List<Double> prices) {
    double minPrice = Double.MAX_VALUE, maxProfit = 0.0;
    for (Double price : prices) {
        maxProfit = Math.max(maxProfit, price - minPrice);
        minPrice = Math.min(minPrice, price);
    }
    return maxProfit;
}
```

시간 복잡도는 O(n)이고, 공간 복잡도는 O(1)이다. 여기서 n은 배열의 길이를 말한다.

## 5.7 주식 두 번 사고팔기

이번에는 주식 한 주를 최대 두 번까지 매매할 수 있을 때, 최대 이윤을 구하는 프로그램을 작성하라. 단 두 번쨰 주식은 첫 번째 주식을 판 뒤에 구입할 수 있다.

> 힌트: (i+1)번째 원소를 다루고 있을 때, i개의 원소에서 어떤 정보를 얻어야 하는지 생각해보자.

무식한 방법은 모든 가능한 매수-매도-매수-매도의 조합을 구하는 방식으로 시간 복잡도는 O(n^4)이다. 두 번째 주식은 첫 번째 주식을 매도한 뒤에 구입해야 하므로 배열 A를 두 부분 배열로 나누어 생각해 볼 수 있다. 앞의 O(n) 알고리즘을 두 배열에 적용하면 시간 복잡도를 O(n^2)으로 줄일 수 있다.

이 방법은 비효율적인데, 그 이유는 이전에 계산해 놓은 값을 제대로 이용하지 못하기 때문이다. 이를 개선하는 방법을 생각해보자. A[0,j](j는 1과 n-1 사이의 값)의 최대 이익값을 기록해 놓자. 이제 반대로 순회하면서 A[j, n-1](j는 1과 n-1 사이의 값)의 최대 이익값을 구하면서 동시에 앞에서 저장해 놓은 최대 이익값을 합치면, 현재 이익값을 구하면서 동시에 앞에서 저장해 놓은 최대 이익값을 합치면, 현재 이전에 얻은 최대 이익과 현재 이후에 얻은 최대 이익의 합을 구할 수 있다.

```java
public static double buyAndSellStockTwice(List<Double> prices) {
    double maxTotalProfit = 0.0;
    double minPriceSoFar = Double.MAX_VALUE;
    List<Double> firstBuySellProfits = new ArrayList<>();
    
    // 앞으로 읽는 부분
    // 각 날짜마다, 해당 날짜에 주식을 팔았을 때의 최대 이익 값을 구해 놓는다.
    for (int i = 0; i < prices.size(); ++i) {
        minPriceSoFar = Math.min(minPriceSoFar, prices.get(i));
        maxTotalprofit = Math.max(maxTotalProfit, prices.get(i) - minPriceSoFar);
        firstBuySellProfits.add(maxTotalProfit);
    }

    // 뒤로 읽는 부분
    // 각 날짜마다, 두 번째 주식을 해당 날짜에 샀을 때에 최대 이익 값을 구해 놓는다.
    double maxPriceSoFar = Double.MIN_VALUE;
    for (int i = prices.size() - 1; i > 0; --i) {
        maxPriceSoFar = Math.max(maxPriceSoFar, prices.get(i));
        maxTotalProfit = Math.max(maxTotalProfit, maxPriceSoFar - prices.get(i) + firstBuySellProfits.get(i - 1));
    }
    return maxTotalProfit;
}
```

이 알고리즘의 시간 복잡도는 O(n)이고, 부분 배열의 최대 이윤을 저장하기 위한 배열이 추가적으로 필요하므로 공간 복잡도 또한 O(n)이 된다.

## 5.8 대체 연산

n개의 숫자를 원소로 가지는 배열 A를, B[0] <= B[1] >= B[2] <= B[3] >= B[4] <= B[5] >= ...의 특징을 가지도록, 새로운 배열 B에 재배치하라.

> 힌트: 배열 A를 국지적으로 변경하여 문제를 풀 수 있는가?

간단한 해결책 중 하나는, 배열 A를 정렬한 뒤 아래쪽과 위쪽 절반을 교차로 배치하는 것이다. 또는 배열 A를 정렬한 다음 (A[1], A[2])와 (A[3], A[4])를 서로 교환한다. 나머지 원소들을 대상으로도 이런 작업을 이어간다. 두 개의 접근 방식은 정렬과 동일한 O(n log n)의 시간 복잡도를 가진다.

문제를 조금 더 생각해 보면, 굳이 배열 A를 정렬할 필요 없이, 중간 값 주위의 원소를 재배열한다음, 교차 배치를 하면 된다는 걸 알 수 있다. 중간값 찾기는 문제 11.8의 해법에서 볼 수 있는 것처럼 O(n) 시간에 수행할 수 있다.

최종적으로는, 문제에서 요구하는 순서가 매우 국지적이라는 것을 알아챌 수 있을 것이다. 따라서 중간값을 찾을 필요도 없다. 배열을 순회하면서 i가 짝수고 A[i] > A[i+1]이거나, i가 홀수이면서 A[i] < A[i+1]일 때, A[i]와 A[i+1]을 교환하면 된다.

```java
public static void rearrange(List<Integer> A) {
    for (int i = 0; i < A.size() - 1; ++i) {
        if (
            ( (i % 2) == 0 && A.get(i - 1) < A.get(i) )
         || ( (i % 2) != 0 && A.get(i - 1) > A.get(i) )
        ) {
            Collections.swap(A, i-1, i);
        }
    }
}
```

이 접근 방법은 중간값 찾기에 기반한 해법과 동일하게 O(n)의 시간 복잡도를 가진다. 하지만 메모리에 두 개 이상의 원소를 저장하거나 이전 원소를 읽을 필요가 없는 국지적 변경을 구현하는 것이 훨씬 더 쉽다. 즉, 배열의 원소 전체를 정렬할 필요 없이 하나씩 순회하면서 문제에서 요구하는 순서를 맞춰 주면 된다. 이 해법은 무식하게 풀기를 반복적으로 개선해 나가는 알고리즘 설계의 멋진 예시다.

## 5.9 n보다 작은 모든 소수 나열하기

1보다 큰 자연수 중에서 1과 자기 자신 이외의 수로 나누어 떨어지지 않는 수를 소수라 한다.

양의 정수 n이 주어졌을 때, 1과 n 사이에 있는 모든 소수를 반환하는 프로그램을 작성해 보자. 예를 들어 입력이 18이라면, <2,3,5,7,11,13,17>을 반환해야 한다.

> 힌트: 합성수는 제외한다.

우리는 불 배열을 사용해서 전체 소수를 구할 것이다. 만약 배열의 i번째 값이 참이라면 i는 소수일 것이다. 초기에 2보다 크거나 같은 모든 값은 후보가 된다. 해당 숫자가 소수라고 판명되면 그 숫자를 결과에 추가한다. 첫 번째 소수는 2이다. 이를 결과에 추가한다. 2의 배수는 소수가 될 수 없으므로 해당 후보들은 거짓으로 체크해 놓는다. 다음에 참으로 세팅된 값은 3이다. 1보다 크고 3보다 작은 숫자 중에 이 숫자를 나눌 수 있는 숫자는 없으므로 3도 소수가 된다. 마찬가지로 3을 결과에 추가하고 3의 배수는 후보자 배열에서 제거한다. 후보자 배열의 마지막에 도달할 때까지 이 과정을 반복한다.

예를 들어 n = 10일 때 후보자 배열을 <F,F,T,T,T,T,T,T,T,T,T>로 초기화한다. 여기서 T는 참을 의미하고 F는 거짓을 의미한다.(0과 1은 소수가 아니므로 거짓으로 초기화한다.) 2번 인덱스부터 시작한다. 해당 값이 참이므로 2를 소수 리스트에 추가하고 2의 배수를 걸러 낸다. 이제 배열은 <F,F,T,T,F,F,F,T,F,T,F>가 된다. 그 다음 참인 숫자는 3이므로 소수 리스트에 추가하고 3의 배수들은 걸러 낸다. 이제 배열은 <F,F,T,T,F,T,F,T,F,F,F>가 된다. 그 다음 참인 숫자는 5와 7이고, 이들의 배수는 10보다 크므로 더 이상 걸러 낼 숫자가 없다.

```java
// n이 주어졌을 때 n보다 작거나 같은 모든 소수를 반환하라.
public static List<Integer> generatePrimes(int n) {
    List<Integer> primes = new ArrayList<>();
    // isPrime.get(p)는 p가 소수인지 아닌지를 나타낸다. 초기에는 0과 1을 제외한
    // 나머지를 모두 참으로 세팅한다. 그 다음에 소수가 아닌 숫자를 걸러 낸다.
    List<Boolean> isPrime = new ArrayList<>(Collections.nCopies(n + 1, true));
    isPrime.set(0, false);
    isPrime.set(1, false);
    for (int p = 2; p <= n; ++p) {
        if (isPrime.get(p)) {
            primes.add(p);
            // p의 배수를 걸러 낸다.
            for (int j = p; j <= n; j += p) {
                isPrime.set(j, false);
            }
        }
    }
    return primes;
}
```

휴리스틱을 바탕으로 모든 숫자로 나누어 보는 방식보다 체로 걸러 내는 방식이 더 효율적이다. p의 배수를 걸러 내는 이 방법의 시간 복잡도는 n/p에 비례한다. 따라서 전체 시간 복잡도는 O(n/2 + n/3 + n/5 + n/7 + n/11 + ...)가 된다. 명백하진 않지만, 이 합은 점근적으로 n log n으로 수렴하고, 따라서 시간 복잡도의 상한은 O(n log n)이 된다. 공간 복잡도는 배열 P의 크기인 O(n)이 된다.

소수 판정을 할 때마다 O(sqrt(n))의 시간이 필요하기 때문에 모든 숫자로 나누어 보는 방법의 시간 복잡도는 O(n^(3/2))가 된다. 대부분의 숫자는 소수가 아니고 보통 소수 판정을 하는 데 오래 걸리지 않기 때문에 실제 시간 복잡도는 평균적으로 이보다 적다. 모든 숫자로 나누어 보는 첫 번째 방법의 시간 복잡도는 O(n^(3/2)/(log n)^2))이라고 알려져 있다. 여전히 두 번째 방법이 더 빠르다.

수행시간을 개선하기 위해 p가 아닌 p^2의 배수부터 제거해 나가도 된다. 모든 kp(k < p)의 합성수에 대해서는 이전에 이미 체크했기 때문이다. 짝수는 미리 제거함으로써 공간을 줄일 수 있다.

```java
// 와 무슨 말인지 모르겠다.
public static List<Integer> generatePrimes(int n) {
    final int size = (int)Math.floor(0.5 * (n - 3)) + 1;
    List<Integer> primes = new ArrayList<>();
    primes.add(2);
    // isPrimes.get(i)는 (2i + 3)이 소수인지 아닌지 알려준다.
    // 초기에는 전부 참으로 세팅한다. 그 다음에 소수가 아닌 숫자들을 지워 나간다.
    List<Boolean> isPrime = new ArrayList<>(Collections.nCopies(size, true));
    for (int i = 0; i < size; ++i) {
        if (isPrime.get(i)) {
            int p =((i * 2) + 3);
            primes.add(p);

            // p^2부터 배수를 제거해 나간다. 그 값은 (4i^2 + 12i + 9)이 된다.
            // 이 값의 isPrime에서의 인덱스는 (2i^2 + 6i + 3)이다.
            // 왜냐하면 isPrime.get(i)이 2i + 3을 의미하기 때문이다.
            //
            // p^2가 오버플로될 수 있기 때문에 j는 long 자료형을 사용해야 한다.
            for (long j = ((i * i) * 2) + 6 * i + 3; j < size; j += p) {
                isPrime.set((int)j, false);
            }
        }
    }
    return primes;
}
```

## 5.10 배열 안의 원소로 순열 구하기

순열이란 일련의 순서로 나열된 원소들을 새로운 순서로 재배열하는 것을 말한다. 예를 들어, <a,b,c,d>는 <b,a,d,c>,<d,a,b,c>와 같이 24개의 서로 다른 순열이 존재한다.

배열 P를 이용해 순열을 나타낼 수 있는데, 예를 들면 P[i]는 i 원소의 새로운 위치가 된다. 즉, 배열 <2,0,1,3>은 0번 원소는 2번으로, 1번 원소는 0번으로, 그리고 3번 원소는 제자리에 놓는다는 뜻이다. 이 배열을 실제 배열의 객체를 재배치하는 데 적용할 수도 있다. 예를 들어 순열 <2,0,1,3>을 배열 A = <a,b,c,d>에 적용하면 <b,c,a,d>가 된다.

길이가 n인 배열 A와 순열 P가 주어졌을 때, P를 A에 적용해 보라.

> 힌트: 모든 순열은 순환 순열의 집합 안에 있다고 말할 수 있다. 이미 순환된 원소를 어떻게 나타낼 수 있을까?

만약 추가 공간을 사용할 수 있다면 순열 배열을 주어진 배열에 적용하는 것은 간단하다. 주어진 배열과 길이가 같은 새로운 배열 B를 사용해서 모든 i에 대해 B[P[i]] = A[i]로 값을 할당한 뒤 B의 결과를 A로 복사하면 된다. 시간 복잡도는 O(n)이고 공간 복잡도는 O(n)이다.

공간 복잡도는 개선할 수 있는 핵심은 순열을 보다 간략한 구조로 분해한 뒤 하나씩 순서대로 처리하는 것이다. 예를 들어, 순열 <3,2,1,0>를 A = <a,b,c,d>에 적용하면, 0(a)은 3번 인덱스로, 3(d)는 0번 인덱스로 옮긴다. 계속해서 1(b)은 2번 인덱스로, 2(c)는 1번 인덱스로 옮겨진다. 순열 배열에 따라 모든 원소를 다 옮긴 결과는 <d,c,b,a>가 된다.

이 예제를 일반화 하면 다음과 같다. 모든 순열은 독립적인 순환 순열의 컬렉션과 같고, 이를 통해 모든 원소가 순환 순열 내에서 재배치가 이루어진다.

이 사실은 굉장히 중요하다. 왜냐하면 순환 순열 내에서는 상수 크기의 공간으로 원소를 하나씩 차례대로 재배치할 수 있고, 결국 순환 순열의 컬렉션으로 이루어진 순열 또한 상수만큼의 공간을 이용해서 모든 원소를 재배치할 수 있기 때문이다. 따라서 이 문제를 풀기 위해서는 순열을 구성하는 분리된 사이클을 찾아야 한다. 원소 배열에 불값을 저장하면 쉽게 사이클을 찾을 수 있다.

O(n) 공간을 추가로 사용하지 않을 수 있는 한 가지 방법은 순환 배열에 음수를 사용하는 것이다. 즉 P[i]를 사이클에 추가한 뒤에는 n을 빼서 음수로 만들어 준다. 그 뒤 P[i]가 음수라면 해당 숫자는 사이클에 속해 있다고 해석하면 된다.

예를 들어 <3,1,2,0>을 생각해 보자. 먼저 첫 번째 숫자인 3부터 시작한다. A[0]을 A[3]으로 옮기고 기존 A[3]을 다른 곳에 저장해 둔다. 이제 순환 배열은 <-1,1,2,0>이 된다. A[3]을 A[0]에 옮긴다. P[0]은 음수이므로 0번에서 시작한 사이클이 끝났음을 알 수 있다. 이제 순환 배열은 <-1,1,2,-4>가 된다. P[1]은 음수가 아니므로 해당 숫자는 아직 사이클에 속해 있지 않다는 것을 알 수 있다. 이와 같은 과정을 계속해 나가면 된다.

```java
public static void applyPermutation(List<Integer> perm, List<Integer> A) {
    for (int i = 0; i < A.size(); ++i) {
        // perm.get(i)가 음수인지 확인하면 i번째 인덱스가 이미 사이클 내에 속해 있는지 알 수 있다.
        int next = i;
        while (perm.get(next) >= 0) {
            Collections.swap(A, i, perm.get(next));
            int temp = perm.get(next);
            // perm에 있는 값에서 perm.size()을 빼서 해당 값을 음수로 만든다.
            // 이렇게 하면 해당 값은 이미 사이클에 속해 있다는 말이 된다.
            perm.set(next, perm.get(next) - perm.size());
            next = temp;
        }

        // perm을 다시 갱신한다.
        for (int i = 0; i < perm.size(); ++i) {
            perm.set(i, perm.get(i) + perm.size());
        }
    }
}
```

이 프로그램의 시간 복잡도는 O(n)이 된다. 순열 배열을 임시적으로 수정할 수 있다면 공간 복잡도를 O(1)로 개선할 수 있다.

만약 부호 비트를 사용할 수 있다면 길이가 n인 불 배열을 사용해서 i번째 원소가 이미 처리됐는지 확인할 수 있다. 혹은 배열을 왼쪽에서 오른쪽으로 순회하면서 현재 위치가 사이클에서 가장 왼쪽에 있을 경우에만 사이클 찾는 알고리즘을 적용하면 된다.

```java
public static void applyPermutaion(List<Integer> perm, List<Integer> A) {
    for (int i = 0; i < A.size(); ++i) {
        // 사이클을 순회하면서 i가 최소 원소인지 확인한다.
        boolean isMin = true;
        int j = perm = perm.get(i);
        while (j != i) {
            if (j < i) {
                isMin = false;
                break;
            }
            j = perm.get(j);
        }

        if (isMin) {
            cyclicPermutation(i, perm, A);
        }
    }
}

private static void cyclicPermutation(int start, List<Integer> perm, List<Integer> A) {
    int i = start;
    int temp = A.get(start);
    do {
        int nextI = perm.get(i);
        int nextTemp = A.get(nextI);
        A.set(nextI, temp);
        i = nextI;
        temp = nextTemp;
    } while (i != start);
}
```

현재 위치가 가장 왼쪽에 위치한 원소인지 확인하려면 사이클을 한 번 더 돌아야 하므로 시간 복잡도는 O(n^2)으로 증가한다.

## 5.11 다음 순열 구하기

n개의 원소로 만들 수 있는 순열의 개수는 n!이다. 이들은 사전 순으로 정렬(dictionary ordering)이 가능하다. 순열 p와 q의 순서는 다음과 같이 결정한다. 0번째 인덱스부터 시작해서 처음으로 다른 값이 q보다 p가 더 작다면 p가 q의 앞에 온다. 예를 들어 <2,0,1>은 <2,1,0>보다 앞에 온다. 순열 <0,1,2>가 사전 순으로 배열했을 때 가장 앞에 놓이게 되고 <2,1,0>이 가장 마지막에 놓이게 된다.

어떤 순열이 주어졌을 때 다음 순열을 구하는 함수를 작성하라. 단, 순열의 순서는 사전 순으로 정렬되어 있다. 주어진 순열이 가장 마지막 순열이라면 빈 순열을 반환하면 된다. 예를 들어 p = <1,0,3,2>의 다음 순열은 <1,2,0,3>이다. 입력이 <3,2,1,0>이라면 <>을 반환한다.

> 힌트: 실제 예제를 사용해서 생각해보자.

무식한 방법은 입력과 갈이가 같은 모든 순열을 사전 순으로 나열한 뒤 입력 순열 바로 다음에 등장하는 순열을 찾는 것이다. 엄청난 크기의 시간 및 공간 복잡도를 고려하지 않는다고 하더라도 길이가 n인 모든 순열을 계산하는 건 단순한 문제가 아니다.

순열이 사전 순으로 정렬되어 있으므로, 이 문제를 해결하는 핵심은 순열의 크기를 가능한 조금씩 증가시키는 것이다. 자동차에서 주행 기록계를 증가시키는 것도 이와 비슷한 유형이라고 볼 수 있는데, 가장 큰 차이점은 이 문제에서는 순열의 값이 아닌 순서를 재배치한다는 데 있다. 순열 <6,2,1,5,4,3,0>을 생각해보자.

일단 순열의 접미사(suffix) 중에서 가장 긴 감소 순열(앞의 예제에서는 <5,4,3,0>)을 찾는다. 이 순열은 이미 사전 순으로 가장 마지막에 있는 순열이므로 그 다음 순열이 존재하지 않는다.

그 후 이 순열 바로 앞에 위치한 원소 e(앞의 예제에서는 1)를 살펴보자(만약 이런 e가 존재하지 않는다면, 즉 가장 긴 감소 순열이 <n-1, n-2, ... 2,1,0>이라면, 이 순열이 사전 순으로 가장 마지막 순열이므로 다음 순열은 존재하지 않는다).

원소 e는 접미사 순열의 원소 중 적어도 하나보다는 작다(적어도 원소 e 바로 다음 원소는 e보다 크다). e보다 큰 접미사 순열의 원소 중에서 가장 작은 원소를 s라 하자. s와 e를 맞바꾼다면 전체 순열의 접두사(prefix)를 최소한으로 증가시킨 꼴이 된다.

이 예제에서는, e가 1이고 s는 3이므로, 이 둘을 맞바꾸면 <6,2,3,5,4,1,0>이 된다.

아직 끝나지 않았다. 순열의 접두사는 현재 순열보다 큰 순열 중에서 가장 작은 순열이라고 말할 수 있지만 접미사는 아직 가장 작은 순열이 아니다. 가장 작은 접미사 순열은 정렬을 통해 얻을 수 있다. 앞의 예제에서는 <0,1,4,5>가 된다.

최적화 측면에서 접미사 순열은 이미 감소 순열이고, s와 e를 맞바꾸더라도 여전히 감소 순열이므로, 접미사 순열에 복잡한 정렬 알고리즘을 대입할 필요가 없다. 감소 순열을 단순히 거꾸로 뒤집으면 가장 작은 접미사 순열을 만들 수 있다.

이 알고리즘을 일반화하면 다음과 같다.

1. p[k] < p[k+1]이면서 k 이후의 접미사가 감소 순열인 k를 찾는다.
2. p[l] > p[k] 중에서 가장 작은 p[l]을 찾는다.(p[k] < p[k+1]이므로 l은 항상 존재한다.)
3. p[l]과 p[k]를 맞바꾼다. (이 둘을 맞바꾸더라도 k 이후의 접미사 순열은 여전히 감소 순열이다.)
4. k 이후의 접미사 순열을 뒤집어 준다.

```java
public static List<Integer> nextPermutation(List<Integer> perm) {
    // 오른쪽에서 바로 다음 항목보다 작은 첫 번째 항목을 찾는다.
    int inversionPoint = perm.size() - 2;
    while (inversionPoint >= 0 && perm.get(inversionPoint) >= perm.get(inversionPoint + 1)) {
        --inversionPoint;
    }
    if (inversionPoint == -1) {
        return Collections.emptyList(); // perm이 마지막 순열이다.
    }

    // inversionPoint 이후의 엔트리 중에서 perm.get(inversionPoint)보다 크지만
    // 그중에서 가장 작은 엔트리를 맞바꾼다.
    // perm의 항목은 inversionPoint 이후 감소하므로 역순으로 검색하면
    // perm.get(inversionPoint)보다 큰 첫 번째 항목이 스왑할 항목이다.
    for (int i = perm.size() - 1; i > inversionPoint; --i) {
        if (perm.get(i) > perm.get(inversionPoint)) {
            Collections.swap(perm, inversionPoint, i);
            break;
        }
    }

    // perm의 항목은 inversionPoint 후에 감소 순서로 나타나야 하므로,
    // 단순히 이 순열을 뒤집음으로써 사전 순으로 가장 작은 순열을 만들 수 있다.
    Collections.reverse(perm.subList(inversionPoint + 1, perm.size()));
    return perm;
}
```

이 알고리즘은 상수 번 읽는다. 따라서 전체 시간 복잡도는 O(n)이 되고, 사용하는 지역 변수의 개수가 상수이므로 복잡도는 O(1)이 된다.

## 5.12 오프라인 데이터 샘플 구하기

소셜 네트워크 회사를 운영하는 중 페이지의 새로운 UI 효과를 알고 싶다고 가정하자. 이때 전체 사용자가 아니라 임의의 일부 사용자에게만 새로운 기능을 배포하면 잠재적 실패 위험도를 줄일 수 있다.

서로 다른 원소로 이루어진 배열과 부분 집합의 크기가 주어졌을 때, 주어진 크기의 부분 집합을 반환하는 알고리즘을 작성하라. 모든 부분 집합이 생성될 확률은 같아야 한다. 입력 배열을 통해 부분 집합의 결과를 반환하라.

> 힌트: 크기가 k인 임의의 부분 집합이 존재할 때 크기가 k+1인 임의의 부분 집합을 어떻게 구할 수 있을까?

주어진 배열 A의 길이는 n, 부분 집합의 크기는 k라 하자. 가장 단순한 방법은 입력 배열을 순회하면서 각 원소를 k/n의 확률로 선택하는 것이다. 이 방법은 물론 평균적으로 k개의 원소를 선택하겠지만 k보다 많이 혹은 적게 선택할 수도 있다.

다른 방법은 크기가 k인 모든 부분 집합을 나열한 뒤에 임의로 하나의 부분 집합을 선택하는 것이다. 부분 집합은 총(텍스트 에디터에서 적을 수 없음: 이항계수로 n개의 원소 중에서 k개를 선택하는 방법의 개수)개 있으므로 이 방법의 시간 및 공간 복잡도가 굉장히 클 것이다. 또한 크기가 k인 부분 집합을 모두 나열하는 것은 간단치 않다.(문제 15.5)

크기가 k인 임의의 부분 집합을 효율적으로 만드는 방법은 먼저 크기가 k-1인 부분 집합을 만든 뒤, 임의의 나머지 원소 하나를 추가하는 것이다. K = 1일 때는 임의의 숫자 생성기를 한번 호출하면 된다. 즉, 임의의 값을 n으로 나눈 나머지를 r이라 했을 때, A[0]와 A[r]을 맞바꾼다. A[0]이 임의로 생성된 최종 결괏값이 된다.

K > 1인 경우에는 위와 같이 임의의 숫자 하나를 선택한 다음에 부분 배열 A[1, n - 1]에 대해서 앞의 과정을 반복하면 된다. 결과적으로 임의의 부분 집합은 A[0, k - 1]에 놓이게 되고 나머지 원소들은 그 뒤 n - k개의 위치에 놓이게 된다.

직관적으로 생각해 보면, 크기가 k인 부분 집합을 생성할 확률이 같다면 크기가 k + 1인 부분 집합을 생성할 확률도 같을 것이다. 이는 수학적 귀납법(mathematical induction)을 이용해 증명할 수 있는데 여기서는 다루지 않을 것이다. 참고로 길이가 k인 모든 부분 집합의 순열이 A[0, k - 1]에 존재할 확률이 같다는 사실이 위 증명의 귀납 가정(induction hypothesis)이다.

실제 예제로 설명해 보자. A = <3,7,5,11>이고 부분 집합의 크기를 3이라 하자. 먼저 임의의 숫자 생성기를 통해 [0,3] 사이의 숫자 하나를 선택한다. 그 숫자가 2라고 가정하자. A[0]과 A[2]를 맞바꾼다. 이제 배열은 <5,7,3,11>이 된다. 이제 [1,3] 사이의 숫자를 임의로 선택한다. 그 숫자가 3이라 가정하자. A[1]과 A[3]을 맞바꾼다. 이제 배열은 <5,11,3,7>이 된다. 다시 [2,3] 사이의 숫자를 하나 선택한다. 그 숫자가 2라 가정하자. A[2]와 자기 자신을 맞바꾸게 되므로 배열은 변하지 않는다. 따라서 임의로 선택한 순열은 앞의 원소 세 개 {5,11,3}이 된다.

```java
public static void randomSampling(int k, List<Integer> A) {
    Random gen = new Random();
    for (int i = 0; i < k; ++i) {
        // [i, A.size() - 1] 사이에서 임의의 수를 생성한다.
        Collections.swap(A, i, i + gen.nextInt(A.size() - 1));
    }
}
```

이 알고리즘의 공간 복잡도는 명백히 O(1)이다. 시간 복잡도는 원소를 선택하는 데 필요한 O(k)와 같다.

이 알고리즘은 임의의 숫자 생성기를 총 k번 호출한다. 약간의 최적화를 해보자면, k가 n/2보다 큰 경우에는 임의의 숫자 생성기를 n - k번 호출한 뒤 해당 숫자들을 집합에서 제거하면 된다. 예를 들어 k = n - 1이라면 임의의 숫자 생성기를 한 번만 호출한 뒤 이를 뺀 나머지 원소들을 반환하면 된다.

## 5.13 온라인 데이터 샘플 구하기

이 문제는 네트워크 세션에서 균일한 샘플의 패킷을 제공하는 패킷 스니퍼(packet sniffer)를 설계하는 부분에 착안해서 만들어졌다.

어떤 정수값 k가 주어졌을 때, 실시간으로 패킷이 유입되는 상황에서, k개의 임의의 패킷을 균일한 확률로 유지하는 알고리즘을 설계하라.

> 힌트: n개의 패킷 중에서 이미 k개를 가지고 있다고 가정해 보자. 이떄, n + 1번째 패킷이 입력으로 들어오면 어떻게 할 것인가.

무식한 방법은 모든 패킷을 읽은 뒤 저장하는 것이다. 매번 패킷을 읽을 때마다 해법 5.12를 적용해 크기가 k인 부분 집합을 임의로 선택한다. 이 방법은 n개의 패킷을 모두 저장해야 하므로 공간 복잡도가 O(n)로 굉장히 크다. 또한 패킷을 읽을 때마다 해법 5.12를 실행해야 하므로 시간 복잡도도 O(nk)로 굉장히 크다.

문제를 슬쩍 봤을 때 무식한 방법보다 더 나은 방법은 없어 보인다. 왜냐하면 n개의 패킷을 읽은 후 k개의 패킷을 균등하게 선택해야 하기 때문이다. 하지만 처음 n개의 패킷을 읽고서 크기가 k인 부분 집합을 임의로 선택했다고 가정한다면 어떨까. n + 1번째 패킷을 읽었을 때 패킷이 부분 집합에 포함될 확률은 k / (n + 1)이 된다. 기존의 부분 집합에서 패킷 하나를 임의로 선택해서 제거한다면, 우리는 n + 1개의 패킷에서 크기가 k인 부분 집합을 임의로 선택한 꼴이 된다.

앞의 알고리즘은 읽은 패킷의 개수에 대한 수학적 귀납법을 통해 증명할 수 있다. 이 증명의 귀납 가정(induction hypothesis)은 n >= k번째 패킷을 읽은 뒤에 선택한 k개가 이미 균일한 확률을 유지하는 임의의 샘플이라는 사실이다.

예를 들어 k = 2이고, p, q, r, t, u, v 순서대로 패킷을 읽었다고 가정하자.
처음 두 패킷은 부분 집합에 포함하므로 {p,q}가 된다.
그 다음 패킷 r을 부분 집합에 포함시킬 확률은 2/3이다.
패킷 r이 선택되지 않았다고 가정하자.
그러면 3개의 패킷을 읽어서 선택한 부분 집합은 여전히 {p,q}가 된다.
그 다음 패킷 t를 부분 집합에 포함시킬 확률은 2/4이다.
패킷 t가 선택되었다고 가정하자.
그러면 {p,q} 중의 하나를 같은 확률로 선택한 뒤 t과 맞바꾸어야 한다.
패킷 q가 선택되었다고 가정하자.
이제 부분 집합은 {p,t}가 된다.
그 다음 패킷 u가 부분 집합에 포함될 확률은 2/5이다.
패킷 u가 선택되었다고 가정하자.
{p,t} 중의 하나를 같은 확률로 선택한 뒤 u와 맞바꾸어야 한다.
패킷 t가 선택되었다고 가정하자.
이제 부분 집합은 {p,u}가 되었다.
다음 패킷 v는 2/6 확률로 선택된다.
패킷 u가 선택되지 않았다고 가정하자.
부분 집합은 {p,u}로 남아 있다.

```java
// 가정: 적어도 k개의 원소가 유입된다.
public static List<Integer> onlineRandomSample(Interator<Integer> sequence, int k) {
    List<Integer> runningSample = new ArrayList<>(k);
    // 첫 k개의 원소를 저장한다.
    for (int i = 0; sequence.hasNext() && i < k; ++i) {
        runningSample.add(sequence.next());
    }

    // 첫 k개의 원소를 읽었다.
    int numSeenSoFar = k;
    Random randIdxGen = new Random();
    while (sequence.hasNext()) {
        Integer x = sequence.next();
        ++numSeenSoFar;
        // [0, numSeenSoFar] 사이에서 임의의 숫자를 생성한다.
        // 그리고 만약에 그 숫자가 [0, k - 1] 사이에 들어 있다면, 해당 원소를 x와 맞바꾼다.
        final int idxToReplace = randIdxGen.nextInt(numSeenSoFar);
        if (idxToReplace < k) {
            runningSample.set(idxToReplace, x);
        }
    }
    return runningSample;
}
```

각 원소마다 O(1)의 시간을 사용하기 때문에 총 시간 복잡도는 스트리밍으로 유입되는 원소의 개수에 비례한다. 공간 복잡도는 O(k)가 된다.

반복마다 모든 부분 집합이 선택될 확률은 같다. 하지만 부분 집합들은 매 반복마다 독립적으로 생성된다고 할 수 없다. 바로 다음 부분 집합은 많아야 하나의 원소만 다르다. 이와 반대로 무식한 방법으로 선택한 부분 집합은 반복할 때마다 독립적이다.

## 5.14 임의의 순열 계산하기

임의의 순열을 생성하는 건 생각보다 간단하지 않다. 예를 들어 <0,1,...,n-1>을 순회하면서 한 원소를 임의의 다른 원소와 맞바꾸는 방법은 모든 순열을 같은 확률로 생성해 내지 못한다. n = 3인 경우를 생각해 보자. 이때 모든 순열의 개수는 3! = 6이다. 원소를 선택해서 맞바꾸는 경우의 수는 3^3 = 27이다. 27은 6으로 나누어 떨어지지 않으므로 모든 순열이 동일하게 생성된다고 말할 수 없고, 어떤 순열이 다른 순열보다 더 선택될 확률이 높을 것이다.

{0,1,...,n-1}로 이루어진 임의의 순열을 동일한 확률로 만들어 내는 알고리즘을 설계하라. {0,1,...,n-1}의 숫자를 같은 확률로 반환하는 임의의 숫자 생성기가 주어졌다고 가정해도 된다. 이 생성기를 가능하면 적게 호출하도록 하라.

> 힌트: 결과를 배열 A에 저장한다고 하자. A[n-1]에 올바른 값이 할당되었을 때 어떻게 처리하겠는가?

무식한 방법은 반복적으로 0부터 n-1까지의 숫자를 임의로 선택하는 것이다. 뽑은 숫자를 다시 뽑으면 무시하고 다른 숫자를 뽑는다. 이미 뽑은 숫자를 확인하기 위해서 해시 테이블을 사용하면 좋다.

예를 들어 n = 4일 때, 우리가 뽑은 숫자의 수열이 1,2,1(이미 뽑은 숫자),3,1(이미 뽑은 숫자),2(이미 뽑은 숫자),0(끝, 0부터 3까지 숫자가 모두 나왔다)이 될 수 있다. 이때의 순열은 <1,2,3,0>이 된다.

이 방법을 사용하면 꽤 명백하게 모든 순열이 같은 확률로 선택되는 것을 알 수 있다. 공간 복잡도는 해시 테이블을 사용하므로 O(n)이 된다. 시간 복잡도는 분석하기 조금 어렵다. 먼저, 선택할 숫자가 많을 때는 반복을 적게 할 테지만, 숫자가 많이 남지 않은 상황에서는 오래 걸릴 것이다. 순열이 완성되는 데 필요한 평균 시도 횟수를 구하는 문제는 쿠폰 수집 문제로 알려져 있다. 평균적으로 필요한 시도 횟수는 O(n log n)이다.

당연하겠지만, 시간 복잡도를 개선하기 위해선 중복된 부분을 피해야 한다. 이를 해결하기 위해 임의로 선택하는 집합의 개수를 제한한다. 문제 5.12의 해법을 <0,1,2,...,n-1>과 k = n에 적용해 보면, 반복마다 배열을 부분 순열과 남아 있는 값으로 구할 수 있다. 반환되는 부분 집합이 항상 같다고 하더라도 ({0,1,...,n-1}), 모든 n!개의 가능한 순열이 같은 확률로 선택된다. 예를 들어 n = 4라고 하자. <0,1,2,3>에서 시작한다. 처음에는 0에서 3 사이의 숫자를 임의로 선택한다. 1이라고 가정하자. 배열을 <1,0,2,3>으로 갱신한다. 두 번째에는 1에서 3사이의 숫자를 임의로 선택한다. 3이라고 가정하자. 배열을 <1,3,0,2>로 갱신한다. 세 번쨰 임의의 숫자는 2와 3 중의 하나가 된다. 3이라고 가정하자. 배열을 <1,3,2,0>으로 갱신하고, 이 배열이 최종 결과가 된다.

```java
public static List<Integer> computeRandomPermutation(int n) {
    List<Integer> permutation = new ArrayList<>(n);
    for (int i = 0; i < n; ++i) {
        permutation.add(i);
    }
    OfflineSampling.randomSampling(permutation.size(), permutation);
    return permutation;
}
```

시간 복잡도는 O(n)이다. 배열 내에서 순열을 만들기 때문에 추가적인 공간은 필요하지 않다.

## 5.15 임의의 부분 집합 만들기

집합 {0,1,2,...,n-1}에서 크기가 k인 부분 집합의 개수는 총 n! / ((n-k)!k!)이다. 우리는 이 부분 집합 중 하나를 같은 확률로 반환하는 알고리즘을 설계하려고 한다.

양의 정수 n과 크기 k(k < n)가 입력으로 주어졌을 때, {0,1,2,...,n-1}의 집합에서 크기가 k인 부분 집합을 반환하는 프로그램을 작성하라. 부분 집합은 배열로 표현한다. 모든 부분 집합뿐만 아니라 배열 내의 모든 순열 또한 같은 확률로 나타나야 한다. 음이 아닌 정수 t가 주어졌을 때 {0,1,...,t-1} 중에서 숫자 하나를 균일한 확률로 반환하는 함수가 주어졌다고 가정해도 된다.

> 힌트: 공간을 줄일 수 있도록 적절한 자료구조를 사용해서 문제 5.12의 해법을 시뮬레이션해 보라.

해법 5.12의 무식한 방법과 비슷하게 서로 다른 k개의 값을 선택할 때까지 0부터 n-1 사이의 임의의 숫자를 반복해서 선택하는 방법도 있다. 이 방법은 앞에서 언급했듯이 k가 n에 가까울수록 성능이 저하되는 문제가 있다. 공간도 추가적으로 O(k) 시간이 소요된다.

우리는 문제 5.12의 해법에서 설명한 오프라인 샘플링 알고리즘을 흉내 낼 것이다. 먼저 배열 A를 A[i] = i로 초기화한 뒤, k개의 원소를 샘플링한다. 이 방법은 O(n) 공간 및 시간이 소요된다. 배열 <0,1,...,n-1>을 만든 뒤, 부분 집합을 구하는 데 O(k) 시간이 소요된다.

K << n 일 때는 대부분의 배열이 A[i] = i 상태 그대로일 것이다. 공간 복잡도를 O(k)로 줄일 수 있는 핵심은 해시테이블을 사용해서 A를 시뮬레이션하는 것이다. 즉, 변경된 엔트리가 무엇인지만 기록하고, 나머지 엔트리는 기본값, 즉 본인의 인덱스가 된다.

자세히 말하자면, 키와 값이 {0,1,...,n-1}인 해시 테이블 H를 사용할 것이다. 개념적으로 H는 임의의 숫자를 선택하는 과정에서 선택된 배열의 엔트리를 확인하는 데 사용된다. 즉, A[i]의 값이 i가 아닌 엔트리들 말이다. 알고리즘이 진행될수록 해시테이블 H는 갱신된다.

- 만약 i가 H 안에 있다면 이 값은 A[i]에 저장되어 있는 값이다.
- 만약 i가 H 안에 있지 않다면 암묵적으로 A[i] = i를 의미한다.

우리가 살펴볼 엔트리의 개수는 k개이므로 k가 n보다 작을 때 길이가 n인 배열을 초기화하고 갱신하는 무식한 방법보다 시간과 공간을 절약할 수 있다.

초기에 H는 비어 있다. 그리고 다음과 같은 작업을 k번 반복한다. [0,n-1-i] 사이의 임의의 값 r을 선택한다(i < k는 현재까지의 작업 반복 횟수). 두 개의 엔트리 r과 i가 현재 H에 존재하거나 하지 않는 네 가지 경우의 수가 존재한다. 최종 결과는 A[0, k-1]에 들어 있고, 이는 H를 통해 결정된다.

예를 들어 n = 100이고 k = 4라고 하자.
첫 번째 반복에서 임의의 숫자 28이 선택됐다고 가정하자. H를 (0,28), (28,0)으로 갱신한다. 이 말은 A[0]은 28이고, A[28]은 0이라는 뜻이다. 나머지는 모두 A[i] = i가 된다.
두 번째에 42가 선택되었다고 하면, H를 (0,28),(28,0),(1,42),(42,1)으로 갱신한다.
세 번째에 다시 28이 선택됐다고 가정하자. 이제 H를 (0,28),(28,2),(1,42),(42,1),(2,0)으로 갱신한다.
마지막으로 64가 선택되었으면, H는 (0,28),(28,2),(1,42),(42,1),(2,0),(3,64),(64,3)이 된다. 임의의 부분 집합은 0,1,2,3 인덱스에 있는 4개의 원소인<28,42,0,64>

```java
// {0,1,...,n-1}에서 크기가 k인 임의의 부분 집합을 반환하라.
public static List<Integer> randomSubset(int n, int k) {
    Map<Integer, Integer> changedElements = new HashMap<>();
    Random randIdxGen = new Random();
    for (int i = 0; i < k; ++i) {
        // [i, n - 1] 사이에서 임의의 숫자를 생성한다.
        int randIdx = i + randIdxGen.nextInt(n - 1);
        Integer ptr1 = changedElements.get(randIdx);
        Integer ptr2 = changedElements.get(i);
        if (ptr1 == null && ptr2 == null) {
            changedElement.put(randIdx, i);
            changedElement.put(i, randIdx);
        } else if (ptr1 == null && ptr2 != null) {
            changedElement.put(randIdx, ptr2);
            changedElement.put(i, randIdx);
        } else if (ptr1 != null && ptr2 == null) {
            changedElement.put(i, ptr1);
            changedElement.put(randIdx, i);
        } else {
            changedElement.put(i, ptr1);
            changedElement.put(randIdx, ptr2);
        }
    }

    List<Integer> result = new ArrayList<>(k);
    for (int i = 0; i < k; ++i) {
        result.add(changedElements.get(i))
    }
    return result;
}
```

반복마다 정해진 횟수의 연산을 수행하므로 시간 복잡도는 O(k)가 된다. H와 결과 배열은 k 이상의 원소를 담지 않으므로 공간 복잡도 또한 O(k)가 된다.

## 5.16 균등하지 않은 임의의 숫자 생성하기

서버를 위한 로드 테스트(load test, 부하 테스트) 코드를 작성해야 한다고 가정하자. 이 서버에 유입되는 일 년 치 요청의 도착 간격 시간(inter-arrival time of request) 데이터가 있고, 이 데이터를 통해 분포를 나타내는 히스토그램을 그릴 수 있다. 로드 테스트용 요청을 만들려고 하는데, 이 요청의 도착 간격 시간의 분포를 우리가 관찰한 분포와 같도록 생성하려고 한다. 다음은 이러한 도착 간격 시간을 생성하는 문제를 형식적으로 설명했다.

n개의 숫자와 각 숫자의 확률 p0,p1,...,pn-1이 주어졌다.(이 확률을 전부 더하면 1이 된다). [0,1] 사이의 숫자를 균등하게 생성하려면 어떻게 해야 할까? 예를 들어 숫자 3,5,7,11과 각 숫자의 확률 9/18, 6/18, 2/18, 1/18이 주어졌을 때 여러분의 프로그램을 1000000번 호출하면 3은 대략 5000000번, 5는 대략 333333번, 7은 대략 111111번, 11은 대략 55555번 등장해야 한다.

> 힌트: 선택된 숫자가 a보다 작거나 같은 확률 그래프를 살펴보자. 여기서 확률에 맞는 수를 선택하는 기준은 무엇인가?

실제로 어떤 숫자가 생성되는지는 중요하지 않다. n개의 결과를 p0,p1,...,pn-1의 확률로 선택하고 싶을 뿐이다. 만약 모든 확률이 같다면, 즉 1/n이라면, 임의의 숫자 생성기를 한 번만 호출한 뒤 i/n과 (i+1)/n 사이에 있는 i를 선택하면 된다.

확률이 같이 않다면 [0,1] 구간을 각 확률의 크기에 비례하도록 n개의 서로 다른 구간으로 분할하면 된다. j번째 구간은 확률 pj에 비례하도록 구간의 크기를 설정한다. 그다음에 [0,1] 사이의 값을 임의로 선택한 뒤 그 값이 속한 구간의 숫자를 반환하면 된다.

이 구간을 만드는 쉬운 방법은 p0, p0 + p1, p0 + p1 + p2, ..., p0 + p1 + p2 +...+ pn-1을 구간의 끝점으로 잡으면 된다. 이 문제에서 주어진 예제를 살펴보면, 네 개의 구간은 각각 [0.0, 0.5), [0.5, 0.833), [0.833, 0.944), [0.944, 1.0]이 된다. 이제 임의의 숫자 생성기가 [0.0, 1.0] 사이의 값 중에서 0.873을 선택했다고 하자. 0.873은 세 번째 구간인 [0.833, 0.944)의 구간에 속해 있으므로 세 번째 숫자인 7을 반환하면 된다.

일반적으로 n개의 구간값이 들어 있는 배열을 탐색하는 데 걸리는 시간은 O(n)이다. 하지만 이를 좀 더 개선할 수 있다. 배열 <p0, p0 + p1, p0 + p1 + p2, ..., p0 + p1 + p2 + ... + pn-1>은 정렬되어 있으므로 이진 탐색을 사용해서 O(log n) 시간에 원하는 구간을 찾을 수 있다.

```java
public static int nonuniformRandomNumberGeneration(List<Integer> values, List<Double> probabilities) {
    List<Double> prefixSumOfProbabilities = new ArrayList<>();
    // 확률값을 사용해서 구간의 끝점을 구한다.
    probabilities.stream().reduce(0.0, (left, right) -> {
        prefixSumOfProbabilities.add(left + right);
        return left + right;
    })

    Random r = new Random();
    // [0.0, 1.0) 사이의 숫자를 임의로 선택한다.
    final double uniform01 = r.nextDouble();
    // uniform01이 있는 구간의 인덱스를 찾는다.
    int it = Collections.binarySearch(prefixSumOfProbabilities, uniform01);
    if (it < 0) {
        // 배열에 있는 원소 중에서 key보다 큰 첫 번째 원소의 인덱스를 찾으려고 한다.
        // key를 배열 안에서 찾을 수 없다면, Collections.binarySearch()는 key보다 큰 엔트리
        // 중에서 인덱스 값이 가장 작은 인덱스에 음수 부호를 붙인 뒤 1을 뺀 값을 반환한다.
        // 따라서 반환하는 값이 음수라면,
        // 그 값의 절댓값에서 1을 빼면 우리가 원하는 인덱스 값을 얻을 수 있다.
        final int intervalIdx = Math.abs(it) - 1;
        return values.get(intervalIdx);
    } else {
        // it >= 0라면 uniform01이 prefixSumOfProbabilities의 값 중 하나와 같다는 뜻이다.
        // uniform01은 임의의 실수이므로, 이 값이 prefixSumOfProbabilities의 끝점 중
        // 하나와 같을 확률은 굉장히 적다.
        // 하지만 그 확률이 0은 아니므로, 이 경우를 반드시 고려해야 한다.
        return values.get(it);
    }
}
```

이 함수를 단 한 번만 호출한다면, 배열을 만드는 데 소요된 시간 O(n)이 이 알고리즘의 시간 복잡도가 된다. 추가로 배열을 사용하므로 공간 복잡도는 O(n)이다.

배열을 완성한 후에, 임의의 숫자 생성기를 한 번만 호출할 뒤 이진 탐색을 사용해서 균등하지 않은 확률로 임의의 숫자를 생성할 수 있다. 이 방법의 시간 복잡도는 O(log n)이다.

## 5.17 스도쿠 체크

스도쿠는 다양한 조합의 숫자를 배치하는 논리 기반 퍼즐 게임이다. 9*9 격자판에 숫자를 채우는데, 각 행과 열, 그리고 9개의 3*3 하위 격자판에 [1,9] 사이의 숫자가 단 한 개씩 배열해야 한다.

9*9 크기의 미완성된 격자판이 2차원 배열로 주어졌을 때 이 게임의 해법이 존재하는지 판별하고자 한다. 즉, 모든 행과 열, 3*3 하위 격자판에 중복되는 숫자가 없어야 한다. 2차원 배열에서 0으로 초기화되어 있는 엔트리는 빈칸을 나타내고, 그 외에는 [1,9] 숫자로 채워져 있다.

> 힌트: 직접 제한 사항을 테스트해 보라. 배열을 통해 집합을 표현할 수 있다.

특별한 알고리즘을 사용해야 하는 문제가 아니다. 단지 코드를 깔끔하게 작성하기만 하면 된다.

9개 행의 제한사항, 9개 행의 제한사항, 9개 하위 격자판의 제한사항을 확인할 필요가 있다. 비트 배열(bit array)을 사용해서 제한사항, 즉 [1,9] 사이의 숫자가 한 번 이상 등장했는지를 테스트하면 편리하다.

```java
// 미완성된 격자가 올바르게 배치되어 있는지 확인한다.
public static boolean isValidSudoku(List<List<Integer>> partialAssignment) {
    // 행 제한사항을 확인한다.
    for (int i = 0; i < partialAssignment.size(); ++i) {
        if (hasDuplicate(partialAssignment, i, i + 1, 0, partialAssignment.size())) {
            return false;
        }
    }

    // 열 제한사항을 확인한다.
    for (int j = 0; j < partialAssignment.size(); ++j) {
        if (hasDuplicate(partialAssignment, 0, partialAssignment.size(), j, j + 1)) {
            return false;
        }
    }

    // 격자판 제한사항을 확인한다.
    int regionSize = (int)Math.sqrt(partialAssignment.size());
    for (int I = 0; I < regionSize; ++I) {
        for (int J = 0; J < regionSize; ++J) {
            if (hasDuplicate(partialAssignment, regionSize * I, regionSize * (I + 1), regionSize * J, regionSize * (J + 1))) {
                return false;
            }
        }
    }

    return true;
}

// 부분배열 partialAssignment[startRow, endRow - 1][startCol, endCol - 1]이
// {1,2,..., partialAssignment.size()};의 값을 중복해서 가지고 있으면 true를 반환한다.
// 그렇지 않으면 false를 반환한다.
private static boolean hasDuplicate(List<List<Integer>> partialAssignment, int startRow, int endRow, int startCol, int endCol) {
    List<Boolean> isPresent = new ArrayList<>(
        Collections.nCopies(partialAssignment.size() + 1, false);
    );

    for (int i = startRow; i < endRow; ++i) {
        for (int j = startCol; j < endCol; ++j) {
            if (partialAssignment.get(i).get(j) != 0 && isPresent.get(partialAssignment.get(i).get(j))) {
                return true;
            }
            isPresent.set(partialAssignment.get(i).get(j), true);
        }
    }
    return false;
}
```

$n \times n$ 격자판과 $\sqrt{n} \times \sqrt{n}$의 하위 격자판이 주어졌을 때 n개의 행, n개의 열, 그리고 n개의 하위 격자판을 확인하는 데 필요한 시간 복잡도는 O(n^2) + O(n^2) + O(n^2/(sqrt(n)^2) * (sqrt(n)^2)) = O(n^2)이다. 추가 공간 복잡도는 비트 배열에 필요한 O(n)이 된다.

## 5.18 2차원 배열에 나선형으로 원소 배치하기

2차월 배열에 다양한 순서로 원소를 채워 넣을 수 있다. 가장 일반적인 방법은 열별(row-by-row) 혹은 행별(column-by-column)로 채워 넣는 것이다. 이 문제에서는 2차월 배열에 원소를 나선형으로 쓰는 방법을 생각해 볼 것이다.

> 힌트: 케이스 분석(case analysis)과 분할 정복법(divide-and-conquer)을 사용하라.

자연스럽게 배열의 가장 자리부터 안쪽으로 숫자를 읽어 나가면 된다. 첫 번째 행에서 n개의 원소, 마지막 열에서 n-1개의 원소, 마지막 행에서 n-1개의 원소, 그리고 첫 번째 열에서 n-2개의 원소를 읽으면 된다. 하지만 읽어야 하는 원소의 개수가 일정하지 않기 때문에 자칫 코드가 복잡해질 수 있다.

읽는 원소의 개수를 일정하게 유지시킬 필요가 있다. 먼저 첫 번째 행에서 n-1개의 원소를 읽는다. 그 뒤 마지막 열에서 n-1개의 원소를 읽고, 마지막 행에서 n-1개의 원소를 역순으로 읽는다. 마지막으로 첫 번째 열에서 n-1개의 원소를 역순으로 읽는다.

그 뒤에는, (n-2)*(n-2) 크기의 2차원 배열을 나선형으로 읽으면 된다. 따라서 2차원 배열의 가장자리 원소를 읽는 알고리즘을 n*n, (n-2)*(n-2), (n-4)*(n-4), ... 크기의 배열에 반복 적용하면 풀 수 있다. 배열의 길이가 홀수인 경우에는 마지막에 가운데 원소만 남게 되므로 예외처리를 해야 한다.

```java
public static List<Integer> matrixInSpiralOrder(List<List<Integer>> squareMatrix) {
    List<Integer> spiralOrdering = new ArrayList<>();
    for (int offset = 0; offset < Math.ceil(0.5 * squareMatrix.size()); ++offset) {
        matrixLayerInClockwise(squareMatrix, offset, spiralOrdering);
    }
    return spiralOrdering;
}

private static void matrixLayerInClockwise(List<List<Integer>> squareMatrix, int offset, List<Integer> spiralOrdering) {
    if (offset == squareMatrix.size() - offset - 1) {
        // squareMatrix의 크기는 홀수이므로, 마지막에 중심 원소 하나가 남는다.
        spiralOrdering.add(squareMatrix.get(offset).get(offset));
        return;
    }

    for (int j = offset; j < squareMatrix.size() - offset - 1; ++j) {
        spiralOrdering.add(squareMatrix.get(offset).get(j));
    }
    for (int i = offset; i < squareMatrix.size() - offset - 1; ++i) {
        spiralOrdering.add(squareMatrix.get(i).get(squareMatrix.size() - offset - 1));
    }
    for (int j = squareMatrix.size() - offset - 1; j > offset; --j) {
        spiralOrdering.add(squareMatrix.get(squareMatrix.size() - offset - 1).get(j));
    }
    for (int i = squareMatrix.size() - offset - 1; i > offset; --j) {
        spiralOrdering.add(squareMatrix.get(i).get(offset));
    }
}
```

시간 복잡도는 O(n^2)이고 공간 복잡도는 O(1)이다.

앞의 해법은 거의 비슷한 반복문을 4번이나 사용한다. 반복문을 하나만 사용해서 해결해 보자. 즉, 동일한 반복문 내에서 다음에 처리해야 할 원소와 읽을 방향(왼쪽, 오른쪽, 위, 아래)을 결정해야 한다. 행렬이 X축과 Y축으로 이루어진 2차원 격자에 놓여 있다고 생각해 보자. (i,j)는 열 i와 행 j에 있는 엔트리를 표현한다. (x,y)가 다음에 처리해야 할 원소라고 가정하자. x가 오른쪽 (n-1, 0)에 도달할 때까지 움직인다. 그 다음에는 아래쪽 (n-1, n-1)로 내려가고, 왼쪽 (0, n-1)로 움직인다. 마지막으로 (0,1)에 도달할 때까지 위로 올라간다. (0,0)은 이미 읽은 원소이므로 (0,0)이 아닌 (0,1)에서 멈춘다는 사실에 주목하라. 이미 읽은 엔트리는 표식을 위해 0으로 채워 넣었다(배열에 없는 값이라면 아무거나 사용해도 된다). (0,1)을 처리한 후에는 위와 비슷한 방법으로 (n-2, 1)까지 움직이고, (n-2,1)에서 멈춘다. 위와 같은 방식으로 모든 원소를 읽을 때까지 이 메서드를 반복한다.

```java
public static List<Integer> matrixInSpiralOrder(List<List<Integer>> squareMatrix) {
    final int[][] SHIFT = {{0,1}, {1,0}, {0,-1}, {-1,0}};
    int dir = 0, x = 0, y = 0;
    List<Integer> spiralOrdering = new ArrayList<>();

    for (int i = 0; i < squareMatrix.size() * squareMatrix.size(); ++i) {
        spiralOrdering.add(squareMatrix.get(x).get(y));
        squareMatrix.get(x).set(y, 0);
        int nextX = x + SHIFT[dir][0], nextY = y + SHIFT[dir][1];
        if (nextX < 0
            || nextX >= squareMatrix.size()
            || nextY < 0
            || nextY >= squareMatrix.size()
            || squareMatrix.get(nextX).get(nextY) == 0 )
        {
            dir = (dir + 1) % 4;
            nextX = x + SHIFT[dir][0];
            nextY = y + SHIFT[dir][1];
        }
        x = nextX;
        y = nextY;
    }
    return spiralOrdering;
}
```

시간 복잡도는 O(n^2)이고 공간 복잡도는 O(1)이다.

## 5.19 2차원 배열 회전하기

이미지 회전은 컴퓨터 그래픽스 분야에서 사용되는 기본적인 연산자 중 하나이다.

n*n 크기의 2차원 배열이 주어졌을 때 이를 시계 방향으로 90도만큼 회전시키는 프로그램을 작성하라.

> 힌트: 배열의 가장자리에 집중해 보라.

행렬을 회전시켰을 때 i번째 열은 기존 행렬의 i번째 행과 같다. 무식하게 생각해 보면 n*n 크기의 새로운 2차원 배열을 메모리에 할당한 뒤 회전시킨 결과를 여기에 출력하고(즉, 기존 행렬의 행을 열 위치에 적는다), 이 행렬을 다시 기존 행렬로 복사해 오면 된다. 주어진 행렬을 회전시키는 문제이므로 회전된 결과를 기존 행렬로 복사해야 한다. 시간과 공간 복잡도는 모두 O(n^2)이다.

하지만 추가 공간을 O(1)만큼만 사용해도 문제를 풀 수 있다. 먼저 생각할 수 있는 방법은 각 계층별로 회전을 하는 것이다. 회전 작업을 할 때 다른 계층은 서로 독립적으로 처리할 수 있기 때문이다. 또한 같은 계층에서도 4개의 원소를 한번에 회전할 수 있다. 예를 들어 1은 4의 위치에, 4는 16의 위치에, 16은 13의 위치에, 13은 1의 위치에 옮긴 뒤, 2는 8의 위치에, 8은 15의 위치에, 15는 9의 위치에, 9는 2의 위치에 옮길 수 있다. 다음 프로그램은 이러한 방식으로 가장자리 계층에서 시작해서 중심으로 다가오는 방식이다. 한 계층에서는 방금 설명한 네 개의 원소 교환을 반복적으로 수행한다.

```java
public static void rotateMatrix(List<List<Integer>> squareMatrix) {
    final int matrixSize = squareMax.size() - 1;
    for (int i = 0 i < (squareMatrix.size() / 2); ++i) {
        for (int j = i; j < matrixSize - i; ++j) {
            // 4개의 원소 교환을 수행한다.
            int temp1 = squareMatrix.get(matrixSize - j).get(i);
            int temp2 = squareMatrix.get(matrixSize - i).get(matrixSize - j);
            int temp3 = squareMatrix.get(j).get(matrixSize - i);
            int temp4 = squareMatrix.get(i).get(j);
            squareMatrix.get(i).set(j, temp1);
            squareMatrix.get(matrixSize - j).set(i, temp2);
            squareMatrix.get(matrixSize - i).set(matrixSize - j, temp3);
            squareMatrix.get(j).set(matrixSize - i, temp4);
        }
    }
}
```

시간 복잡도는 O(n^2)이고 추가 공간 복잡도는 O(1)이 된다.

약간의 제한 사항이 있긴 하지만 O(1)의 공간 및 시간 복잡도로 회전의 효과를 얻을 수 있는 방법이 있다. 객체 r을 반환하는 행렬 A를 가정해 보자. 회전된 행렬 A의 (i,j) 원소를 읽고자 할 때는 기존 행렬 A에서 [n-1-j,i]의 원소를 반환한다. 쓰는 연산도 이와 비슷하게 처리하면 된다. 객체 r은 단순히 행렬 A를 참조하기만 하므로 객체 r을 만드는 상수 시간이면 충분하다. 읽기 연산과 쓰기 연산을 수행하는 데 필요한 시간은 변하지는 않는다. 하지만 기존 행렬 A를 사용하고자 하는 클라이언트가 복수일 때에는 쓰기 연산에 문제가 될 수 있다. 왜냐하면 쓰기 연산은 기존 행렬 A를 수정하기 때문이다. 행렬 A에 직접 쓰는 작업이 아니더라도 저장된 객체의 메서드가 상태를 변경하면 시스템에 문제가 생길 수 있다. 이 경우에는 "쓸 때 복사하기(copy-on-write)"를 사용해서 이 문제를 해결할 수 있다.

```java
class RotateMatrix {
    private List<List<Integer>> wrapperSquareMatrix;

    public RotateMatrix(List<List<Integer>> squareMatrix) {
        this.wrapperSquareMatrix = squareMatrix;
    }

    public int readEntry(int i, int j) {
        return wrapperSquareMatrix.get(wrapperSquareMatrix.size() - 1 - j).get(i);
    }

    public void writeEntry(int i, int j, int v) {
        wrapperSquareMatrix.get(wrapperSquareMatrix.size() - 1 - j).set(i, v);
    }
}
```

## 5.20 파스칼의 삼각형에서 행 계산하기

각 행은 이전 행보다 엔트리가 하나 더 많고, 각 엔트리는 그 밑에 한 개 혹은 두 개의 엔트리를 접하고 있다(마지막 행은 제외). 첫 번째 행의 첫 번째 엔트리는 1로 시작한다. 그 다음 엔트리는 바로 위에 인접한 엔트리의 합으로 표현된다.

음이 아닌 정수 n이 주어졌을 때 파스칼의 삼각형에 해당하는 첫 n개의 행을 출력하는 프로그램을 작성하라.

> 힌트: 파스칼의 삼각형을 수식으로 작성해 보자.

무식한 방법은 그림에 나온 것과 비슷하게 배열을 채워 나가는 것이다. 참조할 인덱스는 범위를 올바르게 설정해야 한다.

인덱스 참조를 쉽게 하려면, 파스칼의 삼각형을 왼쪽으로 정렬하면 된다. 즉, 첫 번째 엔트리의 위치를 0번 위치로 설정한다. 이제 간단해졌다. j가 0 혹은 i라면, i번째 행의 j번째 엔트리는 1이 된다. 그 외의 엔트리는 (i-1)번째 행에서 (j-1)번째와 j번쨰 엔트리의 합이 된다. 첫 번째 행 R0는 <1>이다. 두 번째 행 R1은 <1,1>이 되고, 세 번째 행 R2는 <1, R1[0]+R1[1]=2, 1>이 된다. 네 번째 행 R3은 <1, R2[0]+R2[1]=3, R2[1]+R2[2]=3 ,1>이 된다.

```java
public static List<List<Integer>> generatePascalTriangle(int numRows) {
    List<List<Integer>> pascalTriangle = new ArrayList<>();
    for (int i = 0; i < numRows; ++i) {
        List<Integer> currRow = new ArrayList<>();
        for (int j = 0; j <= i; ++j) {
            // 만약 이 위에 인접한 두 엔트리가 존재한다면, 해당 엔트리의 값을 위에 인접한 두 엔트리의 합으로 나타내라.
            currRow.add((0 < j && j < i)
                        ? pascalTriangle.get(i-1).get(j-1) + pascalTriangle.get(i-1).get(j)
                        : 1);
        }
        pascalTriangle.add(currRow);
    }
    return pascalTriangle;
}
```

각 원소를 구하는 데 O(1)이 걸리므로 전체 시간 복잡도는 O(1+2+...+n) = O(n(n+1)/2) = O(n^2)가 된다.
