# 9장 이진 트리

이진 트리는 계층을 표현하는 데 유용한 자료구조로, 각 노드가 최대 두 개의 자식을 가지는 트리를 말한다. 형식상 이진 트리는 비어 있거나, 루트 노드 r과 함께 왼쪽 이진 트리 및 오른쪽 이진 트리로 구성된다. 각각의 부분 트리도 이진 트리의 형식을 만족해야 한다. 왼쪽 이진 트리는 루트의 왼쪽 부분 트리, 오른쪽 이진 트리는 루트의 오른쪽 부분 트리라 한다.

노드에는 보통, 다른 노드를 가리키기 위한 데이터 외에도 추가 데이터가 저장된다. 다음 코드는 노드의 프로토타입을 나타낸다.

```java
public static class BinaryTreeNode<T> {
    public T data;
    public BinaryTreeNode<T> left, right;
}
```

루트를 제외한 노드는 왼쪽 부분 트리 혹은 오른쪽 부분 트리의 노드이다. l이 p의 왼쪽 부분 트리의 노드라면 l을 p의 왼쪽 자식일아고 하고, p를 l의 부모라고 할 것이다. 오른쪽 자식도 마찬가지이다. 어떤 노드가 p의 왼쪽 혹은 오른쪽 자식이라면, 해당 노드는 p의 자식이다. 루트를 제외한 모든 노드는 유일한 부모 노드를 가지고 있다는 사실을 명심하라. 노드 객체에 부모를 가리키는 참조 변수가 있을 수도 있다(루트의 경우에는 null이 된다). 모든 노드는 루트 노드에서 해당 노드까지의 유일한 경로를 가지고 있고 그 경로에 있는 노드들은 자식 노드의 시퀀스로 이루어져 있다. 가끔 이 경로를 루트 노드에서 해당 노드까지의 탐색 경로라 하기도 한다.

이진 트리에서 부모-자식 관계는 조상-자손의 관계를 정의하기도 한다. 즉, 루트 노드에서 d 노드까지의 탐색 경로상에 있는 노드들은 d 노드의 조상 노드가 된다. 어떤 노드가 d의 조상이라면 d는 해당 노드의 자손이 된다. 관습적으로 각 노드는 자기 자신의 조상 노드이면서 자손 노드가 된다. 자기 자신 외에 자손이 없는 노드는 단말(leaf) 노드라 한다.

노드 n의 깊이는 루트 노드에서 n까지의 탐색 경로상에서 노드 n을 제외한 나머지 노드의 개수와 같다. 이진 트리의 높이는, 가장 깊은 노드의 깊이와 같다. 트리의 레벨은 같은 깊이에 있는 모든 노드를 뜻한다. 

![이진 트리의 예](img/binarytree0.svg)

노드 I는 J와 O의 부모이다. 노드 G는 B의 자손이다. L까지의 탐색 경로는 <A,I,J,K,L>이다. N의 깊이는 4이다. 노드 M이 가장 깊으므로 트리의 높이는 노드 M의 높이인 5이다. B를 루트로 한 부분 트리의 높이는 3이다. H를 루트로 한 부분 트리의 높이는 0이다. D,E,H,M,P는 트리의 단말 노드이다.

전 이진 트리(full binary tree)는 단말 노드를 제외한 모든 노드의 자식이 두 개인 트리를 말한다. 포화 이진 트리(perfect binary tree)는 전 이진 트리이면서 단말 노드의 깊이가 모두 같은 트리를 말한다. 완전 이진 트리(complete binary tree)는 마지막을 제외한 모든 레벨에서 노드가 완전히 채워져 있고, 모든 노드는 가능하면 왼쪽에 있는 트리를 말한다. 전 이진 트리에서 단말 노드가 아닌 노드의 개수가 단말 노드의 개수보다 하나 적다. 이는 귀납법을 사용하면 쉽게 증명할 수 있다. 높이가 h인 포화 이진 트리의 노드의 개수는 정확히 2^(h+1)-1개이고, 단말 노드의 개수는 2^h개이다. 노드가 n개인 완전 이진 트리의 높이는 floor(log n)이다. 오른쪽 자식이 없는 트리를 왼쪽으로 치우친 트리(left-skewed tree)라고 한다. 왼쪽 자식이 없는 트리는 오른쪽으로 치우친 트리(right-skewed tree)라 한다.

이진 트리의 핵심 연산은 모든 노드를 순회하는 연산이다(순회를 걷는다고도 표현한다). 여기에 몇 가지 순회 방법이 있다.

- 왼쪽 부분 트리, 루트, 오른쪽 부분 트리 순으로 순회하는 중위 순회(inorder traversal)가 있다. 위 그림의 트리를 중위 순회하면 다음과 같은 순서로 방문한다. <D,C,E,B,F,H,G,A,J,L,M,K,N,I,O,P>
- 루트, 왼쪽 부분 트리, 오른쪽 부분트리 순으로 순회하는 전위 순회(preorder traversal)가 있다. <A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P>
- 왼쪽 부분 트리, 오른쪽 부분 트리, 루트 순으로 순회하는 후위 순회(postorder traversal)가 있다. <D,E,C,H,G,F,B,M,L,N,K,J,P,O,I,A>

노드가 n개이고 높이가 h인 이진 트리 T가 있다고 가정하자. 재귀로 구현하면 순회의 시간 복잡도는 O(n), 공간 복잡도는 O(h)가 된다(공간 복잡도는 함수 호출 스택의 최대 깊이와 같다). 만약 각 노드에 부모를 가리키는 변수가 존재하면 O(1)의 추가 공간 복잡도만을 사용해서 순회할 수 있다.

트리의 종류가 다양하다. 그중에서 자주 사용되는 트리는 18장에서 간략히 설명한다.

## 이진 트리 부트캠프
이진 트리를 빠르게 이해하려면 기본적인 세 가지 순회방법(중위, 전위, 후위 순회)를 직접 구현해 보는 것이 좋다.

```java
public static void treeTraversal(BinaryTreeNode<Integer> root) {
    if (root != null) {
        // 전위 순회: 왼쪽 자식과 오른쪽 자식을 순회하기 전에 루트를 먼저 처리하는 방법
        System.out.println("Preorder: " + root.data);
        treeTraversal(root.left);
        // 중위 순회: 오른쪽 자식을 순회하기 위해 루트를 먼저 처리하고 그 다음에 왼쪽 자식을 순회하는 방법
        System.out.println("Ineorder: " + root.data);
        treeTraversal(root.right);
        // 후위 순회: 왼쪽 자식과 오른쪽 자식을 순회한 다음에 루트를 처리하는 방법
        System.out.println("Posteorder: " + root.data);
    }
}
```

노드가 n개일 때, 각 방법의 시간 복잡도는 O(n)이다. 명시적으로 메모리를 할당하지 않더라도 함수 호출 스택의 최대 깊이는 트리의 높이인 h에 근접하게 된다. 따라서 공간 복잡도는 O(h)가 된다. h의 하한값은 log n(완전 이진 트리)이고 상한 값은 n(한쪽으로 치우친 트리)이다.

## 이진 트리 문제를 풀기 전 꼭 알고 있어야 할 내용
- `재귀 알고리즘`은 트리에 적합하다. `함수 호출 스택`에 암묵적으로 할당된 공간은 공간 복잡도를 분석할 때 포함시켜야 한다.[문제 9.1]
- 어떤 트리 문제는 O(n) 공간을 사용한 쉬운 해법이 존재하지만 `주어진 트리의 노드`를 사용해서 공간 복잡도를 O(1)로 줄이는 까다로운 해법도 존재한다.[문제 9.14]
- 복잡도를 분석할 때 `왼쪽 혹은 오른쪽으로 치우친 트리`를 고려해 보라. 트리의 높이가 h일 때 O(h) 복잡도는 균형 잡힌 트리에서 O(log n)이지만 치우친 트리에서 O(n)이 된다. [문제 9.12]
- 노드에 `부모를 가리키는 변수`가 있다면, 코드를 좀 더 깔끔하게 작성할 수 있고 시간 및 공간 복잡도도 줄일 수 있다.[문제 9.10]
- `하나 있는 자식`이 단말 노드인 경우, `실수`하기 쉬우므로 유의한다.[문제 9.6]

